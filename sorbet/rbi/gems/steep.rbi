# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/steep/all/steep.rbi
#
# steep-1.3.2

module Steep
  def self.log_error(exn, message: nil); end
  def self.log_output; end
  def self.log_output=(output); end
  def self.logger; end
  def self.measure(message, level: nil); end
  def self.measure2(message, level: nil); end
  def self.new_logger(output, prev_level); end
end
module Steep::PathHelper
  def self.to_pathname(uri, dosish: nil); end
  def self.to_uri(path, dosish: nil); end
  def to_pathname(uri, dosish: nil); end
  def to_uri(path, dosish: nil); end
end
module Shims
end
module Shims::EnumerableFilterMap
  def filter_map(&block); end
end
module Shims::SymbolStartWith
  def end_with?(*args); end
  def start_with?(*args); end
end
module Steep::Equatable
  def ==(other); end
  def eql?(other); end
  def hash; end
end
class Steep::InstanceMethodName < Struct
  def method_name; end
  def method_name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def to_s; end
  def type_name; end
  def type_name=(_); end
end
class Steep::SingletonMethodName < Struct
  def method_name; end
  def method_name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def to_s; end
  def type_name; end
  def type_name=(_); end
end
class Object < BasicObject
  def MethodName(string); end
end
module Steep::NodeHelper
  def each_child_node(node, &block); end
  def each_descendant_node(node, &block); end
  def value_node?(node); end
end
module Steep::AST
end
module Steep::AST::Types
end
module Steep::AST::Types::Helper
end
module Steep::AST::Types::Helper::ChildrenLevel
  def level_of_children(children); end
end
module Steep::AST::Types::Helper::NoFreeVariables
  def free_variables; end
end
module Steep::AST::Types::Helper::NoChild
  def each_child(&block); end
end
class Steep::AST::Types::Any
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(location: nil); end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::NoChild
  include Steep::AST::Types::Helper::NoFreeVariables
end
class Steep::AST::Types::Instance
  def ==(other); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(location: nil); end
  def level; end
  def location; end
  def self.instance; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::NoChild
end
class Steep::AST::Types::Class
  def ==(other); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(location: nil); end
  def level; end
  def location; end
  def self.instance; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::NoChild
end
class Steep::AST::Types::Union
  def ==(other); end
  def each_child(&block); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(types:, location: nil); end
  def level; end
  def location; end
  def self.build(types:, location: nil); end
  def subst(s); end
  def to_s; end
  def types; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::ChildrenLevel
end
class Steep::AST::Types::Var
  def ==(other); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(name:, location: nil); end
  def level; end
  def location; end
  def name; end
  def self.fresh(name, location: nil); end
  def self.fresh_name(name); end
  def subst(s); end
  def to_s; end
  def update(name: nil, location: nil); end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::NoChild
end
module Steep::AST::Types::Name
end
class Steep::AST::Types::Name::Base
  def initialize(name:, location: nil); end
  def level; end
  def location; end
  def name; end
  def subst(s); end
  include Steep::AST::Types::Helper::NoFreeVariables
end
class Steep::AST::Types::Name::Applying < Steep::AST::Types::Name::Base
  def ==(other); end
  def args; end
  def each_child(&block); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(name:, args:, location: nil); end
  def level; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::ChildrenLevel
end
class Steep::AST::Types::Name::Singleton < Steep::AST::Types::Name::Base
  def ==(other); end
  def eql?(other); end
  def hash; end
  def to_s; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::NoChild
end
class Steep::AST::Types::Name::Instance < Steep::AST::Types::Name::Applying
  def to_module; end
end
class Steep::AST::Types::Name::Interface < Steep::AST::Types::Name::Applying
end
class Steep::AST::Types::Name::Alias < Steep::AST::Types::Name::Applying
end
class Steep::AST::Types::Self
  def ==(other); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(location: nil); end
  def level; end
  def location; end
  def self.instance; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::NoChild
end
class Steep::AST::Types::Intersection
  def ==(other); end
  def each_child(&block); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(types:, location: nil); end
  def level; end
  def location; end
  def self.build(types:, location: nil); end
  def subst(s); end
  def to_s; end
  def types; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::ChildrenLevel
end
class Steep::AST::Types::Void
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(location: nil); end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::NoChild
  include Steep::AST::Types::Helper::NoFreeVariables
end
class Steep::AST::Types::Bot
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(location: nil); end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::NoChild
  include Steep::AST::Types::Helper::NoFreeVariables
end
class Steep::AST::Types::Top
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(location: nil); end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::NoChild
  include Steep::AST::Types::Helper::NoFreeVariables
end
class Steep::AST::Types::Nil
  def ==(other); end
  def back_type; end
  def eql?(other); end
  def hash; end
  def initialize(location: nil); end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::NoChild
  include Steep::AST::Types::Helper::NoFreeVariables
end
class Steep::AST::Types::Literal
  def ==(other); end
  def back_type; end
  def eql?(other); end
  def hash; end
  def initialize(value:, location: nil); end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def value; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::NoChild
  include Steep::AST::Types::Helper::NoFreeVariables
end
class Steep::AST::Types::Boolean
  def ==(other); end
  def back_type; end
  def eql?(other); end
  def hash; end
  def initialize(location: nil); end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::NoChild
  include Steep::AST::Types::Helper::NoFreeVariables
end
class Steep::AST::Types::Tuple
  def ==(other); end
  def each_child(&block); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(types:, location: nil); end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def types; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::ChildrenLevel
end
class Steep::AST::Types::Proc
  def ==(other); end
  def back_type; end
  def block; end
  def block_required?; end
  def each_child(&block); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(type:, block:, self_type:, location: nil); end
  def level; end
  def location; end
  def map_type(&block); end
  def one_arg?; end
  def self_type; end
  def subst(s); end
  def to_s; end
  def type; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::ChildrenLevel
end
class Steep::AST::Types::Record
  def ==(other); end
  def each_child(&block); end
  def elements; end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(elements:, location: nil); end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  def with_location(new_location); end
  include Steep::AST::Types::Helper::ChildrenLevel
end
module Steep::AST::Types::Logic
end
class Steep::AST::Types::Logic::Base
  def ==(other); end
  def eql?(other); end
  def hash; end
  def level; end
  def location; end
  def subst(s); end
  def to_s; end
  include Steep::AST::Types::Helper::NoChild
  include Steep::AST::Types::Helper::NoFreeVariables
end
class Steep::AST::Types::Logic::Not < Steep::AST::Types::Logic::Base
  def initialize(location: nil); end
end
class Steep::AST::Types::Logic::ReceiverIsNil < Steep::AST::Types::Logic::Base
  def initialize(location: nil); end
end
class Steep::AST::Types::Logic::ReceiverIsNotNil < Steep::AST::Types::Logic::Base
  def initialize(location: nil); end
end
class Steep::AST::Types::Logic::ReceiverIsArg < Steep::AST::Types::Logic::Base
  def initialize(location: nil); end
end
class Steep::AST::Types::Logic::ArgIsReceiver < Steep::AST::Types::Logic::Base
  def initialize(location: nil); end
end
class Steep::AST::Types::Logic::ArgEqualsReceiver < Steep::AST::Types::Logic::Base
  def initialize(location: nil); end
end
class Steep::AST::Types::Logic::Env < Steep::AST::Types::Logic::Base
  def ==(other); end
  def eql?(other); end
  def falsy; end
  def hash; end
  def initialize(truthy:, falsy:, type:, location: nil); end
  def inspect; end
  def to_s; end
  def truthy; end
  def type; end
end
module Steep::AST::Annotation
end
module Steep::AST::Annotation::Located
  def line; end
  def location; end
end
class Steep::AST::Annotation::Named
  def ==(other); end
  def initialize(name:, type:, location: nil); end
  def name; end
  def type; end
  include Steep::AST::Annotation::Located
end
class Steep::AST::Annotation::Typed
  def ==(other); end
  def initialize(type:, location: nil); end
  def type; end
  include Steep::AST::Annotation::Located
end
class Steep::AST::Annotation::ReturnType < Steep::AST::Annotation::Typed
end
class Steep::AST::Annotation::BlockType < Steep::AST::Annotation::Typed
end
class Steep::AST::Annotation::SelfType < Steep::AST::Annotation::Typed
end
class Steep::AST::Annotation::InstanceType < Steep::AST::Annotation::Typed
end
class Steep::AST::Annotation::ModuleType < Steep::AST::Annotation::Typed
end
class Steep::AST::Annotation::BreakType < Steep::AST::Annotation::Typed
end
class Steep::AST::Annotation::MethodType < Steep::AST::Annotation::Named
end
class Steep::AST::Annotation::VarType < Steep::AST::Annotation::Named
end
class Steep::AST::Annotation::ConstType < Steep::AST::Annotation::Named
end
class Steep::AST::Annotation::IvarType < Steep::AST::Annotation::Named
end
class Steep::AST::Annotation::Implements
  def ==(other); end
  def initialize(name:, location: nil); end
  def name; end
  include Steep::AST::Annotation::Located
end
class Steep::AST::Annotation::Implements::Module
  def ==(other); end
  def args; end
  def eql?(other); end
  def hash; end
  def initialize(name:, args:); end
  def name; end
end
class Steep::AST::Annotation::Dynamic
  def ==(other); end
  def initialize(names:, location: nil); end
  def names; end
  include Steep::AST::Annotation::Located
end
class Steep::AST::Annotation::Dynamic::Name
  def ==(other); end
  def initialize(name:, kind:, location: nil); end
  def instance_method?; end
  def kind; end
  def location; end
  def module_method?; end
  def name; end
end
class Steep::AST::Annotation::Collection
  def absolute_type(type); end
  def annotations; end
  def any?(&block); end
  def block_type; end
  def block_type_annotation; end
  def break_type; end
  def break_type_annotation; end
  def const_type_annotations; end
  def const_types; end
  def context; end
  def dynamic_annotations; end
  def factory; end
  def implement_module_annotation; end
  def include?(obj); end
  def initialize(annotations:, factory:, context:); end
  def instance_dynamics; end
  def instance_type; end
  def instance_type_annotation; end
  def ivar_type_annotations; end
  def ivar_types; end
  def lvar_types; end
  def merge_block_annotations(annotations); end
  def method_type(name); end
  def method_type_annotations; end
  def module_dynamics; end
  def module_type; end
  def module_type_annotation; end
  def return_type; end
  def return_type_annotation; end
  def self_type; end
  def self_type_annotation; end
  def size; end
  def var_type(lvar: nil, ivar: nil, const: nil); end
  def var_type_annotations; end
end
module Steep::AST::Node
end
class Steep::AST::Node::TypeAssertion
  def initialize(location); end
  def line; end
  def location; end
  def self.parse(location); end
  def source; end
  def type(context, factory, type_vars); end
  def type?(context, factory, type_vars); end
  def type_location; end
  def type_str; end
end
class Steep::AST::Node::TypeApplication
  def initialize(location); end
  def line; end
  def location; end
  def node; end
  def self.parse(location); end
  def set_node(node); end
  def source; end
  def type_location; end
  def type_str; end
  def types(context, factory, type_vars); end
  def types?(context, factory, type_vars); end
end
module Steep::AST::Builtin
  def self.any_type; end
  def self.bool_type; end
  def self.bottom_type; end
  def self.false_type; end
  def self.nil_type; end
  def self.optional(type); end
  def self.top_type; end
  def self.true_type; end
end
class Steep::AST::Builtin::Type
  def arity; end
  def initialize(module_name, arity: nil); end
  def instance_type(*args, fill_untyped: nil); end
  def instance_type?(type, args: nil); end
  def module_name; end
  def module_type; end
  def module_type?(type); end
end
class Steep::AST::Types::Factory
  def absolute_type(type, context:); end
  def absolute_type_name(type_name, context:); end
  def class_name?(type_name); end
  def deep_expand_alias(type, recursive: nil); end
  def definition_builder; end
  def env; end
  def expand_alias(type); end
  def flatten_union(type, acc = nil); end
  def function_1(func); end
  def initialize(builder:); end
  def inspect; end
  def instance_type(type_name, args: nil, location: nil); end
  def method_type(method_type, method_decls:); end
  def method_type_1(method_type); end
  def module_name?(type_name); end
  def params(type); end
  def try_instance_type(type); end
  def try_singleton_type(type); end
  def type(type); end
  def type_1(type); end
  def type_1_opt(type); end
  def type_cache; end
  def type_name_resolver; end
  def type_opt(type); end
  def type_param(type_param); end
  def type_param_1(type_param); end
  def unfold(type_name, args); end
  def unwrap_optional(type); end
end
class RBS::Location
  def as_lsp_range; end
end
class Parser::Source::Range
  def as_lsp_range; end
end
module Steep::Interface
end
class Steep::Interface::TypeParam
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(name:, upper_bound:, variance:, unchecked:, location: nil); end
  def location; end
  def name; end
  def self.rename(params, conflicting_names = nil, new_names = nil); end
  def subst(s); end
  def to_s; end
  def unchecked; end
  def update(name: nil, upper_bound: nil, variance: nil, unchecked: nil, location: nil); end
  def upper_bound; end
  def variance; end
end
class Steep::Interface::Function
  def ==(other); end
  def closed?; end
  def each_child(&block); end
  def each_type(&block); end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(params:, return_type:, location:); end
  def location; end
  def map_type(&block); end
  def params; end
  def return_type; end
  def subst(s); end
  def to_s; end
  def with(params: nil, return_type: nil); end
end
class Steep::Interface::Function::Params
  def &(other); end
  def +(other); end
  def ==(other); end
  def closed?; end
  def drop_first; end
  def each_positional_param(&block); end
  def each_type(&block); end
  def empty?; end
  def eql?(other); end
  def first_param; end
  def flat_keywords; end
  def flat_unnamed_params; end
  def free_variables; end
  def has_keywords?; end
  def has_positional?; end
  def hash; end
  def initialize(positional_params:, keyword_params:); end
  def keyword_params; end
  def map_type(&block); end
  def optional; end
  def optional?; end
  def optional_keywords; end
  def positional_params; end
  def required; end
  def required_keywords; end
  def rest; end
  def rest_keywords; end
  def self.build(required: nil, optional: nil, rest: nil, required_keywords: nil, optional_keywords: nil, rest_keywords: nil); end
  def self.empty; end
  def size; end
  def subst(s); end
  def to_s; end
  def update(positional_params: nil, keyword_params: nil); end
  def with_first_param(param); end
  def without_keywords; end
  def |(other); end
end
module Steep::Interface::Function::Params::Utils
  def intersection(*types); end
  def union(*types, null: nil); end
end
class Steep::Interface::Function::Params::PositionalParams
  def ==(other); end
  def each(&block); end
  def each_type; end
  def eql?(other); end
  def hash; end
  def head; end
  def initialize(head:, tail:); end
  def map(&block); end
  def map_type(&block); end
  def self.build(required:, optional:, rest:); end
  def self.merge_for_intersection(xs, ys); end
  def self.merge_for_overload(xs, ys); end
  def self.merge_for_union(xs, ys); end
  def self.optional(type, tail = nil); end
  def self.required(type, tail = nil); end
  def self.rest(type, tail = nil); end
  def size; end
  def subst(s); end
  def tail; end
  def to_ary; end
  extend Steep::Interface::Function::Params::Utils
end
class Steep::Interface::Function::Params::PositionalParams::Base
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(type); end
  def map_type(&block); end
  def subst(s); end
  def type; end
  def var_type; end
end
class Steep::Interface::Function::Params::PositionalParams::Required < Steep::Interface::Function::Params::PositionalParams::Base
end
class Steep::Interface::Function::Params::PositionalParams::Optional < Steep::Interface::Function::Params::PositionalParams::Base
end
class Steep::Interface::Function::Params::PositionalParams::Rest < Steep::Interface::Function::Params::PositionalParams::Base
end
class Steep::Interface::Function::Params::KeywordParams
  def &(other); end
  def +(other); end
  def ==(other); end
  def each(&block); end
  def each_type; end
  def empty?; end
  def eql?(other); end
  def hash; end
  def initialize(requireds: nil, optionals: nil, rest: nil); end
  def keywords; end
  def map_type(&block); end
  def optionals; end
  def requireds; end
  def rest; end
  def size; end
  def subst(s); end
  def update(requireds: nil, optionals: nil, rest: nil); end
  def |(other); end
  include Steep::Interface::Function::Params::Utils
end
class Steep::Interface::Block
  def +(other); end
  def ==(other); end
  def closed?; end
  def eql?(other); end
  def free_variables; end
  def hash; end
  def initialize(type:, optional:, self_type:); end
  def map_type(&block); end
  def optional; end
  def optional?; end
  def required?; end
  def self_type; end
  def subst(s); end
  def to_optional; end
  def to_s; end
  def type; end
end
class Steep::Interface::MethodType
  def &(other); end
  def +(other); end
  def ==(other); end
  def block; end
  def each_type(&block); end
  def eql?(other); end
  def equals_modulo_type_params?(other); end
  def free_variables; end
  def hash; end
  def initialize(type_params:, type:, block:, method_decls:); end
  def instantiate(s); end
  def map_type(&block); end
  def method_decls; end
  def self.intersection(type1, type2, check); end
  def self.try_type_params(type1, type2, check, generate, relation); end
  def self.union(type1, type2, check); end
  def subst(s); end
  def to_s; end
  def type; end
  def type_params; end
  def unify_overload(other); end
  def with(type_params: nil, type: nil, block: nil, method_decls: nil); end
  def |(other); end
end
class Steep::Interface::Substitution
  def [](key); end
  def add!(v, ty); end
  def apply?(type); end
  def dictionary; end
  def domain; end
  def empty?; end
  def except!(vars); end
  def except(vars); end
  def initialize(dictionary:, instance_type:, module_type:, self_type:); end
  def instance_type; end
  def key?(var); end
  def merge!(s, overwrite: nil); end
  def merge(s); end
  def module_type; end
  def self.build(vars, types = nil, instance_type: nil, module_type: nil, self_type: nil); end
  def self.empty; end
  def self_type; end
  def to_s; end
end
class Steep::Interface::Substitution::InvalidSubstitutionError < StandardError
  def initialize(vars_size:, types_size:); end
  def types_size; end
  def vars_size; end
end
class Steep::Interface::Shape
  def initialize(type:, private:, methods: nil); end
  def methods; end
  def private?; end
  def public?; end
  def subst(s, type: nil); end
  def to_s; end
  def type; end
  def update(type: nil, methods: nil); end
end
class Steep::Interface::Shape::Entry
  def initialize(method_types:); end
  def method_types; end
  def to_s; end
end
class Steep::Interface::Shape::Methods
  def +(other); end
  def [](name); end
  def []=(name, entry); end
  def each(&block); end
  def each_name(&block); end
  def initialize(substs:, methods:); end
  def key?(name); end
  def merge!(other); end
  def methods; end
  def push_substitution(subst); end
  def resolved_methods; end
  def subst; end
  def substs; end
  include Enumerable
end
class Steep::Interface::Builder
  def cache; end
  def definition_builder; end
  def factory; end
  def fetch_cache(type, public_only, config); end
  def include_self?(type); end
  def initialize(factory); end
  def intersection_shape(type, shapes, public_only); end
  def method_name_for(type_def, name); end
  def object_shape(type, public_only, keep_self, keep_instance, keep_singleton); end
  def proc_shape(proc, public_only, config); end
  def raw_instance_object_shape_cache; end
  def raw_interface_object_shape_cache; end
  def raw_object_cache; end
  def raw_object_shape(type, public_only, subst); end
  def raw_singleton_object_shape_cache; end
  def record_shape(record, public_only, config); end
  def replace_primitive_method(method_name, method_def, method_type); end
  def shape(type, public_only:, config:); end
  def subtyping; end
  def tuple_shape(tuple, public_only, config); end
  def union_shape(shape_type, shapes, public_only); end
end
class Steep::Interface::Builder::Config
  def ==(other); end
  def class_type; end
  def eql?(other); end
  def hash; end
  def initialize(self_type:, class_type:, instance_type:, variable_bounds:, resolve_self: nil, resolve_class: nil, resolve_instance: nil); end
  def instance_type; end
  def no_resolve; end
  def resolve?; end
  def resolve_class; end
  def resolve_instance; end
  def resolve_self; end
  def self_type; end
  def subst; end
  def update(self_type: nil, class_type: nil, instance_type: nil, resolve_self: nil, resolve_class: nil, resolve_instance: nil, variable_bounds: nil); end
  def variable_bounds; end
end
module Steep::Subtyping
end
module Steep::Subtyping::Result
end
class Steep::Subtyping::Result::Base
  def else; end
  def failure?; end
  def failure_path(path = nil); end
  def initialize(relation); end
  def relation; end
  def then; end
end
class Steep::Subtyping::Result::Skip < Steep::Subtyping::Result::Base
  def failure?; end
  def failure_path(path = nil); end
  def success?; end
end
class Steep::Subtyping::Result::Expand < Steep::Subtyping::Result::Base
  def child; end
  def failure_path(path = nil); end
  def initialize(relation, &block); end
  def success?; end
end
class Steep::Subtyping::Result::All < Steep::Subtyping::Result::Base
  def add(*relations, &block); end
  def add_result(result); end
  def branches; end
  def failure?; end
  def failure_path(path = nil); end
  def initialize(relation); end
  def success?; end
end
class Steep::Subtyping::Result::Any < Steep::Subtyping::Result::Base
  def add(*relations, &block); end
  def branches; end
  def failure_path(path = nil); end
  def initialize(relation); end
  def success?; end
end
class Steep::Subtyping::Result::Success < Steep::Subtyping::Result::Base
  def failure_path(path = nil); end
  def success?; end
end
class Steep::Subtyping::Result::Failure < Steep::Subtyping::Result::Base
  def error; end
  def failure_path(path = nil); end
  def initialize(relation, error); end
  def success?; end
end
class Steep::Subtyping::Result::Failure::MethodMissingError
  def initialize(name:); end
  def message; end
  def name; end
end
class Steep::Subtyping::Result::Failure::BlockMismatchError
  def initialize(name:); end
  def message; end
  def name; end
end
class Steep::Subtyping::Result::Failure::ParameterMismatchError
  def initialize(name:); end
  def message; end
  def name; end
end
class Steep::Subtyping::Result::Failure::UnknownPairError
  def initialize(relation:); end
  def message; end
  def relation; end
end
class Steep::Subtyping::Result::Failure::PolyMethodSubtyping
  def initialize(name:); end
  def message; end
  def name; end
end
class Steep::Subtyping::Result::Failure::UnsatisfiedConstraints
  def error; end
  def initialize(error); end
  def message; end
  def result; end
  def sub_type; end
  def super_type; end
  def var; end
end
class Steep::Subtyping::Result::Failure::SelfBindingMismatch
  def message; end
end
module Steep::Subtyping::Result::Helper
  def All(relation, &block); end
  def Any(relation, &block); end
  def Expand(relation, &block); end
  def Failure(relation, error = nil); end
  def Skip(relation); end
  def Success(relation); end
  def success(relation); end
end
class Steep::Subtyping::Check
  def Relation(sub, sup); end
  def alias?(type); end
  def arg_type?(type); end
  def assumptions; end
  def builder; end
  def cache; end
  def cache_bounds(relation); end
  def cacheable?(relation); end
  def check(relation, constraints:, self_type:, instance_type:, class_type:); end
  def check_constraints(relation, variables:, variance:); end
  def check_function(name, relation); end
  def check_generic_method_type(name, relation); end
  def check_interface(relation); end
  def check_method(name, relation); end
  def check_method_params(name, relation); end
  def check_method_type(name, relation); end
  def check_self_type_binding(relation, sub_self, super_self); end
  def check_type(relation); end
  def check_type0(relation); end
  def check_type_arg(relation); end
  def class_type; end
  def constraints; end
  def definition_for_type(type); end
  def each_ancestor(ancestors, &block); end
  def expand_alias(type, &block); end
  def expand_block_given(name, relation, &block); end
  def factory; end
  def false_type?(type); end
  def hole_path(type, path = nil); end
  def initialize(builder:); end
  def instance_super_types(type_name, args:); end
  def instance_type; end
  def match_method_type_fails?(name, type1, type2); end
  def match_params(name, relation); end
  def push_assumption(relation); end
  def push_variable_bounds(params); end
  def same_type?(relation); end
  def self_type; end
  def singleton_super_types(type_name); end
  def true_type?(type); end
  def variable_upper_bound(name); end
  def variable_upper_bounds; end
  def with_context(self_type:, instance_type:, class_type:, constraints:); end
  include Steep::Subtyping::Result::Helper
end
class Steep::Subtyping::Cache
  def [](relation, self_type, instance_type, class_type, bounds); end
  def []=(relation, self_type, instance_type, class_type, bounds, value); end
  def initialize; end
  def no_subtype_cache?; end
  def subtype(relation, self_type, instance_type, class_type, bounds); end
  def subtypes; end
end
class Steep::Subtyping::Relation
  def ==(other); end
  def assert_type(type); end
  def block!; end
  def block?; end
  def eql?(other); end
  def flip; end
  def function!; end
  def function?; end
  def hash; end
  def initialize(sub_type:, super_type:); end
  def interface!; end
  def interface?; end
  def map; end
  def method!; end
  def method?; end
  def params!; end
  def params?; end
  def sub_type; end
  def super_type; end
  def to_ary; end
  def to_s; end
  def type!; end
  def type?; end
end
class Steep::Subtyping::Constraints
  def add(var, sub_type: nil, super_type: nil, skip: nil); end
  def add_var(*vars); end
  def dictionary; end
  def each; end
  def eliminate_variable(type, to:); end
  def empty?; end
  def has_constraint?(var); end
  def initialize(unknowns:); end
  def lower_bound(var, skip: nil); end
  def lower_bound_types(var_name); end
  def self.empty; end
  def solution(checker, variables:, variance: nil, self_type: nil, instance_type: nil, class_type: nil, context: nil); end
  def to_s; end
  def unknown!(var); end
  def unknown?(var); end
  def unknowns; end
  def upper_bound(var, skip: nil); end
  def upper_bound_types(var_name); end
  def vars; end
end
class Steep::Subtyping::Constraints::UnsatisfiedInvariantError < StandardError
  def constraints; end
  def initialize(reason:, constraints:); end
  def reason; end
end
class Steep::Subtyping::Constraints::UnsatisfiedInvariantError::VariablesUnknownsNotDisjoint
  def initialize(vars:); end
  def message; end
  def vars; end
end
class Steep::Subtyping::Constraints::UnsatisfiedInvariantError::VariablesFreeVariablesNotDisjoint
  def initialize(var: nil, lower_bound: nil, upper_bound: nil); end
  def lower_bound; end
  def message; end
  def upper_bound; end
  def var; end
end
class Steep::Subtyping::Constraints::UnsatisfiedInvariantError::UnknownsFreeVariableNotDisjoint
  def initialize(var:, lower_bound:, upper_bound:); end
  def lower_bound; end
  def message; end
  def upper_bound; end
  def var; end
end
class Steep::Subtyping::Constraints::UnsatisfiableConstraint < StandardError
  def initialize(var:, sub_type:, super_type:, result:); end
  def result; end
  def sub_type; end
  def super_type; end
  def var; end
end
class Steep::Subtyping::Constraints::Context < Struct
  def class_type; end
  def class_type=(_); end
  def instance_type; end
  def instance_type=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def self_type; end
  def self_type=(_); end
  def variance; end
  def variance=(_); end
end
class Steep::Subtyping::VariableVariance
  def contravariant?(var); end
  def contravariants; end
  def covariant?(var); end
  def covariants; end
  def initialize(covariants:, contravariants:); end
  def invariant?(var); end
  def self.add_params(params, block:, covariants:, contravariants:); end
  def self.add_type(type, variance:, covariants:, contravariants:); end
  def self.from_method_type(method_type); end
  def self.from_type(type); end
end
module Steep::Diagnostic
end
module Steep::Diagnostic::Helper
  def error_name; end
  def full_message; end
end
module Steep::Diagnostic::Ruby
  def self.all_error; end
  def self.default; end
  def self.lenient; end
  def self.strict; end
end
class Steep::Diagnostic::Ruby::Base
  def detail_lines; end
  def diagnostic_code; end
  def header_line; end
  def initialize(node:, location: nil); end
  def location; end
  def node; end
  include Steep::Diagnostic::Helper
end
module Steep::Diagnostic::Ruby::ResultPrinter
  def detail_lines; end
  def relation_message(relation); end
end
class Steep::Diagnostic::Ruby::IncompatibleAssignment < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, lhs_type:, rhs_type:, result:); end
  def lhs_type; end
  def result; end
  def rhs_type; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::UnexpectedPositionalArgument < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, params:); end
  def node; end
  def params; end
end
class Steep::Diagnostic::Ruby::InsufficientPositionalArguments < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, params:); end
  def node; end
  def params; end
end
class Steep::Diagnostic::Ruby::UnexpectedKeywordArgument < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, params:); end
  def node; end
  def params; end
end
class Steep::Diagnostic::Ruby::InsufficientKeywordArguments < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, params:, missing_keywords:); end
  def method_name; end
  def method_type; end
  def missing_keywords; end
  def node; end
end
class Steep::Diagnostic::Ruby::UnresolvedOverloading < Steep::Diagnostic::Ruby::Base
  def detail_lines; end
  def header_line; end
  def initialize(node:, receiver_type:, method_name:, method_types:); end
  def method_name; end
  def method_types; end
  def node; end
  def receiver_type; end
end
class Steep::Diagnostic::Ruby::ArgumentTypeMismatch < Steep::Diagnostic::Ruby::Base
  def actual; end
  def expected; end
  def header_line; end
  def initialize(node:, expected:, actual:, result:); end
  def node; end
  def result; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::NoMethod < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, type:, method:); end
  def method; end
  def type; end
end
class Steep::Diagnostic::Ruby::ReturnTypeMismatch < Steep::Diagnostic::Ruby::Base
  def actual; end
  def expected; end
  def header_line; end
  def initialize(node:, expected:, actual:, result:); end
  def result; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::UnexpectedBlockGiven < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, method_type:); end
  def method_type; end
end
class Steep::Diagnostic::Ruby::RequiredBlockMissing < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, method_type:); end
  def method_type; end
end
class Steep::Diagnostic::Ruby::BlockTypeMismatch < Steep::Diagnostic::Ruby::Base
  def actual; end
  def expected; end
  def header_line; end
  def initialize(node:, expected:, actual:, result:); end
  def result; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::BlockBodyTypeMismatch < Steep::Diagnostic::Ruby::Base
  def actual; end
  def expected; end
  def header_line; end
  def initialize(node:, expected:, actual:, result:); end
  def result; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::BreakTypeMismatch < Steep::Diagnostic::Ruby::Base
  def actual; end
  def expected; end
  def header_line; end
  def initialize(node:, expected:, actual:, result:); end
  def result; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::ImplicitBreakValueMismatch < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, jump_type:, result:); end
  def jump_type; end
  def result; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::UnexpectedJump < Steep::Diagnostic::Ruby::Base
  def header_line; end
end
class Steep::Diagnostic::Ruby::UnexpectedJumpValue < Steep::Diagnostic::Ruby::Base
  def header_line; end
end
class Steep::Diagnostic::Ruby::MethodArityMismatch < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, method_type:); end
  def method_type; end
end
class Steep::Diagnostic::Ruby::MethodParameterMismatch < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(method_param:, method_type:); end
  def method_param; end
  def method_type; end
end
class Steep::Diagnostic::Ruby::DifferentMethodParameterKind < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(method_param:, method_type:); end
  def method_param; end
  def method_type; end
end
class Steep::Diagnostic::Ruby::IncompatibleMethodTypeAnnotation < Steep::Diagnostic::Ruby::Base
  def annotation_method; end
  def initialize(node:, interface_method:, annotation_method:, result:); end
  def interface_method; end
  def result; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::MethodReturnTypeAnnotationMismatch < Steep::Diagnostic::Ruby::Base
  def annotation_type; end
  def header_line; end
  def initialize(node:, method_type:, annotation_type:, result:); end
  def method_type; end
  def result; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::MethodBodyTypeMismatch < Steep::Diagnostic::Ruby::Base
  def actual; end
  def expected; end
  def header_line; end
  def initialize(node:, expected:, actual:, result:); end
  def result; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::UnexpectedYield < Steep::Diagnostic::Ruby::Base
  def header_line; end
end
class Steep::Diagnostic::Ruby::UnexpectedSuper < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, method:); end
  def method; end
end
class Steep::Diagnostic::Ruby::MethodDefinitionMissing < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, module_name:, kind:, missing_method:); end
  def kind; end
  def missing_method; end
  def module_name; end
end
class Steep::Diagnostic::Ruby::UnexpectedDynamicMethod < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, module_name:, method_name:); end
  def method_name; end
  def module_name; end
end
class Steep::Diagnostic::Ruby::UnknownConstant < Steep::Diagnostic::Ruby::Base
  def class!; end
  def header_line; end
  def initialize(node:, name:); end
  def kind; end
  def module!; end
  def name; end
end
class Steep::Diagnostic::Ruby::UnknownInstanceVariable < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, name:); end
  def name; end
end
class Steep::Diagnostic::Ruby::UnknownGlobalVariable < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, name:); end
  def name; end
end
class Steep::Diagnostic::Ruby::FallbackAny < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:); end
end
class Steep::Diagnostic::Ruby::UnsatisfiableConstraint < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, method_type:, var:, sub_type:, super_type:, result:); end
  def method_type; end
  def result; end
  def sub_type; end
  def super_type; end
  def var; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::IncompatibleAnnotation < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, var_name:, result:, relation:); end
  def relation; end
  def result; end
  def var_name; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::IncompatibleTypeCase < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, var_name:, result:, relation:); end
  def relation; end
  def result; end
  def var_name; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
class Steep::Diagnostic::Ruby::ElseOnExhaustiveCase < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, type:); end
  def type; end
end
class Steep::Diagnostic::Ruby::UnexpectedSplat < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, type:); end
  def type; end
end
class Steep::Diagnostic::Ruby::ProcTypeExpected < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, type:); end
  def type; end
end
class Steep::Diagnostic::Ruby::MultipleAssignmentConversionError < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, original_type:, returned_type:); end
  def original_type; end
  def returned_type; end
end
class Steep::Diagnostic::Ruby::UnsupportedSyntax < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, message: nil); end
  def message; end
end
class Steep::Diagnostic::Ruby::UnexpectedError < Steep::Diagnostic::Ruby::Base
  def error; end
  def header_line; end
  def initialize(node:, error:); end
  def message; end
end
class Steep::Diagnostic::Ruby::SyntaxError < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(message:, location:); end
  def message; end
end
class Steep::Diagnostic::Ruby::FalseAssertion < Steep::Diagnostic::Ruby::Base
  def assertion_type; end
  def header_line; end
  def initialize(node:, assertion_type:, node_type:); end
  def node; end
  def node_type; end
end
class Steep::Diagnostic::Ruby::UnexpectedTypeArgument < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(type_arg:, method_type:); end
  def method_type; end
  def type_arg; end
end
class Steep::Diagnostic::Ruby::InsufficientTypeArgument < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(node:, type_args:, method_type:); end
  def method_type; end
  def type_args; end
end
class Steep::Diagnostic::Ruby::TypeArgumentMismatchError < Steep::Diagnostic::Ruby::Base
  def header_line; end
  def initialize(type_arg:, type_param:, result:); end
  def result; end
  def type_argument; end
  def type_parameter; end
  include Steep::Diagnostic::Ruby::ResultPrinter
end
module Steep::Diagnostic::Signature
  def self.from_rbs_error(error, factory:); end
end
class Steep::Diagnostic::Signature::Base
  def detail_lines; end
  def diagnostic_code; end
  def header_line; end
  def initialize(location:); end
  def location; end
  def path; end
  include Steep::Diagnostic::Helper
end
class Steep::Diagnostic::Signature::SyntaxError < Steep::Diagnostic::Signature::Base
  def exception; end
  def header_line; end
  def initialize(exception, location:); end
  def self.parser_syntax_error_message(exception); end
end
class Steep::Diagnostic::Signature::DuplicatedDeclaration < Steep::Diagnostic::Signature::Base
  def header_line; end
  def initialize(type_name:, location:); end
  def type_name; end
end
class Steep::Diagnostic::Signature::UnknownTypeName < Steep::Diagnostic::Signature::Base
  def header_line; end
  def initialize(name:, location:); end
  def name; end
end
class Steep::Diagnostic::Signature::InvalidTypeApplication < Steep::Diagnostic::Signature::Base
  def args; end
  def header_line; end
  def initialize(name:, args:, params:, location:); end
  def name; end
  def params; end
end
class Steep::Diagnostic::Signature::UnsatisfiableTypeApplication < Steep::Diagnostic::Signature::Base
  def header_line; end
  def initialize(type_name:, type_arg:, type_param:, location:); end
  def type_arg; end
  def type_name; end
  def type_param; end
end
class Steep::Diagnostic::Signature::InvalidMethodOverload < Steep::Diagnostic::Signature::Base
  def class_name; end
  def header_line; end
  def initialize(class_name:, method_name:, location:); end
  def method_name; end
end
class Steep::Diagnostic::Signature::UnknownMethodAlias < Steep::Diagnostic::Signature::Base
  def class_name; end
  def header_line; end
  def initialize(class_name:, method_name:, location:); end
  def method_name; end
end
class Steep::Diagnostic::Signature::DuplicatedMethodDefinition < Steep::Diagnostic::Signature::Base
  def class_name; end
  def header_line; end
  def initialize(class_name:, method_name:, location:); end
  def method_name; end
end
class Steep::Diagnostic::Signature::RecursiveAlias < Steep::Diagnostic::Signature::Base
  def class_name; end
  def header_line; end
  def initialize(class_name:, names:, location:); end
  def names; end
end
class Steep::Diagnostic::Signature::RecursiveAncestor < Steep::Diagnostic::Signature::Base
  def ancestors; end
  def header_line; end
  def initialize(ancestors:, location:); end
end
class Steep::Diagnostic::Signature::SuperclassMismatch < Steep::Diagnostic::Signature::Base
  def header_line; end
  def initialize(name:, location:); end
  def name; end
end
class Steep::Diagnostic::Signature::GenericParameterMismatch < Steep::Diagnostic::Signature::Base
  def header_line; end
  def initialize(name:, location:); end
  def name; end
end
class Steep::Diagnostic::Signature::InvalidVarianceAnnotation < Steep::Diagnostic::Signature::Base
  def header_line; end
  def initialize(name:, param:, location:); end
  def name; end
  def param; end
end
class Steep::Diagnostic::Signature::ModuleSelfTypeError < Steep::Diagnostic::Signature::Base
  def ancestor; end
  def header_line; end
  def initialize(name:, ancestor:, relation:, location:); end
  def name; end
  def relation; end
end
class Steep::Diagnostic::Signature::ClassVariableDuplicationError < Steep::Diagnostic::Signature::Base
  def class_name; end
  def header_line; end
  def initialize(class_name:, other_class_name:, variable_name:, location:); end
  def other_class_name; end
  def variable_name; end
end
class Steep::Diagnostic::Signature::InstanceVariableTypeError < Steep::Diagnostic::Signature::Base
  def header_line; end
  def initialize(name:, location:, var_type:, parent_type:); end
  def name; end
  def parent_type; end
  def var_type; end
end
class Steep::Diagnostic::Signature::MixinClassError < Steep::Diagnostic::Signature::Base
  def header_line; end
  def initialize(location:, member:, type_name:); end
  def member; end
  def mixin_name; end
  def type_name; end
end
class Steep::Diagnostic::Signature::InheritModuleError < Steep::Diagnostic::Signature::Base
  def header_line; end
  def initialize(super_class); end
  def super_class; end
end
class Steep::Diagnostic::Signature::UnexpectedError < Steep::Diagnostic::Signature::Base
  def header_line; end
  def initialize(message:, location:); end
  def message; end
end
class Steep::Diagnostic::Signature::RecursiveTypeAlias < Steep::Diagnostic::Signature::Base
  def alias_names; end
  def header_line; end
  def initialize(alias_names:, location:); end
end
class Steep::Diagnostic::Signature::NonregularTypeAlias < Steep::Diagnostic::Signature::Base
  def header_line; end
  def initialize(type_name:, nonregular_type:, location:); end
  def nonregular_type; end
  def type_name; end
end
class Steep::Diagnostic::LSPFormatter
  def config; end
  def default_severity; end
  def format(diagnostic); end
  def initialize(config = nil, default_severity: nil); end
  def severity_for(diagnostic); end
  def validate_class(klass); end
  def validate_severity(klass, severity); end
end
module Steep::Signature
end
class Steep::Signature::Validator
  def ancestor_to_type(ancestor); end
  def builder; end
  def checker; end
  def each_error(&block); end
  def each_method_type(definition); end
  def each_variable_type(definition); end
  def env; end
  def factory; end
  def has_error?; end
  def initialize(checker:); end
  def mixin_constraints(definition, mixin_ancestors, immediate_self_types:); end
  def no_error?; end
  def rescue_validation_errors(type_name = nil); end
  def type_name_resolver; end
  def validate; end
  def validate_alias; end
  def validate_ancestor_application(name, ancestor); end
  def validate_const; end
  def validate_decl; end
  def validate_definition_type(definition); end
  def validate_global; end
  def validate_one_alias(name, entry = nil); end
  def validate_one_class(name); end
  def validate_one_constant(name, entry); end
  def validate_one_global(name, entry); end
  def validate_one_interface(name); end
  def validate_type(type); end
  def validate_type_application(type); end
  def validate_type_application_constraints(type_name, type_params, type_args, location:); end
  def validator; end
end
class Steep::Source
  def annotations(block:, factory:, context:); end
  def each_annotation(&block); end
  def each_heredoc_node(node = nil, parents = nil, &block); end
  def find_heredoc_nodes(line, column, position); end
  def find_nodes(line:, column:); end
  def find_nodes_loc(node, position, parents); end
  def initialize(path:, node:, mapping:); end
  def mapping; end
  def node; end
  def path; end
  def self.adjust_location(node); end
  def self.assertion_node(node, type); end
  def self.construct_mapping(node:, annotations:, mapping:, line_range: nil); end
  def self.delete_defs(node, allow_list); end
  def self.insert_type_node(node, comments); end
  def self.map_child_node(node, type = nil, skip: nil); end
  def self.new_parser; end
  def self.parse(source_code, path:, factory:); end
  def self.sendish_node?(node); end
  def self.type_application_node(node, tapp); end
  def without_unrelated_defs(line:, column:); end
  extend Steep::NodeHelper
end
class Steep::Source::Builder < Parser::Builders::Default
  def string_value(token); end
end
class Steep::AnnotationParser
  def factory; end
  def initialize(factory:); end
  def keyword_and_type(keyword); end
  def keyword_subject_type(keyword, name); end
  def parse(src, location:); end
  def parse_type(string); end
end
class Steep::AnnotationParser::SyntaxError < StandardError
  def initialize(source:, location:, exn: nil); end
  def location; end
  def source; end
end
class Steep::Typing
  def add_call(node, call); end
  def add_context(range, context:); end
  def add_context_for_body(node, context:); end
  def add_context_for_node(node, context:); end
  def add_error(error); end
  def add_typing(node, type, _context); end
  def block_range(node); end
  def call_of(node:); end
  def context_at(line:, column:); end
  def contexts; end
  def dump(io); end
  def each_typing(&block); end
  def errors; end
  def has_type?(node); end
  def initialize(source:, root_context:, parent: nil, parent_last_update: nil, contexts: nil, source_index: nil); end
  def last_update; end
  def method_calls; end
  def new_child(range); end
  def parent; end
  def parent_last_update; end
  def root_context; end
  def save!; end
  def self.summary(node); end
  def should_update; end
  def source; end
  def source_index; end
  def type_of(node:); end
  def typing; end
end
class Steep::Typing::UnknownNodeError < StandardError
  def initialize(op, node:); end
  def node; end
  def op; end
end
module Steep::ModuleHelper
  def module_name_from_node(parent_node, constant_name); end
  def namespace_from_node(node); end
end
class Steep::TypeConstruction
  def absolute_name(name); end
  def add_call(call); end
  def add_typing(node, type:, constr: nil); end
  def annotations; end
  def apply_solution(errors, node:, method_type:); end
  def arrayish_type?(type, untyped_is: nil); end
  def block_context; end
  def break_context; end
  def builder_config; end
  def bypass_splat(node); end
  def calculate_interface(type, method_name = nil, private:); end
  def check(node, type, constraints: nil); end
  def check_relation(sub_type:, super_type:, constraints: nil); end
  def checker; end
  def context; end
  def deep_expand_alias(type); end
  def default_module_context(implement_module_name, nesting:); end
  def eliminate_vars(type, variables, to: nil); end
  def expand_alias(type, &block); end
  def expand_self(type); end
  def extract_outermost_call(node, var_name); end
  def fallback_to_any(node); end
  def flatten_array_elements(type); end
  def flatten_union(type); end
  def for_block(body_node, block_params:, block_param_hint:, block_type_hint:, block_block_hint:, block_annotations:, node_type_hint:, block_self_hint:); end
  def for_branch(node, break_context: nil); end
  def for_class(node, new_class_name, super_class_name); end
  def for_module(node, new_module_name); end
  def for_new_method(method_name, node, args:, self_type:, definition:); end
  def for_sclass(node, type); end
  def implement_module(module_name:, annotations:, super_name: nil); end
  def initialize(checker:, source:, annotations:, typing:, context:); end
  def inspect; end
  def instance_type(type); end
  def ivasgn(node, rhs_type); end
  def lvasgn(node, type); end
  def masgn_lhs?(lhs); end
  def meta_type(type); end
  def method_context!; end
  def method_context; end
  def module_context!; end
  def module_context; end
  def namespace_module?(node); end
  def nesting; end
  def no_subtyping?(sub_type:, super_type:, constraints: nil); end
  def optional_proc?(type); end
  def partition_flatten_types(type, &block); end
  def pick_one_of(types, range:); end
  def pure_send?(call, receiver, arguments); end
  def save_typing; end
  def select_flatten_types(type, &block); end
  def self_class?(node); end
  def self_type; end
  def semantically_arrayish_type?(type); end
  def set_up_block_mlhs_params_env(node, type, hash, &block); end
  def singleton_type(type); end
  def source; end
  def synthesize(node, hint: nil, condition: nil); end
  def synthesize_block(node:, block_type_hint:, block_body:); end
  def synthesize_children(node, skips: nil); end
  def synthesize_constant(node, parent_node, constant_name); end
  def synthesize_sendish(node, hint:, tapp:); end
  def test_literal_type(literal, hint); end
  def to_instance_type(type, args: nil); end
  def try_array_type(node, hint); end
  def try_convert(type, method); end
  def try_convert_to_array(type); end
  def try_method_type(node, receiver_type:, method_name:, method_type:, arguments:, block_params:, block_body:, tapp:); end
  def try_special_method(node, receiver_type:, method_name:, method_type:, arguments:, block_params:, block_body:); end
  def try_tuple_type!(node, hint: nil); end
  def try_tuple_type(array_node, hint); end
  def type_any_rec(node); end
  def type_block_without_hint(node:, block_annotations:, block_params:, block_body:); end
  def type_check_args(args, constraints, errors); end
  def type_check_argument(node, type:, constraints:, errors:, report_node: nil); end
  def type_hash(hash_node, hint:); end
  def type_hash_record(hash_node, record_type); end
  def type_lambda(node, params_node:, body_node:, type_hint:); end
  def type_masgn(node); end
  def type_masgn_type(mlhs_node, rhs_type, masgn:, optional:); end
  def type_method_call(node, method_name:, receiver_type:, method:, arguments:, block_params:, block_body:, tapp:); end
  def type_name(type); end
  def type_send(node, send_node:, block_params:, block_body:, tapp:, unwrap: nil); end
  def type_send_interface(node, interface:, receiver:, receiver_type:, method_name:, arguments:, block_params:, block_body:, tapp:); end
  def typing; end
  def union_of_tuple_to_tuple_of_union(type); end
  def union_type(*types); end
  def union_type_unify(*types); end
  def unwrap(type); end
  def update_context; end
  def update_type_env; end
  def validate_method_definitions(node, module_name); end
  def variable_context; end
  def with(annotations: nil, context: nil, typing: nil); end
  def with_child_typing(range:); end
  def with_class_constr(node, new_class_name, super_class_name); end
  def with_method_constr(method_name, node, args:, self_type:, definition:); end
  def with_module_constr(node, module_name); end
  def with_new_typing(typing); end
  def with_sclass_constr(node, type); end
  def with_updated_context(type_env: nil); end
  include Steep::ModuleHelper
  include Steep::NodeHelper
end
class Steep::TypeConstruction::Pair
  def +(other); end
  def constr; end
  def context; end
  def initialize(type:, constr:); end
  def to_ary; end
  def type; end
  def with(type: nil, constr: nil); end
end
module Steep::TypeInference
end
class Steep::TypeInference::Context
  def block_context; end
  def break_context; end
  def call_context; end
  def env; end
  def factory; end
  def initialize(method_context:, block_context:, break_context:, module_context:, self_type:, type_env:, call_context:, variable_context:); end
  def inspect; end
  def method_context; end
  def module_context; end
  def self_type; end
  def type_env; end
  def variable_context; end
  def with(method_context: nil, block_context: nil, break_context: nil, module_context: nil, self_type: nil, type_env: nil, call_context: nil, variable_context: nil); end
end
class Steep::TypeInference::Context::MethodContext
  def block_type; end
  def constructor; end
  def initialize(name:, method:, method_type:, return_type:, constructor:, super_method:); end
  def method; end
  def method_type; end
  def name; end
  def return_type; end
  def super_method; end
end
class Steep::TypeInference::Context::BlockContext
  def body_type; end
  def initialize(body_type:); end
  def subst(s); end
end
class Steep::TypeInference::Context::BreakContext
  def break_type; end
  def initialize(break_type:, next_type:); end
  def next_type; end
  def subst(s); end
end
class Steep::TypeInference::Context::ModuleContext
  def class_name; end
  def class_variables; end
  def defined_instance_methods; end
  def defined_module_methods; end
  def implement_name; end
  def initialize(instance_type:, module_type:, implement_name:, class_name:, nesting:, instance_definition: nil, module_definition: nil); end
  def instance_definition; end
  def instance_type; end
  def module_definition; end
  def module_type; end
  def nesting; end
  def update(instance_type: nil, module_type: nil, implement_name: nil, class_name: nil, instance_definition: nil, module_definition: nil, nesting: nil); end
end
class Steep::TypeInference::Context::TypeVariableContext
  def [](name); end
  def initialize(type_params, parent_context: nil); end
  def self.empty; end
  def table; end
  def type_params; end
  def upper_bounds; end
end
class Steep::TypeInference::ContextArray
  def [](index); end
  def at(line:, column:); end
  def buffer; end
  def context_at(index, entry: nil); end
  def each_entry; end
  def initialize(buffer:, context:, range: nil); end
  def insert_context(range, context:, entry: nil); end
  def merge(subtree); end
  def range; end
  def root; end
  def self.from_source(source:, range: nil, context: nil); end
end
class Steep::TypeInference::ContextArray::Entry
  def context; end
  def initialize(range:, context:); end
  def range; end
  def sub_entries; end
end
class Steep::TypeInference::SendArgs
  def arguments; end
  def block; end
  def block_pass_arg; end
  def each; end
  def initialize(node:, arguments:, type:); end
  def keyword_args; end
  def keyword_params; end
  def kwargs_node; end
  def node; end
  def params; end
  def positional_arg; end
  def positional_params; end
  def type; end
end
class Steep::TypeInference::SendArgs::PositionalArgs
  def args; end
  def consume(n, node:); end
  def consume0(n, node:, params:, ps:); end
  def following_args; end
  def index; end
  def initialize(args:, index:, positional_params:, uniform: nil); end
  def next; end
  def node; end
  def param; end
  def positional_params; end
  def uniform; end
  def uniform_type; end
  def update(index: nil, positional_params: nil, uniform: nil); end
end
class Steep::TypeInference::SendArgs::PositionalArgs::NodeParamPair
  def initialize(node:, param:); end
  def node; end
  def param; end
  def to_ary; end
  include Steep::Equatable
end
class Steep::TypeInference::SendArgs::PositionalArgs::NodeTypePair
  def initialize(node:, type:); end
  def node; end
  def node_type; end
  def type; end
  include Steep::Equatable
end
class Steep::TypeInference::SendArgs::PositionalArgs::SplatArg
  def initialize(node:); end
  def node; end
  def type; end
  def type=(arg0); end
  include Steep::Equatable
end
class Steep::TypeInference::SendArgs::PositionalArgs::UnexpectedArg
  def initialize(node:); end
  def node; end
  include Steep::Equatable
end
class Steep::TypeInference::SendArgs::PositionalArgs::MissingArg
  def initialize(params:); end
  def params; end
  include Steep::Equatable
end
class Steep::TypeInference::SendArgs::KeywordArgs
  def all_keys; end
  def all_values; end
  def consume_keys(keys, node:); end
  def consumed_keywords; end
  def index; end
  def initialize(kwarg_nodes:, keyword_params:, index: nil, consumed_keywords: nil); end
  def keyword_pair; end
  def keyword_params; end
  def keyword_type(key); end
  def kwarg_nodes; end
  def next; end
  def optional_keywords; end
  def possible_key_type; end
  def possible_value_type; end
  def required_keywords; end
  def rest_type; end
  def update(index: nil, consumed_keywords: nil); end
end
class Steep::TypeInference::SendArgs::KeywordArgs::ArgTypePairs
  def [](index); end
  def initialize(pairs:); end
  def pairs; end
  def size; end
  include Steep::Equatable
end
class Steep::TypeInference::SendArgs::KeywordArgs::SplatArg
  def initialize(node:); end
  def node; end
  def type; end
  def type=(arg0); end
  include Steep::Equatable
end
class Steep::TypeInference::SendArgs::KeywordArgs::UnexpectedKeyword
  def initialize(keyword:, node:); end
  def key_node; end
  def keyword; end
  def node; end
  def value_node; end
  include Steep::Equatable
end
class Steep::TypeInference::SendArgs::KeywordArgs::MissingKeyword
  def initialize(keywords:); end
  def keywords; end
  include Steep::Equatable
end
class Steep::TypeInference::SendArgs::BlockPassArg
  def block; end
  def block_missing?; end
  def compatible?; end
  def initialize(node:, block:); end
  def no_block?; end
  def node; end
  def node_type; end
  def pair; end
  def unexpected_block?; end
  include Steep::Equatable
end
class Steep::TypeInference::BlockParams
  def block_param; end
  def each(&block); end
  def expandable?; end
  def expandable_params?(params_type, factory); end
  def initialize(leading_params:, optional_params:, rest_param:, trailing_params:, block_param:); end
  def leading_params; end
  def optional_params; end
  def params; end
  def params_type(hint: nil); end
  def params_type0(hint:); end
  def rest_param; end
  def self.from_multiple(node, annotations); end
  def self.from_node(node, annotations:); end
  def trailing_params; end
  def zip(params_type, block, factory:); end
end
class Steep::TypeInference::BlockParams::Param
  def ==(other); end
  def each_param(&block); end
  def eql?(other); end
  def hash; end
  def initialize(var:, type:, value:, node:); end
  def node; end
  def type; end
  def value; end
  def var; end
end
class Steep::TypeInference::BlockParams::MultipleParam
  def ==(other); end
  def each_param(&block); end
  def eql?(other); end
  def hash; end
  def initialize(node:, params:); end
  def node; end
  def params; end
  def variable_types; end
end
class Steep::TypeInference::MethodParams
  def [](name); end
  def args; end
  def each; end
  def each_param(&block); end
  def errors; end
  def initialize(args:, method_type:); end
  def method_type; end
  def params; end
  def self.build(node:, method_type:); end
  def self.empty(node:); end
  def size; end
end
class Steep::TypeInference::MethodParams::BaseParameter
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(name:, type:, node:); end
  def name; end
  def node; end
  def optional?; end
  def type; end
  def untyped?; end
  def value; end
  def var_type; end
end
class Steep::TypeInference::MethodParams::PositionalParameter < Steep::TypeInference::MethodParams::BaseParameter
end
class Steep::TypeInference::MethodParams::KeywordParameter < Steep::TypeInference::MethodParams::BaseParameter
end
class Steep::TypeInference::MethodParams::BaseRestParameter
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(name:, type:, node:); end
  def name; end
  def node; end
  def type; end
end
class Steep::TypeInference::MethodParams::PositionalRestParameter < Steep::TypeInference::MethodParams::BaseRestParameter
  def var_type; end
end
class Steep::TypeInference::MethodParams::KeywordRestParameter < Steep::TypeInference::MethodParams::BaseRestParameter
  def var_type; end
end
class Steep::TypeInference::MethodParams::BlockParameter
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(name:, type:, node:, optional:, self_type:); end
  def name; end
  def node; end
  def optional?; end
  def self_type; end
  def type; end
  def var_type; end
end
class Steep::TypeInference::ConstantEnv
  def children(module_name); end
  def constants; end
  def context; end
  def decompose_constant(constant); end
  def factory; end
  def initialize(factory:, context:, resolver:); end
  def resolve(name); end
  def resolve_child(module_name, constant_name); end
  def resolver; end
  def toplevel(name); end
end
class Steep::TypeInference::TypeEnv
  def [](name); end
  def add_pure_call(node, call, type); end
  def annotated_constant(name); end
  def assign_local_variable(name, var_type, enforced_type); end
  def assign_local_variables(assignments); end
  def constant(arg1, arg2); end
  def constant_env; end
  def constant_types; end
  def enforced_type(name); end
  def global_name?(name); end
  def global_types; end
  def initialize(constant_env, local_variable_types: nil, instance_variable_types: nil, global_types: nil, constant_types: nil, pure_method_calls: nil); end
  def inspect; end
  def instance_variable_name?(name); end
  def instance_variable_types; end
  def invalidate_pure_node(node); end
  def invalidated_pure_nodes(invalidated_node); end
  def join(*envs); end
  def local_variable_name!(name); end
  def local_variable_name?(name); end
  def local_variable_types; end
  def merge(local_variable_types: nil, instance_variable_types: nil, global_types: nil, constant_types: nil, pure_method_calls: nil); end
  def pin_local_variables(names); end
  def pure_method_calls; end
  def pure_node_invalidation(invalidated_nodes); end
  def refine_types(local_variable_types: nil, pure_call_types: nil); end
  def replace_pure_call_type(node, type); end
  def subst(s); end
  def to_s; end
  def unpin_local_variables(names); end
  def update(local_variable_types: nil, instance_variable_types: nil, global_types: nil, constant_types: nil, pure_method_calls: nil); end
  include Steep::NodeHelper
end
class Steep::TypeInference::TypeEnvBuilder
  def build(type_env); end
  def commands; end
  def initialize(*commands); end
end
module Steep::TypeInference::TypeEnvBuilder::Command
end
class Steep::TypeInference::TypeEnvBuilder::Command::AnnotationsBase
  def annotations; end
  def initialize(annotations); end
end
class Steep::TypeInference::TypeEnvBuilder::Command::RBSBase
  def environment; end
  def factory; end
  def initialize(factory); end
end
class Steep::TypeInference::TypeEnvBuilder::Command::ImportLocalVariableAnnotations < Steep::TypeInference::TypeEnvBuilder::Command::AnnotationsBase
  def call(env); end
  def initialize(annotations); end
  def merge!(merge = nil); end
  def on_duplicate!(&block); end
  def on_duplicate; end
end
class Steep::TypeInference::TypeEnvBuilder::Command::ImportInstanceVariableAnnotations < Steep::TypeInference::TypeEnvBuilder::Command::AnnotationsBase
  def call(env); end
  def merge!(merge = nil); end
end
class Steep::TypeInference::TypeEnvBuilder::Command::ImportGlobalDeclarations < Steep::TypeInference::TypeEnvBuilder::Command::RBSBase
  def call(env); end
end
class Steep::TypeInference::TypeEnvBuilder::Command::ImportInstanceVariableDefinition
  def call(env); end
  def definition; end
  def factory; end
  def initialize(definition, factory); end
end
class Steep::TypeInference::TypeEnvBuilder::Command::ImportConstantAnnotations < Steep::TypeInference::TypeEnvBuilder::Command::AnnotationsBase
  def call(env); end
end
class Steep::TypeInference::LogicTypeInterpreter
  def config; end
  def decompose_value(node); end
  def eval(env:, node:); end
  def evaluate_assignment(assignment_node, env, rhs_type, refined_objects:); end
  def evaluate_method_call(env:, type:, receiver:, arguments:, refined_objects:); end
  def evaluate_node(env:, node:, refined_objects:); end
  def factory; end
  def guess_type_from_method(node); end
  def initialize(subtyping:, typing:, config:); end
  def literal_var_type_case_select(value_node, arg_type); end
  def refine_node_type(env:, node:, truthy_type:, falsy_type:, refined_objects:); end
  def subtyping; end
  def try_convert(type, method); end
  def type_case_select(type, klass); end
  def type_case_select0(type, klass); end
  def typing; end
end
class Steep::TypeInference::MultipleAssignment
  def expand(mlhs, rhs_type, optional); end
  def expand_any(nodes, rhs_type, element_type, optional); end
  def expand_array(lhss, rhs_type, optional); end
  def expand_tuple(lhss, rhs_type, tuples, optional); end
  def hint_for_mlhs(mlhs, env); end
end
class Steep::TypeInference::MultipleAssignment::Assignments < Struct
  def each(&block); end
  def leading_assignments; end
  def leading_assignments=(_); end
  def optional; end
  def optional=(_); end
  def rhs_type; end
  def rhs_type=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def splat_assignment; end
  def splat_assignment=(_); end
  def trailing_assignments; end
  def trailing_assignments=(_); end
end
class Steep::TypeInference::MethodCall
end
class Steep::TypeInference::MethodCall::MethodDecl
  def ==(other); end
  def eql?(other); end
  def hash; end
  def initialize(method_name:, method_def:); end
  def method_def; end
  def method_name; end
  def method_type; end
end
class Steep::TypeInference::MethodCall::MethodContext < Struct
  def method_name; end
  def method_name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def to_s; end
end
class Steep::TypeInference::MethodCall::ModuleContext < Struct
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def to_s; end
  def type_name; end
  def type_name=(_); end
end
class Steep::TypeInference::MethodCall::TopLevelContext
  def ==(other); end
  def eql?(other); end
  def hash; end
  def to_s; end
end
class Steep::TypeInference::MethodCall::UnknownContext
  def ==(other); end
  def eql?(other); end
  def hash; end
  def to_s; end
end
class Steep::TypeInference::MethodCall::Base
  def ==(other); end
  def context; end
  def eql?(other); end
  def hash; end
  def initialize(node:, context:, method_name:, receiver_type:, return_type:); end
  def method_name; end
  def node; end
  def receiver_type; end
  def return_type; end
  def with_return_type(new_type); end
end
class Steep::TypeInference::MethodCall::Typed < Steep::TypeInference::MethodCall::Base
  def ==(other); end
  def actual_method_type; end
  def eql?(other); end
  def hash; end
  def initialize(node:, context:, method_name:, receiver_type:, actual_method_type:, method_decls:, return_type:); end
  def method_decls; end
  def pure?; end
  def update(node: nil, return_type: nil); end
end
class Steep::TypeInference::MethodCall::Special < Steep::TypeInference::MethodCall::Typed
end
class Steep::TypeInference::MethodCall::Untyped < Steep::TypeInference::MethodCall::Base
  def initialize(node:, context:, method_name:); end
end
class Steep::TypeInference::MethodCall::NoMethodError < Steep::TypeInference::MethodCall::Base
  def error; end
  def initialize(node:, context:, method_name:, receiver_type:, error:); end
end
class Steep::TypeInference::MethodCall::Error < Steep::TypeInference::MethodCall::Base
  def errors; end
  def initialize(node:, context:, method_name:, receiver_type:, errors:, method_decls: nil, return_type: nil); end
  def method_decls; end
end
module Steep::Index
end
class Steep::Index::RBSIndex
  def add_constant_declaration(const_name, decl); end
  def add_global_declaration(global_name, decl); end
  def add_method_declaration(method_name, member); end
  def add_type_declaration(type_name, declaration); end
  def add_type_reference(type_name, ref); end
  def const_index; end
  def each_declaration(type_name: nil, method_name: nil, const_name: nil, global_name: nil, &block); end
  def each_entry(&block); end
  def each_reference(type_name: nil, &block); end
  def entry(type_name: nil, method_name: nil, const_name: nil, global_name: nil); end
  def global_index; end
  def initialize; end
  def method_index; end
  def type_index; end
end
class Steep::Index::RBSIndex::TypeEntry
  def add_declaration(decl); end
  def add_reference(ref); end
  def declarations; end
  def initialize(type_name:); end
  def references; end
  def type_name; end
end
class Steep::Index::RBSIndex::MethodEntry
  def add_declaration(decl); end
  def declarations; end
  def initialize(method_name:); end
  def method_name; end
  def references; end
end
class Steep::Index::RBSIndex::ConstantEntry
  def add_declaration(decl); end
  def const_name; end
  def declarations; end
  def initialize(const_name:); end
end
class Steep::Index::RBSIndex::GlobalEntry
  def add_declaration(decl); end
  def declarations; end
  def global_name; end
  def initialize(global_name:); end
end
class Steep::Index::RBSIndex::Builder
  def env(env); end
  def index; end
  def initialize(index:); end
  def member(type_name, member); end
  def type_reference(type, from:); end
end
class Steep::Index::SignatureSymbolProvider
  def assigned?(path); end
  def assignment; end
  def indexes; end
  def initialize(project:, assignment:); end
  def project; end
  def query_symbol(query); end
  def self.test_const_name(query, type_name); end
  def self.test_global_name(query, type_name); end
  def self.test_method_name(query, method_name); end
  def self.test_type_name(query, type_name); end
end
class Steep::Index::SignatureSymbolProvider::SymbolInformation < Struct
  def container_name; end
  def container_name=(_); end
  def kind; end
  def kind=(_); end
  def location; end
  def location=(_); end
  def name; end
  def name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Index::SourceIndex
  def add_definition(definition:, constant: nil, method: nil); end
  def add_reference(ref:, constant: nil, method: nil); end
  def constant_index; end
  def count; end
  def entry(constant: nil, method: nil); end
  def initialize(source:, parent: nil); end
  def merge!(child); end
  def method_index; end
  def new_child; end
  def parent; end
  def parent_count; end
  def reference(constant_node: nil); end
  def source; end
end
class Steep::Index::SourceIndex::ConstantEntry
  def add_definition(node); end
  def add_reference(node); end
  def definitions; end
  def initialize(name:); end
  def merge!(other); end
  def name; end
  def references; end
end
class Steep::Index::SourceIndex::MethodEntry
  def add_definition(node); end
  def add_reference(node); end
  def definitions; end
  def initialize(name:); end
  def merge!(other); end
  def name; end
  def references; end
end
module Steep::Services
end
class Steep::Services::ContentChange
  def ==(other); end
  def apply_to(text); end
  def eql?(other); end
  def hash; end
  def initialize(text:, range: nil); end
  def range; end
  def self.string(string); end
  def text; end
end
class Steep::Services::ContentChange::Position
  def ==(other); end
  def column; end
  def eql?(other); end
  def hash; end
  def initialize(line:, column:); end
  def line; end
end
class Steep::Services::PathAssignment
  def ===(path); end
  def =~(path); end
  def cache; end
  def index; end
  def initialize(index:, max_index:); end
  def max_index; end
  def self.all; end
  def self.index_for(path:, max_index:); end
end
class Steep::Services::SignatureService
  def add_descendants(graph:, names:, set:); end
  def add_nested_decls(env:, names:, set:); end
  def apply_changes(files, changes); end
  def const_decls(paths:, env:); end
  def current_subtyping; end
  def each_rbs_path(&block); end
  def env_rbs_paths; end
  def files; end
  def global_decls(paths:, env: nil); end
  def initialize(env:); end
  def latest_builder; end
  def latest_constant_resolver; end
  def latest_env; end
  def latest_rbs_index; end
  def pending_changed_paths; end
  def rescue_rbs_error(errors); end
  def self.load_from(loader); end
  def status; end
  def type_name_from_decl(decl, set:); end
  def type_names(paths:, env:); end
  def update(changes); end
  def update_builder(ancestor_builder:, paths:); end
  def update_env(updated_files, paths:); end
end
class Steep::Services::SignatureService::SyntaxErrorStatus
  def changed_paths; end
  def constant_resolver; end
  def diagnostics; end
  def files; end
  def initialize(files:, changed_paths:, diagnostics:, last_builder:); end
  def last_builder; end
  def rbs_index; end
end
class Steep::Services::SignatureService::AncestorErrorStatus
  def changed_paths; end
  def constant_resolver; end
  def diagnostics; end
  def files; end
  def initialize(files:, changed_paths:, diagnostics:, last_builder:); end
  def last_builder; end
  def rbs_index; end
end
class Steep::Services::SignatureService::LoadedStatus
  def builder; end
  def constant_resolver; end
  def files; end
  def initialize(files:, builder:); end
  def rbs_index; end
  def subtyping; end
end
class Steep::Services::SignatureService::FileStatus < Struct
  def content; end
  def content=(_); end
  def decls; end
  def decls=(_); end
  def path; end
  def path=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Services::TypeCheckService
  def app_signature_file?(path); end
  def diagnostics; end
  def each_diagnostics(&block); end
  def has_diagnostics?; end
  def initialize(project:); end
  def lib_signature_file?(path); end
  def project; end
  def self.type_check(source:, subtyping:, constant_resolver:); end
  def signature_diagnostics; end
  def signature_file?(path); end
  def signature_services; end
  def signature_validation_diagnostics; end
  def source_file?(path); end
  def source_files; end
  def type_check_file(target:, subtyping:, path:, text:); end
  def typecheck_source(path:, target: nil, &block); end
  def update(changes:); end
  def update_and_check(changes:, assignment:, &block); end
  def update_signature(changes:, requests:); end
  def update_sources(changes:, requests:); end
  def validate_signature(path:, &block); end
end
class Steep::Services::TypeCheckService::SourceFile
  def content; end
  def diagnostics; end
  def errors; end
  def initialize(path:, node:, content:, typing:, errors:); end
  def node; end
  def path; end
  def self.no_data(path:, content:); end
  def self.with_syntax_error(path:, content:, error:); end
  def self.with_typing(path:, content:, typing:, node:); end
  def target; end
  def typing; end
  def update_content(content); end
end
class Steep::Services::TypeCheckService::TargetRequest
  def ==(other); end
  def empty?; end
  def eql?(other); end
  def hash; end
  def initialize(target:); end
  def signature_updated!(value = nil); end
  def signature_updated?; end
  def source_paths; end
  def target; end
end
module Steep::Services::HoverProvider
  extend Steep::Services::HoverProvider::SingletonMethods
end
module Steep::Services::HoverProvider::SingletonMethods
  def content_for(service:, path:, line:, column:); end
end
class Steep::Services::HoverProvider::Ruby
  def content_for(target:, path:, line:, column:); end
  def initialize(service:); end
  def method_definition_for(factory, type_name, singleton_method: nil, instance_method: nil); end
  def method_name_from_method(context, builder:); end
  def project; end
  def service; end
  def typecheck(target, path:, content:, line:, column:); end
end
class Steep::Services::HoverProvider::Ruby::TypeContent < Struct
  def location; end
  def location=(_); end
  def node; end
  def node=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def type; end
  def type=(_); end
end
class Steep::Services::HoverProvider::Ruby::VariableContent < Struct
  def location; end
  def location=(_); end
  def name; end
  def name=(_); end
  def node; end
  def node=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def type; end
  def type=(_); end
end
class Steep::Services::HoverProvider::Ruby::TypeAssertionContent < Struct
  def asserted_type; end
  def asserted_type=(_); end
  def location; end
  def location=(_); end
  def node; end
  def node=(_); end
  def original_type; end
  def original_type=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Services::HoverProvider::Ruby::MethodCallContent < Struct
  def location; end
  def location=(_); end
  def method_call; end
  def method_call=(_); end
  def node; end
  def node=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Services::HoverProvider::Ruby::DefinitionContent < Struct
  def definition; end
  def definition=(_); end
  def location; end
  def location=(_); end
  def method_name; end
  def method_name=(_); end
  def method_type; end
  def method_type=(_); end
  def node; end
  def node=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Services::HoverProvider::Ruby::ConstantContent < Struct
  def class_decl; end
  def class_or_module?; end
  def comments; end
  def constant?; end
  def constant_decl; end
  def decl; end
  def decl=(_); end
  def full_name; end
  def full_name=(_); end
  def location; end
  def location=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def type; end
  def type=(_); end
end
class Steep::Services::HoverProvider::RBS
  def content_for(target:, path:, line:, column:); end
  def initialize(service:); end
  def project; end
  def service; end
end
class Steep::Services::HoverProvider::RBS::TypeAliasContent < Struct
  def decl; end
  def decl=(_); end
  def location; end
  def location=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Services::HoverProvider::RBS::ClassContent < Struct
  def decl; end
  def decl=(_); end
  def location; end
  def location=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Services::HoverProvider::RBS::InterfaceContent < Struct
  def decl; end
  def decl=(_); end
  def location; end
  def location=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Services::CompletionProvider
  def at_end?(pos, of:); end
  def constant_items_for_context(context, position:, prefix:, items:, parent: nil); end
  def disallowed_method?(name); end
  def env; end
  def index_for(string, line:, column:); end
  def initialize(source_text:, path:, subtyping:); end
  def instance_variable_items_for_context(context, position:, prefix:, items:); end
  def items_for_atmark(position:); end
  def items_for_colon2(position:); end
  def items_for_dot(position:); end
  def items_for_trigger(position:); end
  def local_variable_items_for_context(context, position:, prefix:, items:); end
  def method_items_for_receiver_type(type, include_private:, prefix:, position:, items:); end
  def modified_text; end
  def path; end
  def range_for(position, prefix: nil); end
  def range_from_loc(loc); end
  def run(line:, column:); end
  def source; end
  def source_text; end
  def subtyping; end
  def type_check!(text, line:, column:); end
  def typing; end
  def word_name?(name); end
end
class Steep::Services::CompletionProvider::Position < Struct
  def -(size); end
  def column; end
  def column=(_); end
  def line; end
  def line=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Services::CompletionProvider::Range < Struct
  def end; end
  def end=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def start; end
  def start=(_); end
end
class Steep::Services::CompletionProvider::InstanceVariableItem < Struct
  def identifier; end
  def identifier=(_); end
  def range; end
  def range=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def type; end
  def type=(_); end
end
class Steep::Services::CompletionProvider::LocalVariableItem < Struct
  def identifier; end
  def identifier=(_); end
  def range; end
  def range=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def type; end
  def type=(_); end
end
class Steep::Services::CompletionProvider::ConstantItem < Struct
  def class?; end
  def comments; end
  def env; end
  def env=(_); end
  def full_name; end
  def full_name=(_); end
  def identifier; end
  def identifier=(_); end
  def module?; end
  def range; end
  def range=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def type; end
  def type=(_); end
end
class Steep::Services::CompletionProvider::MethodNameItem < Struct
  def comment; end
  def identifier; end
  def identifier=(_); end
  def inherited?; end
  def method_decls; end
  def method_decls=(_); end
  def method_type; end
  def method_type=(_); end
  def range; end
  def range=(_); end
  def receiver_type; end
  def receiver_type=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Services::StatsCalculator
  def calc_stats(target, file:); end
  def initialize(service:); end
  def project; end
  def service; end
end
class Steep::Services::StatsCalculator::SuccessStats < Struct
  def as_json; end
  def error_calls_count; end
  def error_calls_count=(_); end
  def path; end
  def path=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def target; end
  def target=(_); end
  def typed_calls_count; end
  def typed_calls_count=(_); end
  def untyped_calls_count; end
  def untyped_calls_count=(_); end
end
class Steep::Services::StatsCalculator::ErrorStats < Struct
  def as_json; end
  def path; end
  def path=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def target; end
  def target=(_); end
end
class Steep::Services::FileLoader
  def base_dir; end
  def each_path_in_patterns(pattern, commandline_patterns = nil); end
  def initialize(base_dir:); end
  def load_changes(pattern, command_line_patterns = nil, changes:); end
end
class Steep::Services::GotoService
  def assignment; end
  def constant_definition_in_rbs(name, locations:); end
  def constant_definition_in_ruby(name, locations:); end
  def definition(path:, line:, column:); end
  def implementation(path:, line:, column:); end
  def initialize(type_check:, assignment:); end
  def method_locations(name, in_ruby:, in_rbs:, locations:); end
  def project; end
  def query_at(path:, line:, column:); end
  def test_ast_location(loc, line:, column:); end
  def type_check; end
  def type_check_path(target:, path:, content:, line:, column:); end
  def type_name_locations(name, locations: nil); end
  include Steep::ModuleHelper
end
module Steep::Services::GotoService::SourceHelper
  def from_rbs?; end
  def from_ruby?; end
end
class Steep::Services::GotoService::ConstantQuery < Struct
  def from; end
  def from=(_); end
  def name; end
  def name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  include Steep::Services::GotoService::SourceHelper
end
class Steep::Services::GotoService::MethodQuery < Struct
  def from; end
  def from=(_); end
  def name; end
  def name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  include Steep::Services::GotoService::SourceHelper
end
class Steep::Services::GotoService::TypeNameQuery < Struct
  def name; end
  def name=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
module Steep::Server
end
module Steep::Server::LSPFormatter
  def declaration_summary(decl); end
  def format_hover_content(content); end
  def name_and_args(name, args); end
  def name_and_params(name, params); end
  def self.declaration_summary(decl); end
  def self.format_hover_content(content); end
  def self.name_and_args(name, args); end
  def self.name_and_params(name, params); end
  def self.to_list(collection, &block); end
  def to_list(collection, &block); end
  include Steep::Services
end
class Steep::Server::LSPFormatter::CommentBuilder
  def <<(string); end
  def initialize; end
  def push; end
  def self.build; end
  def to_s; end
end
module Steep::Server::ChangeBuffer
  def buffered_changes; end
  def collect_changes(request); end
  def load_files(project:, commandline_args:); end
  def mutex; end
  def pop_buffer; end
  def push_buffer; end
end
class Steep::Server::BaseWorker
  def handle_job(job); end
  def handle_request(request); end
  def initialize(project:, reader:, writer:); end
  def project; end
  def queue; end
  def reader; end
  def run; end
  def skip_job?; end
  def skip_jobs_after_shutdown!(flag = nil); end
  def skip_jobs_after_shutdown?; end
  def writer; end
end
class Steep::Server::BaseWorker::ShutdownJob < Struct
  def id; end
  def id=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Server::WorkerProcess
  def <<(message); end
  def index; end
  def initialize(reader:, writer:, stderr:, wait_thread:, name:, index: nil); end
  def kill; end
  def name; end
  def read(&block); end
  def reader; end
  def self.fork_worker(type, name:, steepfile:, index:, delay_shutdown:, patterns:); end
  def self.spawn_worker(type, name:, steepfile:, steep_command:, index:, delay_shutdown:, patterns:); end
  def self.start_typecheck_workers(steepfile:, args:, steep_command:, count: nil, delay_shutdown: nil); end
  def self.start_worker(type, name:, steepfile:, steep_command:, index: nil, delay_shutdown: nil, patterns: nil); end
  def stderr; end
  def wait_thread; end
  def writer; end
end
class Steep::Server::InteractionWorker < Steep::Server::BaseWorker
  def format_comment(comment); end
  def format_comments(comments); end
  def format_completion_item(item); end
  def format_completion_item_for_rbs(sig_service, type_name, context, job, prefix); end
  def handle_job(job); end
  def handle_request(request); end
  def initialize(project:, reader:, writer:, queue: nil); end
  def method_type_to_snippet(method_type); end
  def params_to_snippet(fun); end
  def process_completion(job); end
  def process_hover(job); end
  def relative_name_in_context(type_name, context); end
  def service; end
  include Steep::Server::ChangeBuffer
end
class Steep::Server::InteractionWorker::ApplyChangeJob
end
class Steep::Server::InteractionWorker::HoverJob < Struct
  def column; end
  def column=(_); end
  def id; end
  def id=(_); end
  def line; end
  def line=(_); end
  def path; end
  def path=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Server::InteractionWorker::CompletionJob < Struct
  def column; end
  def column=(_); end
  def id; end
  def id=(_); end
  def line; end
  def line=(_); end
  def path; end
  def path=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def trigger; end
  def trigger=(_); end
end
class Steep::Server::TypeCheckWorker < Steep::Server::BaseWorker
  def assignment; end
  def commandline_args; end
  def current_type_check_guid; end
  def enqueue_typecheck_jobs(params); end
  def goto(job); end
  def handle_job(job); end
  def handle_request(request); end
  def initialize(project:, reader:, writer:, assignment:, commandline_args:); end
  def project; end
  def service; end
  def stats_result; end
  def typecheck_progress(guid:, path:); end
  def workspace_symbol_result(query); end
  include Steep::Server::ChangeBuffer
end
class Steep::Server::TypeCheckWorker::WorkspaceSymbolJob < Struct
  def id; end
  def id=(_); end
  def query; end
  def query=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Server::TypeCheckWorker::StatsJob < Struct
  def id; end
  def id=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Server::TypeCheckWorker::StartTypeCheckJob < Struct
  def changes; end
  def changes=(_); end
  def guid; end
  def guid=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Server::TypeCheckWorker::TypeCheckCodeJob < Struct
  def guid; end
  def guid=(_); end
  def path; end
  def path=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Server::TypeCheckWorker::ValidateAppSignatureJob < Struct
  def guid; end
  def guid=(_); end
  def path; end
  def path=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Server::TypeCheckWorker::ValidateLibrarySignatureJob < Struct
  def guid; end
  def guid=(_); end
  def path; end
  def path=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Server::TypeCheckWorker::GotoJob < Struct
  def definition?; end
  def id; end
  def id=(_); end
  def implementation?; end
  def kind; end
  def kind=(_); end
  def params; end
  def params=(_); end
  def self.[](*arg0); end
  def self.definition(id:, params:); end
  def self.implementation(id:, params:); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class Steep::Server::Master
  def broadcast_notification(message); end
  def commandline_args; end
  def controller; end
  def current_type_check_request; end
  def each_worker(&block); end
  def fresh_request_id; end
  def group_request; end
  def initialize(project:, reader:, writer:, interaction_worker:, typecheck_workers:, queue: nil); end
  def initialize_params; end
  def interaction_worker; end
  def job_queue; end
  def kill; end
  def on_type_check_update(guid:, path:); end
  def pathname(uri); end
  def process_message_from_client(message); end
  def process_message_from_worker(message, worker:); end
  def project; end
  def reader; end
  def result_controller; end
  def send_notification(message, worker:); end
  def send_request(method:, worker:, id: nil, params: nil, &block); end
  def start; end
  def start_type_check(request, last_request:, start_progress:); end
  def typecheck_automatically; end
  def typecheck_automatically=(arg0); end
  def typecheck_workers; end
  def work_done_progress_supported?; end
  def writer; end
end
class Steep::Server::Master::TypeCheckRequest
  def all_paths; end
  def as_json(assignment:); end
  def checked(path); end
  def checked_paths; end
  def checking_path?(path); end
  def code_paths; end
  def finished?; end
  def guid; end
  def initialize(guid:); end
  def library_paths; end
  def percentage; end
  def priority_paths; end
  def signature_paths; end
  def total; end
  def unchecked_code_paths; end
  def unchecked_library_paths; end
  def unchecked_paths; end
  def unchecked_signature_paths; end
  def uri(path); end
end
class Steep::Server::Master::TypeCheckController
  def changed_paths; end
  def initialize(project:); end
  def load(command_line_args:); end
  def make_request(guid: nil, last_request: nil, include_unchanged: nil); end
  def priority_paths; end
  def project; end
  def push_changes(path); end
  def target_paths; end
  def update_priority(open: nil, close: nil); end
end
class Steep::Server::Master::TypeCheckController::TargetPaths
  def <<(path); end
  def add(path); end
  def all_paths; end
  def code_path?(path); end
  def code_paths; end
  def initialize(project:, target:); end
  def library_path?(path); end
  def library_paths; end
  def project; end
  def signature_path?(path); end
  def signature_paths; end
  def target; end
end
class Steep::Server::Master::ResultHandler
  def completed?; end
  def completion_handler; end
  def initialize(request:); end
  def on_completion(&block); end
  def process_response(message); end
  def request; end
  def response; end
  def result; end
end
class Steep::Server::Master::GroupHandler
  def <<(handler); end
  def completed?; end
  def completion_handler; end
  def handlers; end
  def initialize; end
  def on_completion(&block); end
  def process_response(message); end
  def request; end
end
class Steep::Server::Master::ResultController
  def <<(handler); end
  def handlers; end
  def initialize; end
  def process_response(message); end
  def request_group; end
end
module Steep::Server::Master::MessageUtils
  def id; end
  def method; end
  def notification?; end
  def params; end
  def request?; end
  def response?; end
  def result; end
end
class Steep::Server::Master::ReceiveMessageJob < Struct
  def message; end
  def message=(_); end
  def response?; end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def source; end
  def source=(_); end
  include Steep::Server::Master::MessageUtils
end
class Steep::Server::Master::SendMessageJob < Struct
  def dest; end
  def dest=(_); end
  def message; end
  def message=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def self.to_client(message:); end
  def self.to_worker(worker, message:); end
  include Steep::Server::Master::MessageUtils
end
class Steep::Project
  def absolute_path(path); end
  def base_dir; end
  def initialize(steepfile_path:); end
  def relative_path(path); end
  def steepfile_path; end
  def target_for_source_path(path); end
  def targets; end
  def targets_for_path(path); end
end
class Steep::Project::Pattern
  def =~(path); end
  def ext; end
  def ignore?(path); end
  def ignore_prefixes; end
  def ignores; end
  def initialize(patterns:, ext:, ignores: nil); end
  def match?(path); end
  def patterns; end
  def prefixes; end
  def test_string(path, patterns, prefixes); end
end
class Steep::Project::Options
  def collection_lock; end
  def collection_lock=(arg0); end
  def initialize; end
  def libraries; end
  def paths; end
  def paths=(arg0); end
end
class Steep::Project::Options::PathOptions < Struct
  def core_root; end
  def core_root=(_); end
  def customized_core?; end
  def customized_stdlib?; end
  def repo_paths; end
  def repo_paths=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
  def stdlib_root; end
  def stdlib_root=(_); end
end
class Steep::Project::Target
  def code_diagnostics_config; end
  def initialize(name:, options:, source_pattern:, signature_pattern:, code_diagnostics_config:); end
  def name; end
  def new_env_loader(project:); end
  def options; end
  def possible_signature_file?(path); end
  def possible_source_file?(path); end
  def self.construct_env_loader(options:, project:); end
  def signature_pattern; end
  def source_pattern; end
end
class Steep::Project::DSL
  def initialize(project:); end
  def project; end
  def self.parse(project, code, filename: nil); end
  def self.register_template(name, target); end
  def self.templates; end
  def target(name, template: nil, &block); end
end
class Steep::Project::DSL::TargetDSL
  def check(*args); end
  def code_diagnostics_config; end
  def collection_config(path); end
  def collection_config_path; end
  def configure_code_diagnostics(hash = nil); end
  def core_root; end
  def disable_collection; end
  def ignore(*args); end
  def ignored_sources; end
  def initialize(name, sources: nil, libraries: nil, signatures: nil, ignored_sources: nil, repo_paths: nil, code_diagnostics_config: nil, project: nil, collection_config_path: nil); end
  def initialize_copy(other); end
  def libraries; end
  def library(*args); end
  def name; end
  def no_builtin!(value = nil); end
  def project; end
  def repo_path(*paths); end
  def repo_paths; end
  def signature(*args); end
  def signatures; end
  def sources; end
  def stdlib_path(core_root:, stdlib_root:); end
  def stdlib_root; end
  def typing_options(level = nil, **hash); end
  def update(name: nil, sources: nil, libraries: nil, ignored_sources: nil, signatures: nil, project: nil); end
  def vendor(dir = nil, stdlib: nil, gems: nil); end
end
class Steep::Expectations
  def diagnostics; end
  def initialize; end
  def self.empty; end
  def self.hash_to_lsp(hash); end
  def self.load(path:, content:); end
  def self.lsp_to_hash(lsp); end
  def self.sort_key(hash); end
  def test(path:, diagnostics:); end
  def to_yaml; end
end
class Steep::Expectations::TestResult
  def actual; end
  def each_diagnostics; end
  def empty?; end
  def expectation; end
  def expected_diagnostics; end
  def initialize(path:, expectation:, actual:); end
  def missing_diagnostics; end
  def path; end
  def satisfied?; end
  def unexpected_diagnostics; end
end
module Steep::Drivers
end
module Steep::Drivers::Utils
end
module Steep::Drivers::Utils::DriverHelper
  def keep_diagnostic?(diagnostic); end
  def load_config(path: nil); end
  def request_id; end
  def shutdown_exit(writer:, reader:); end
  def steepfile; end
  def steepfile=(arg0); end
  def type_check(project); end
  def wait_for_message(reader:, unknown_messages: nil, &block); end
  def wait_for_response_id(reader:, id:, unknown_responses: nil); end
end
class Steep::Drivers::Utils::JobsOption
  def default_jobs_count; end
  def initialize(jobs_count_modifier: nil); end
  def jobs_count; end
  def jobs_count=(arg0); end
  def jobs_count_modifier; end
  def jobs_count_modifier=(arg0); end
  def jobs_count_value; end
  def steep_command; end
  def steep_command=(arg0); end
  include Parallel::ProcessorCount
end
class Steep::Drivers::Check
  def command_line_patterns; end
  def initialize(stdout:, stderr:); end
  def jobs_option; end
  def print_expectations(project:, all_files:, expectations_path:, notifications:); end
  def print_result(project:, notifications:); end
  def run; end
  def save_expectations(project:, all_files:, expectations_path:, notifications:); end
  def save_expectations_path; end
  def save_expectations_path=(arg0); end
  def severity_level; end
  def severity_level=(arg0); end
  def stderr; end
  def stdout; end
  def with_expectations_path; end
  def with_expectations_path=(arg0); end
  include Steep::Drivers::Utils::DriverHelper
end
class Steep::Drivers::Checkfile
  def all_rbs; end
  def all_rbs=(arg0); end
  def all_ruby; end
  def all_ruby=(arg0); end
  def command_line_args; end
  def initialize(stdout:, stderr:); end
  def jobs_option; end
  def run; end
  def stderr; end
  def stdin_input; end
  def stdout; end
  include Steep::Drivers::Utils::DriverHelper
end
class Steep::Drivers::Stats
  def command_line_patterns; end
  def format; end
  def format=(arg0); end
  def initialize(stdout:, stderr:); end
  def jobs_option; end
  def run; end
  def stderr; end
  def stdout; end
  include Steep::Drivers::Utils::DriverHelper
end
class Steep::Drivers::Stats::CSVPrinter
  def initialize(io:); end
  def io; end
  def print(stats_result); end
end
class Steep::Drivers::Stats::TablePrinter
  def initialize(io:); end
  def io; end
  def print(stats_result); end
end
class Steep::Drivers::Validate
  def initialize(stdout:, stderr:); end
  def run; end
  def stderr; end
  def stdout; end
  include Steep::Drivers::Utils::DriverHelper
end
class Steep::Drivers::Annotations
  def command_line_patterns; end
  def initialize(stdout:, stderr:); end
  def run; end
  def stderr; end
  def stdout; end
  include Steep::Drivers::Utils::DriverHelper
end
class Steep::Drivers::Watch
  def dirs; end
  def initialize(stdout:, stderr:); end
  def jobs_option; end
  def queue; end
  def run; end
  def severity_level; end
  def severity_level=(arg0); end
  def stderr; end
  def stdout; end
  def watching?(changed_path, files:, dirs:); end
  include Steep::Drivers::Utils::DriverHelper
end
class Steep::Drivers::Langserver
  def initialize(stdout:, stderr:, stdin:); end
  def jobs_option; end
  def project; end
  def reader; end
  def run; end
  def stderr; end
  def stdin; end
  def stdout; end
  def type_check_queue; end
  def type_check_thread; end
  def write_mutex; end
  def writer; end
  include Steep::Drivers::Utils::DriverHelper
end
class Steep::Drivers::PrintProject
  def initialize(stdout:, stderr:); end
  def run; end
  def stderr; end
  def stdout; end
  include Steep::Drivers::Utils::DriverHelper
end
class Steep::Drivers::Init
  def force_write; end
  def force_write=(arg0); end
  def initialize(stdout:, stderr:); end
  def run; end
  def stderr; end
  def stdout; end
  include Steep::Drivers::Utils::DriverHelper
end
class Steep::Drivers::Vendor
  def clean_before; end
  def clean_before=(arg0); end
  def initialize(stdout:, stderr:, stdin:); end
  def run; end
  def stderr; end
  def stdin; end
  def stdout; end
  def vendor_dir; end
  def vendor_dir=(arg0); end
end
class Steep::Drivers::Worker
  def commandline_args; end
  def commandline_args=(arg0); end
  def delay_shutdown; end
  def delay_shutdown=(arg0); end
  def index; end
  def index=(arg0); end
  def initialize(stdout:, stderr:, stdin:); end
  def max_index; end
  def max_index=(arg0); end
  def run; end
  def stderr; end
  def stdin; end
  def stdout; end
  def worker_name; end
  def worker_name=(arg0); end
  def worker_type; end
  def worker_type=(arg0); end
  include Steep::Drivers::Utils::DriverHelper
end
class Steep::Drivers::DiagnosticPrinter
  def buffer; end
  def color_severity(string, severity:); end
  def initialize(stdout:, buffer:); end
  def location(diagnostic); end
  def path; end
  def print(diagnostic, prefix: nil, source: nil); end
  def print_source_line(diagnostic, prefix: nil); end
  def severity_message(severity); end
  def stdout; end
end
class Steep::Sampler
  def average; end
  def count; end
  def initialize; end
  def percentile(p); end
  def sample(message); end
  def slowests(num); end
  def total; end
end
module GCCounter
  def count_objects(title, regexp = nil, skip: nil); end
  def self.count_objects(title, regexp = nil, skip: nil); end
end
