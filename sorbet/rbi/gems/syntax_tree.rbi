# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/syntax_tree/all/syntax_tree.rbi
#
# syntax_tree-6.1.1

module SyntaxTree
  def self.format(source, maxwidth = nil, base_indentation = nil, options: nil); end
  def self.format_file(filepath, maxwidth = nil, base_indentation = nil, options: nil); end
  def self.format_node(source, node, maxwidth = nil, base_indentation = nil, options: nil); end
  def self.index(source); end
  def self.index_file(filepath); end
  def self.mutation; end
  def self.parse(source); end
  def self.parse_file(filepath); end
  def self.read(filepath); end
  def self.register_handler(extension, handler); end
  def self.search(source, query, &block); end
  def self.search_file(filepath, query, &block); end
end
class SyntaxTree::Location
  def ==(other); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def end_char; end
  def end_column; end
  def end_line; end
  def initialize(start_line:, start_char:, start_column:, end_line:, end_char:, end_column:); end
  def lines; end
  def self.default; end
  def self.fixed(line:, char:, column:); end
  def self.token(line:, char:, column:, size:); end
  def start_char; end
  def start_column; end
  def start_line; end
  def to(other); end
end
class SyntaxTree::Node
  def accept(visitor); end
  def child_nodes; end
  def construct_keys; end
  def deconstruct; end
  def deconstruct_keys(keys); end
  def end_char; end
  def format(q); end
  def location; end
  def pretty_print(q); end
  def start_char; end
  def to_json(*opts); end
  def to_mermaid; end
end
module SyntaxTree::ArrayMatch
  def self.call(left, right); end
end
class SyntaxTree::BEGINBlock < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(lbrace: nil, statements: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(lbrace:, statements:, location:); end
  def lbrace; end
  def statements; end
end
class SyntaxTree::CHAR < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::ENDBlock < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(lbrace: nil, statements: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(lbrace:, statements:, location:); end
  def lbrace; end
  def statements; end
end
class SyntaxTree::EndContent < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::AliasNode < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(left: nil, right: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(left:, right:, location:); end
  def left; end
  def right; end
  def var_alias?; end
end
class SyntaxTree::AliasNode::AliasArgumentFormatter
  def argument; end
  def comments; end
  def format(q); end
  def initialize(argument); end
end
class SyntaxTree::ARef < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def collection; end
  def comments; end
  def copy(collection: nil, index: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def index; end
  def initialize(collection:, index:, location:); end
end
class SyntaxTree::ARefField < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def collection; end
  def comments; end
  def copy(collection: nil, index: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def index; end
  def initialize(collection:, index:, location:); end
end
class SyntaxTree::ArgParen < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def arguments; end
  def arity; end
  def child_nodes; end
  def comments; end
  def copy(arguments: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(arguments:, location:); end
  def trailing_comma?; end
end
class SyntaxTree::Args < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def arity; end
  def child_nodes; end
  def comments; end
  def copy(parts: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(parts:, location:); end
  def parts; end
end
class SyntaxTree::ArgBlock < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::ArgStar < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::ArgsForward < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def arity; end
  def child_nodes; end
  def comments; end
  def copy(location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(location:); end
end
class SyntaxTree::ArrayLiteral < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def contents; end
  def copy(lbracket: nil, contents: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def empty_with_comments?; end
  def format(q); end
  def initialize(lbracket:, contents:, location:); end
  def lbracket; end
  def qsymbols?; end
  def qwords?; end
end
class SyntaxTree::ArrayLiteral::BreakableSpaceSeparator
  def call(q); end
end
class SyntaxTree::ArrayLiteral::QWordsFormatter
  def contents; end
  def format(q); end
  def initialize(contents); end
end
class SyntaxTree::ArrayLiteral::QSymbolsFormatter
  def contents; end
  def format(q); end
  def initialize(contents); end
end
class SyntaxTree::ArrayLiteral::EmptyWithCommentsFormatter
  def format(q); end
  def initialize(lbracket); end
  def lbracket; end
end
class SyntaxTree::AryPtn < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def constant; end
  def copy(constant: nil, requireds: nil, rest: nil, posts: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(constant:, requireds:, rest:, posts:, location:); end
  def posts; end
  def requireds; end
  def rest; end
end
class SyntaxTree::AryPtn::RestFormatter
  def comments; end
  def format(q); end
  def initialize(value); end
  def value; end
end
module SyntaxTree::AssignFormatting
  def self.skip_indent?(value); end
end
class SyntaxTree::Assign < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(target: nil, value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(target:, value:, location:); end
  def skip_indent?; end
  def target; end
  def value; end
end
class SyntaxTree::Assoc < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(key: nil, value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def format_contents(q); end
  def initialize(key:, value:, location:); end
  def key; end
  def value; end
end
class SyntaxTree::AssocSplat < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::Backref < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::Backtick < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
module SyntaxTree::HashKeyFormatter
  def self.for(container); end
end
class SyntaxTree::HashKeyFormatter::Labels
  def format_key(q, key); end
end
class SyntaxTree::HashKeyFormatter::Rockets
  def format_key(q, key); end
end
class SyntaxTree::HashKeyFormatter::Identity
  def format_key(q, key); end
end
class SyntaxTree::BareAssocHash < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def assocs; end
  def child_nodes; end
  def comments; end
  def copy(assocs: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def format_key(q, key); end
  def initialize(assocs:, location:); end
end
class SyntaxTree::Begin < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def bodystmt; end
  def child_nodes; end
  def comments; end
  def copy(bodystmt: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(bodystmt:, location:); end
end
class SyntaxTree::PinnedBegin < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(statement: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(statement:, location:); end
  def statement; end
end
class SyntaxTree::Binary < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(left: nil, operator: nil, right: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(left:, operator:, right:, location:); end
  def left; end
  def operator; end
  def right; end
end
class SyntaxTree::BlockVar < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def arg0?; end
  def child_nodes; end
  def comments; end
  def copy(params: nil, locals: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(params:, locals:, location:); end
  def locals; end
  def params; end
end
class SyntaxTree::BlockVar::Separator
  def call(q); end
end
class SyntaxTree::BlockArg < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(name: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(name:, location:); end
  def name; end
end
class SyntaxTree::BodyStmt < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def bind(parser, start_char, start_column, end_char, end_column); end
  def child_nodes; end
  def comments; end
  def copy(statements: nil, rescue_clause: nil, else_keyword: nil, else_clause: nil, ensure_clause: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def else_clause; end
  def else_keyword; end
  def empty?; end
  def ensure_clause; end
  def format(q); end
  def initialize(statements:, rescue_clause:, else_keyword:, else_clause:, ensure_clause:, location:); end
  def rescue_clause; end
  def statements; end
end
class SyntaxTree::FlowControlFormatter
  def format(q); end
  def format_arguments(q, opening, closing); end
  def format_array_contents(q, array); end
  def initialize(keyword, node); end
  def keyword; end
  def node; end
  def skip_parens?(node); end
end
class SyntaxTree::Break < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def arguments; end
  def child_nodes; end
  def comments; end
  def copy(arguments: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(arguments:, location:); end
end
class SyntaxTree::CallOperatorFormatter
  def comments; end
  def format(q); end
  def initialize(operator); end
  def operator; end
end
class SyntaxTree::CallChainFormatter
  def attach_directly?(node); end
  def format(q); end
  def format_chain(q, children); end
  def format_child(q, child, skip_comments: nil, skip_operator: nil, skip_attached: nil); end
  def initialize(node); end
  def node; end
  def self.chained?(node); end
end
class SyntaxTree::CallNode < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def arguments; end
  def arity; end
  def child_nodes; end
  def comments; end
  def copy(receiver: nil, operator: nil, message: nil, arguments: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def format_arguments(q); end
  def format_contents(q); end
  def initialize(receiver:, operator:, message:, arguments:, location:); end
  def message; end
  def operator; end
  def receiver; end
end
class SyntaxTree::Case < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def consequent; end
  def copy(keyword: nil, value: nil, consequent: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(keyword:, value:, consequent:, location:); end
  def keyword; end
  def value; end
end
class SyntaxTree::RAssign < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, operator: nil, pattern: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, operator:, pattern:, location:); end
  def operator; end
  def pattern; end
  def value; end
end
class SyntaxTree::ClassDeclaration < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def bodystmt; end
  def child_nodes; end
  def comments; end
  def constant; end
  def copy(constant: nil, superclass: nil, bodystmt: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def format_declaration(q); end
  def initialize(constant:, superclass:, bodystmt:, location:); end
  def superclass; end
end
class SyntaxTree::Comma < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::Command < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def align(q, node, &block); end
  def arguments; end
  def arity; end
  def block; end
  def child_nodes; end
  def comments; end
  def copy(message: nil, arguments: nil, block: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(message:, arguments:, block:, location:); end
  def message; end
end
class SyntaxTree::CommandCall < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def argument_alignment(q, doc); end
  def arguments; end
  def arity; end
  def block; end
  def child_nodes; end
  def comments; end
  def copy(receiver: nil, operator: nil, message: nil, arguments: nil, block: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(receiver:, operator:, message:, arguments:, block:, location:); end
  def message; end
  def operator; end
  def receiver; end
end
class SyntaxTree::Comment < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, inline: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def ignore?; end
  def initialize(value:, inline:, location:); end
  def inline; end
  def inline?; end
  def leading!; end
  def leading?; end
  def trailing!; end
  def trailing?; end
  def value; end
end
class SyntaxTree::Const < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::ConstPathField < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def constant; end
  def copy(parent: nil, constant: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(parent:, constant:, location:); end
  def parent; end
end
class SyntaxTree::ConstPathRef < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def constant; end
  def copy(parent: nil, constant: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(parent:, constant:, location:); end
  def parent; end
end
class SyntaxTree::ConstRef < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def constant; end
  def copy(constant: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(constant:, location:); end
end
class SyntaxTree::CVar < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::DefNode < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def arity; end
  def bodystmt; end
  def child_nodes; end
  def comments; end
  def copy(target: nil, operator: nil, name: nil, params: nil, bodystmt: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def endless?; end
  def format(q); end
  def initialize(target:, operator:, name:, params:, bodystmt:, location:); end
  def name; end
  def operator; end
  def params; end
  def target; end
end
class SyntaxTree::Defined < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::BlockNode < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def arity; end
  def block_var; end
  def bodystmt; end
  def child_nodes; end
  def comments; end
  def copy(opening: nil, block_var: nil, bodystmt: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def forced_brace_bounds?(q); end
  def forced_do_end_bounds?(q); end
  def format(q); end
  def format_break(q, break_opening, break_closing); end
  def format_flat(q, flat_opening, flat_closing); end
  def initialize(opening:, block_var:, bodystmt:, location:); end
  def keywords?; end
  def opening; end
  def unchangeable_bounds?(q); end
end
class SyntaxTree::BlockNode::BlockOpenFormatter
  def comments; end
  def format(q); end
  def initialize(text, node); end
  def node; end
  def text; end
end
class SyntaxTree::RangeNode < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(left: nil, operator: nil, right: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(left:, operator:, right:, location:); end
  def left; end
  def operator; end
  def right; end
end
module SyntaxTree::Quotes
  def self.locked?(node, quote); end
  def self.matching(quote); end
  def self.normalize(content, enclosing); end
end
class SyntaxTree::DynaSymbol < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(parts: nil, quote: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(parts:, quote:, location:); end
  def parts; end
  def quote; end
  def quotes(q); end
end
class SyntaxTree::Else < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(keyword: nil, statements: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(keyword:, statements:, location:); end
  def keyword; end
  def statements; end
end
class SyntaxTree::Elsif < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def consequent; end
  def copy(predicate: nil, statements: nil, consequent: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(predicate:, statements:, consequent:, location:); end
  def predicate; end
  def statements; end
end
class SyntaxTree::EmbDoc < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def ignore?; end
  def initialize(value:, location:); end
  def inline?; end
  def leading!; end
  def leading?; end
  def trailing!; end
  def trailing?; end
  def value; end
end
class SyntaxTree::EmbExprBeg < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::EmbExprEnd < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::EmbVar < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::Ensure < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(keyword: nil, statements: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(keyword:, statements:, location:); end
  def keyword; end
  def statements; end
end
class SyntaxTree::ExcessedComma < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::Field < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(parent: nil, operator: nil, name: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(parent:, operator:, name:, location:); end
  def name; end
  def operator; end
  def parent; end
end
class SyntaxTree::FloatLiteral < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::FndPtn < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def constant; end
  def copy(constant: nil, left: nil, values: nil, right: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(constant:, left:, values:, right:, location:); end
  def left; end
  def right; end
  def values; end
end
class SyntaxTree::For < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def collection; end
  def comments; end
  def copy(index: nil, collection: nil, statements: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def index; end
  def initialize(index:, collection:, statements:, location:); end
  def statements; end
end
class SyntaxTree::GVar < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::HashLiteral < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def assocs; end
  def child_nodes; end
  def comments; end
  def copy(lbrace: nil, assocs: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def empty_with_comments?; end
  def format(q); end
  def format_contents(q); end
  def format_key(q, key); end
  def initialize(lbrace:, assocs:, location:); end
  def lbrace; end
end
class SyntaxTree::HashLiteral::EmptyWithCommentsFormatter
  def format(q); end
  def initialize(lbrace); end
  def lbrace; end
end
class SyntaxTree::Heredoc < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def beginning; end
  def child_nodes; end
  def comments; end
  def copy(beginning: nil, location: nil, ending: nil, parts: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def dedent; end
  def ending; end
  def format(q); end
  def initialize(beginning:, location:, ending: nil, dedent: nil, parts: nil); end
  def parts; end
end
class SyntaxTree::HeredocBeg < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::HeredocEnd < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::HshPtn < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def constant; end
  def copy(constant: nil, keywords: nil, keyword_rest: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def format_contents(q, parts, nested); end
  def initialize(constant:, keywords:, keyword_rest:, location:); end
  def keyword_rest; end
  def keywords; end
end
class SyntaxTree::HshPtn::KeywordFormatter
  def comments; end
  def format(q); end
  def initialize(key, value); end
  def key; end
  def value; end
end
class SyntaxTree::HshPtn::KeywordRestFormatter
  def comments; end
  def format(q); end
  def initialize(keyword_rest); end
  def keyword_rest; end
end
class SyntaxTree::Ident < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
module SyntaxTree::ContainsAssignment
  def self.call(parent); end
end
module SyntaxTree::Ternaryable
  def self.call(q, node); end
  def self.ternaryable?(statement); end
end
class SyntaxTree::ConditionalFormatter
  def contains_conditional?; end
  def format(q); end
  def format_break(q, force:); end
  def format_flat(q); end
  def format_ternary(q); end
  def initialize(keyword, node); end
  def keyword; end
  def node; end
end
class SyntaxTree::IfNode < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def consequent; end
  def copy(predicate: nil, statements: nil, consequent: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(predicate:, statements:, consequent:, location:); end
  def modifier?; end
  def predicate; end
  def statements; end
end
class SyntaxTree::IfOp < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(predicate: nil, truthy: nil, falsy: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def falsy; end
  def format(q); end
  def format_break(q); end
  def format_flat(q); end
  def initialize(predicate:, truthy:, falsy:, location:); end
  def predicate; end
  def truthy; end
end
class SyntaxTree::Imaginary < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::In < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def consequent; end
  def copy(pattern: nil, statements: nil, consequent: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(pattern:, statements:, consequent:, location:); end
  def pattern; end
  def statements; end
end
class SyntaxTree::Int < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::IVar < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::Kw < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def name; end
  def value; end
end
class SyntaxTree::KwRestParam < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(name: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(name:, location:); end
  def name; end
end
class SyntaxTree::Label < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::LabelEnd < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::Lambda < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(params: nil, statements: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(params:, statements:, location:); end
  def params; end
  def statements; end
end
class SyntaxTree::LambdaVar < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(params: nil, locals: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def empty?; end
  def format(q); end
  def initialize(params:, locals:, location:); end
  def locals; end
  def params; end
end
class SyntaxTree::LBrace < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def self.default; end
  def value; end
end
class SyntaxTree::LBracket < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def self.default; end
  def value; end
end
class SyntaxTree::LParen < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def self.default; end
  def value; end
end
class SyntaxTree::MAssign < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(target: nil, value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(target:, value:, location:); end
  def target; end
  def value; end
end
class SyntaxTree::MethodAddBlock < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def block; end
  def call; end
  def child_nodes; end
  def comments; end
  def copy(call: nil, block: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def format_contents(q); end
  def initialize(call:, block:, location:); end
end
class SyntaxTree::MLHS < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comma; end
  def comma=(arg0); end
  def comments; end
  def copy(parts: nil, location: nil, comma: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(parts:, location:, comma: nil); end
  def parts; end
end
class SyntaxTree::MLHSParen < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comma; end
  def comma=(arg0); end
  def comments; end
  def contents; end
  def copy(contents: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(contents:, location:, comma: nil); end
end
class SyntaxTree::ModuleDeclaration < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def bodystmt; end
  def child_nodes; end
  def comments; end
  def constant; end
  def copy(constant: nil, bodystmt: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def format_declaration(q); end
  def initialize(constant:, bodystmt:, location:); end
end
class SyntaxTree::MRHS < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(parts: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(parts:, location:); end
  def parts; end
end
class SyntaxTree::Next < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def arguments; end
  def child_nodes; end
  def comments; end
  def copy(arguments: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(arguments:, location:); end
end
class SyntaxTree::Op < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def name; end
  def value; end
end
class SyntaxTree::OpAssign < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(target: nil, operator: nil, value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(target:, operator:, value:, location:); end
  def operator; end
  def skip_indent?; end
  def target; end
  def value; end
end
module SyntaxTree::Parentheses
  def self.break(q); end
  def self.flat(q); end
end
class SyntaxTree::Params < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def arity; end
  def block; end
  def child_nodes; end
  def comments; end
  def copy(location: nil, requireds: nil, optionals: nil, rest: nil, posts: nil, keywords: nil, keyword_rest: nil, block: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def empty?; end
  def format(q); end
  def format_contents(q, parts); end
  def initialize(location:, requireds: nil, optionals: nil, rest: nil, posts: nil, keywords: nil, keyword_rest: nil, block: nil); end
  def keyword_rest; end
  def keywords; end
  def optionals; end
  def posts; end
  def requireds; end
  def rest; end
end
class SyntaxTree::Params::OptionalFormatter
  def comments; end
  def format(q); end
  def initialize(name, value); end
  def name; end
  def value; end
end
class SyntaxTree::Params::KeywordFormatter
  def comments; end
  def format(q); end
  def initialize(name, value); end
  def name; end
  def value; end
end
class SyntaxTree::Params::KeywordRestFormatter
  def comments; end
  def format(q); end
  def initialize(value); end
  def value; end
end
class SyntaxTree::Paren < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def contents; end
  def copy(lparen: nil, contents: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(lparen:, contents:, location:); end
  def lparen; end
end
class SyntaxTree::Period < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::Program < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(statements: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(statements:, location:); end
  def statements; end
end
class SyntaxTree::QSymbols < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def beginning; end
  def child_nodes; end
  def comments; end
  def copy(beginning: nil, elements: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def elements; end
  def format(q); end
  def initialize(beginning:, elements:, location:); end
end
class SyntaxTree::QSymbolsBeg < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::QWords < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def beginning; end
  def child_nodes; end
  def comments; end
  def copy(beginning: nil, elements: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def elements; end
  def format(q); end
  def initialize(beginning:, elements:, location:); end
end
class SyntaxTree::QWordsBeg < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::RationalLiteral < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::RBrace < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::RBracket < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::Redo < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(location:); end
end
class SyntaxTree::RegexpContent < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def beginning; end
  def child_nodes; end
  def copy(beginning: nil, parts: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def initialize(beginning:, parts:, location:); end
  def parts; end
end
class SyntaxTree::RegexpBeg < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::RegexpEnd < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::RegexpLiteral < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def ambiguous?(q); end
  def beginning; end
  def child_nodes; end
  def comments; end
  def copy(beginning: nil, ending: nil, parts: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def ending; end
  def format(q); end
  def include?(pattern); end
  def initialize(beginning:, ending:, parts:, location:); end
  def options; end
  def parts; end
end
class SyntaxTree::RescueEx < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(exceptions: nil, variable: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def exceptions; end
  def format(q); end
  def initialize(exceptions:, variable:, location:); end
  def variable; end
end
class SyntaxTree::Rescue < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def bind_end(end_char, end_column); end
  def child_nodes; end
  def comments; end
  def consequent; end
  def copy(keyword: nil, exception: nil, statements: nil, consequent: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def exception; end
  def format(q); end
  def initialize(keyword:, exception:, statements:, consequent:, location:); end
  def keyword; end
  def statements; end
end
class SyntaxTree::RescueMod < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(statement: nil, value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(statement:, value:, location:); end
  def statement; end
  def value; end
end
class SyntaxTree::RestParam < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(name: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(name:, location:); end
  def name; end
end
class SyntaxTree::Retry < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(location:); end
end
class SyntaxTree::ReturnNode < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def arguments; end
  def child_nodes; end
  def comments; end
  def copy(arguments: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(arguments:, location:); end
end
class SyntaxTree::RParen < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::SClass < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def bodystmt; end
  def child_nodes; end
  def comments; end
  def copy(target: nil, bodystmt: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(target:, bodystmt:, location:); end
  def target; end
end
class SyntaxTree::Statements < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def attach_comments(parser, start_char, end_char); end
  def bind(parser, start_char, start_column, end_char, end_column); end
  def bind_end(end_char, end_column); end
  def body; end
  def child_nodes; end
  def comments; end
  def copy(body: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def empty?; end
  def format(q); end
  def initialize(body:, location:); end
end
class SyntaxTree::StringContent < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(parts: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(parts:, location:); end
  def parts; end
end
class SyntaxTree::StringConcat < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(left: nil, right: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(left:, right:, location:); end
  def left; end
  def right; end
end
class SyntaxTree::StringDVar < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(variable: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(variable:, location:); end
  def variable; end
end
class SyntaxTree::StringEmbExpr < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(statements: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(statements:, location:); end
  def statements; end
end
class SyntaxTree::StringLiteral < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(parts: nil, quote: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(parts:, quote:, location:); end
  def parts; end
  def quote; end
end
class SyntaxTree::Super < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def arguments; end
  def child_nodes; end
  def comments; end
  def copy(arguments: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(arguments:, location:); end
end
class SyntaxTree::SymBeg < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::SymbolContent < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::SymbolLiteral < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::Symbols < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def beginning; end
  def child_nodes; end
  def comments; end
  def copy(beginning: nil, elements: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def elements; end
  def format(q); end
  def initialize(beginning:, elements:, location:); end
end
class SyntaxTree::SymbolsBeg < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::TLambda < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::TLamBeg < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::TopConstField < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def constant; end
  def copy(constant: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(constant:, location:); end
end
class SyntaxTree::TopConstRef < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def constant; end
  def copy(constant: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(constant:, location:); end
end
class SyntaxTree::TStringBeg < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::TStringContent < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def match?(pattern); end
  def value; end
end
class SyntaxTree::TStringEnd < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::Not < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(statement: nil, parentheses: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(statement:, parentheses:, location:); end
  def parentheses; end
  def parentheses?; end
  def statement; end
end
class SyntaxTree::Unary < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(operator: nil, statement: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(operator:, statement:, location:); end
  def operator; end
  def statement; end
end
class SyntaxTree::Undef < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(symbols: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(symbols:, location:); end
  def symbols; end
end
class SyntaxTree::Undef::UndefArgumentFormatter
  def comments; end
  def format(q); end
  def initialize(node); end
  def node; end
end
class SyntaxTree::UnlessNode < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def consequent; end
  def copy(predicate: nil, statements: nil, consequent: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(predicate:, statements:, consequent:, location:); end
  def modifier?; end
  def predicate; end
  def statements; end
end
class SyntaxTree::LoopFormatter
  def format(q); end
  def format_break(q); end
  def initialize(keyword, node); end
  def keyword; end
  def node; end
end
class SyntaxTree::UntilNode < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(predicate: nil, statements: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(predicate:, statements:, location:); end
  def modifier?; end
  def predicate; end
  def statements; end
end
class SyntaxTree::VarField < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::VarRef < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def pin(parent, pin); end
  def value; end
end
class SyntaxTree::PinnedVarRef < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::VCall < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def access_control?; end
  def arity; end
  def child_nodes; end
  def comments; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::VoidStmt < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(location:); end
end
class SyntaxTree::When < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def arguments; end
  def child_nodes; end
  def comments; end
  def consequent; end
  def copy(arguments: nil, statements: nil, consequent: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(arguments:, statements:, consequent:, location:); end
  def statements; end
end
class SyntaxTree::When::Separator
  def call(q); end
end
class SyntaxTree::WhileNode < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(predicate: nil, statements: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(predicate:, statements:, location:); end
  def modifier?; end
  def predicate; end
  def statements; end
end
class SyntaxTree::Word < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(parts: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(parts:, location:); end
  def match?(pattern); end
  def parts; end
end
class SyntaxTree::Words < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def beginning; end
  def child_nodes; end
  def comments; end
  def copy(beginning: nil, elements: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def elements; end
  def format(q); end
  def initialize(beginning:, elements:, location:); end
end
class SyntaxTree::WordsBeg < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def copy(value: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def initialize(value:, location:); end
  def value; end
end
class SyntaxTree::XString < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def copy(parts: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def initialize(parts:, location:); end
  def parts; end
end
class SyntaxTree::XStringLiteral < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(parts: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(parts:, location:); end
  def parts; end
end
class SyntaxTree::YieldNode < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def arguments; end
  def child_nodes; end
  def comments; end
  def copy(arguments: nil, location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(arguments:, location:); end
end
class SyntaxTree::ZSuper < SyntaxTree::Node
  def ===(other); end
  def accept(visitor); end
  def child_nodes; end
  def comments; end
  def copy(location: nil); end
  def deconstruct; end
  def deconstruct_keys(_keys); end
  def format(q); end
  def initialize(location:); end
end
class SyntaxTree::BasicVisitor
  def self.valid_visit_methods; end
  def self.visit_method(method_name); end
  def self.visit_methods; end
  def visit(node); end
  def visit_all(nodes); end
  def visit_child_nodes(node); end
end
class SyntaxTree::BasicVisitor::VisitMethodError < StandardError
  def initialize(visit_method); end
  def visit_method; end
end
class SyntaxTree::BasicVisitor::VisitMethodChecker
  def corrections; end
  def initialize(error); end
  def visit_method; end
end
class SyntaxTree::BasicVisitor::VisitMethodsChecker < Module
  def disable!; end
  def initialize; end
  def status; end
end
class SyntaxTree::BasicVisitor::VisitMethodsChecker::Status < Struct
  def checking; end
  def checking=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.keyword_init?; end
  def self.members; end
  def self.new(*arg0); end
end
class SyntaxTree::Visitor < SyntaxTree::BasicVisitor
  def visit_BEGIN(node); end
  def visit_CHAR(node); end
  def visit_END(node); end
  def visit___end__(node); end
  def visit_alias(node); end
  def visit_aref(node); end
  def visit_aref_field(node); end
  def visit_arg_block(node); end
  def visit_arg_paren(node); end
  def visit_arg_star(node); end
  def visit_args(node); end
  def visit_args_forward(node); end
  def visit_array(node); end
  def visit_aryptn(node); end
  def visit_assign(node); end
  def visit_assoc(node); end
  def visit_assoc_splat(node); end
  def visit_backref(node); end
  def visit_backtick(node); end
  def visit_bare_assoc_hash(node); end
  def visit_begin(node); end
  def visit_binary(node); end
  def visit_block(node); end
  def visit_block_var(node); end
  def visit_blockarg(node); end
  def visit_bodystmt(node); end
  def visit_break(node); end
  def visit_call(node); end
  def visit_case(node); end
  def visit_class(node); end
  def visit_comma(node); end
  def visit_command(node); end
  def visit_command_call(node); end
  def visit_comment(node); end
  def visit_const(node); end
  def visit_const_path_field(node); end
  def visit_const_path_ref(node); end
  def visit_const_ref(node); end
  def visit_cvar(node); end
  def visit_def(node); end
  def visit_defined(node); end
  def visit_dyna_symbol(node); end
  def visit_else(node); end
  def visit_elsif(node); end
  def visit_embdoc(node); end
  def visit_embexpr_beg(node); end
  def visit_embexpr_end(node); end
  def visit_embvar(node); end
  def visit_ensure(node); end
  def visit_excessed_comma(node); end
  def visit_field(node); end
  def visit_float(node); end
  def visit_fndptn(node); end
  def visit_for(node); end
  def visit_gvar(node); end
  def visit_hash(node); end
  def visit_heredoc(node); end
  def visit_heredoc_beg(node); end
  def visit_heredoc_end(node); end
  def visit_hshptn(node); end
  def visit_ident(node); end
  def visit_if(node); end
  def visit_if_op(node); end
  def visit_imaginary(node); end
  def visit_in(node); end
  def visit_int(node); end
  def visit_ivar(node); end
  def visit_kw(node); end
  def visit_kwrest_param(node); end
  def visit_label(node); end
  def visit_label_end(node); end
  def visit_lambda(node); end
  def visit_lambda_var(node); end
  def visit_lbrace(node); end
  def visit_lbracket(node); end
  def visit_lparen(node); end
  def visit_massign(node); end
  def visit_method_add_block(node); end
  def visit_mlhs(node); end
  def visit_mlhs_paren(node); end
  def visit_module(node); end
  def visit_mrhs(node); end
  def visit_next(node); end
  def visit_not(node); end
  def visit_op(node); end
  def visit_opassign(node); end
  def visit_params(node); end
  def visit_paren(node); end
  def visit_period(node); end
  def visit_pinned_begin(node); end
  def visit_pinned_var_ref(node); end
  def visit_program(node); end
  def visit_qsymbols(node); end
  def visit_qsymbols_beg(node); end
  def visit_qwords(node); end
  def visit_qwords_beg(node); end
  def visit_range(node); end
  def visit_rassign(node); end
  def visit_rational(node); end
  def visit_rbrace(node); end
  def visit_rbracket(node); end
  def visit_redo(node); end
  def visit_regexp_beg(node); end
  def visit_regexp_content(node); end
  def visit_regexp_end(node); end
  def visit_regexp_literal(node); end
  def visit_rescue(node); end
  def visit_rescue_ex(node); end
  def visit_rescue_mod(node); end
  def visit_rest_param(node); end
  def visit_retry(node); end
  def visit_return(node); end
  def visit_rparen(node); end
  def visit_sclass(node); end
  def visit_statements(node); end
  def visit_string_concat(node); end
  def visit_string_content(node); end
  def visit_string_dvar(node); end
  def visit_string_embexpr(node); end
  def visit_string_literal(node); end
  def visit_super(node); end
  def visit_symbeg(node); end
  def visit_symbol_content(node); end
  def visit_symbol_literal(node); end
  def visit_symbols(node); end
  def visit_symbols_beg(node); end
  def visit_tlambda(node); end
  def visit_tlambeg(node); end
  def visit_top_const_field(node); end
  def visit_top_const_ref(node); end
  def visit_tstring_beg(node); end
  def visit_tstring_content(node); end
  def visit_tstring_end(node); end
  def visit_unary(node); end
  def visit_undef(node); end
  def visit_unless(node); end
  def visit_until(node); end
  def visit_var_field(node); end
  def visit_var_ref(node); end
  def visit_vcall(node); end
  def visit_void_stmt(node); end
  def visit_when(node); end
  def visit_while(node); end
  def visit_word(node); end
  def visit_words(node); end
  def visit_words_beg(node); end
  def visit_xstring(node); end
  def visit_xstring_literal(node); end
  def visit_yield(node); end
  def visit_zsuper(node); end
end
class SyntaxTree::Formatter < PrettierPrint
  def disable_auto_ternary; end
  def disable_auto_ternary?; end
  def format(node, stackable: nil); end
  def format_each(nodes); end
  def grandparent; end
  def group; end
  def initialize(source, *args, options: nil); end
  def parent; end
  def parents; end
  def quote; end
  def self.format(source, node, base_indentation = nil); end
  def seplist(list, sep = nil, iter_method = nil); end
  def source; end
  def stack; end
  def target_ruby_version; end
  def text(string); end
  def trailing_comma; end
  def trailing_comma?; end
end
class SyntaxTree::Formatter::SemanticVersion < Gem::Version
  def initialize(version); end
end
class SyntaxTree::Formatter::Options
  def disable_auto_ternary; end
  def initialize(quote: nil, trailing_comma: nil, disable_auto_ternary: nil, target_ruby_version: nil); end
  def quote; end
  def target_ruby_version; end
  def trailing_comma; end
end
class SyntaxTree::Parser < Ripper
  def attach_comments(program, comments); end
  def char_pos; end
  def comments; end
  def consume_error(name, location); end
  def consume_keyword(name); end
  def consume_operator(name); end
  def consume_token(type); end
  def consume_tstring_end(location); end
  def current_column; end
  def find_colon2_before(const); end
  def find_keyword(name); end
  def find_keyword_between(name, left, right); end
  def find_next_statement_start(position); end
  def find_operator(name); end
  def find_token(type); end
  def find_token_between(type, left, right); end
  def find_token_error(location); end
  def initialize(source, *); end
  def lambda_locals(source); end
  def line_counts; end
  def nearest_nodes(node, comment); end
  def on_BEGIN(statements); end
  def on_CHAR(value); end
  def on_END(statements); end
  def on___end__(value); end
  def on_alias(left, right); end
  def on_alias_error(error, *); end
  def on_aref(collection, index); end
  def on_aref_field(collection, index); end
  def on_arg_paren(arguments); end
  def on_args_add(arguments, argument); end
  def on_args_add_block(arguments, block); end
  def on_args_add_star(arguments, argument); end
  def on_args_forward; end
  def on_args_new; end
  def on_array(contents); end
  def on_aryptn(constant, requireds, rest, posts); end
  def on_assign(target, value); end
  def on_assign_error(error, *); end
  def on_assoc_new(key, value); end
  def on_assoc_splat(value); end
  def on_backref(value); end
  def on_backtick(value); end
  def on_bare_assoc_hash(assocs); end
  def on_begin(bodystmt); end
  def on_binary(left, operator, right); end
  def on_block_var(params, locals); end
  def on_blockarg(name); end
  def on_bodystmt(statements, rescue_clause, else_clause, ensure_clause); end
  def on_brace_block(block_var, statements); end
  def on_break(arguments); end
  def on_call(receiver, operator, message); end
  def on_case(value, consequent); end
  def on_class(constant, superclass, bodystmt); end
  def on_class_name_error(error, *); end
  def on_comma(value); end
  def on_command(message, arguments); end
  def on_command_call(receiver, operator, message, arguments); end
  def on_comment(value); end
  def on_const(value); end
  def on_const_path_field(parent, constant); end
  def on_const_path_ref(parent, constant); end
  def on_const_ref(constant); end
  def on_cvar(value); end
  def on_def(name, params, bodystmt); end
  def on_defined(value); end
  def on_defs(target, operator, name, params, bodystmt); end
  def on_do_block(block_var, bodystmt); end
  def on_dot2(left, right); end
  def on_dot3(left, right); end
  def on_dyna_symbol(string_content); end
  def on_else(statements); end
  def on_elsif(predicate, statements, consequent); end
  def on_embdoc(value); end
  def on_embdoc_beg(value); end
  def on_embdoc_end(value); end
  def on_embexpr_beg(value); end
  def on_embexpr_end(value); end
  def on_embvar(value); end
  def on_ensure(statements); end
  def on_excessed_comma(*); end
  def on_fcall(value); end
  def on_field(parent, operator, name); end
  def on_float(value); end
  def on_fndptn(constant, left, values, right); end
  def on_for(index, collection, statements); end
  def on_gvar(value); end
  def on_hash(assocs); end
  def on_heredoc_beg(value); end
  def on_heredoc_dedent(string, width); end
  def on_heredoc_end(value); end
  def on_hshptn(constant, keywords, keyword_rest); end
  def on_ident(value); end
  def on_if(predicate, statements, consequent); end
  def on_if_mod(predicate, statement); end
  def on_ifop(predicate, truthy, falsy); end
  def on_imaginary(value); end
  def on_in(pattern, statements, consequent); end
  def on_int(value); end
  def on_ivar(value); end
  def on_kw(value); end
  def on_kwrest_param(name); end
  def on_label(value); end
  def on_label_end(value); end
  def on_lambda(params, statements); end
  def on_lambda_var(params, locals); end
  def on_lbrace(value); end
  def on_lbracket(value); end
  def on_lparen(value); end
  def on_massign(target, value); end
  def on_method_add_arg(call, arguments); end
  def on_method_add_block(call, block); end
  def on_mlhs_add(mlhs, part); end
  def on_mlhs_add_post(left, right); end
  def on_mlhs_add_star(mlhs, part); end
  def on_mlhs_new; end
  def on_mlhs_paren(contents); end
  def on_module(constant, bodystmt); end
  def on_mrhs_add(mrhs, part); end
  def on_mrhs_add_star(mrhs, value); end
  def on_mrhs_new; end
  def on_mrhs_new_from_args(arguments); end
  def on_next(arguments); end
  def on_op(value); end
  def on_opassign(target, operator, value); end
  def on_param_error(error, *); end
  def on_params(requireds, optionals, rest, posts, keywords, keyword_rest, block); end
  def on_paren(contents); end
  def on_parse_error(error, *); end
  def on_period(value); end
  def on_program(statements); end
  def on_qsymbols_add(qsymbols, element); end
  def on_qsymbols_beg(value); end
  def on_qsymbols_new; end
  def on_qwords_add(qwords, element); end
  def on_qwords_beg(value); end
  def on_qwords_new; end
  def on_rational(value); end
  def on_rbrace(value); end
  def on_rbracket(value); end
  def on_redo; end
  def on_regexp_add(regexp_content, part); end
  def on_regexp_beg(value); end
  def on_regexp_end(value); end
  def on_regexp_literal(regexp_content, ending); end
  def on_regexp_new; end
  def on_rescue(exceptions, variable, statements, consequent); end
  def on_rescue_mod(statement, value); end
  def on_rest_param(name); end
  def on_retry; end
  def on_return(arguments); end
  def on_return0; end
  def on_rparen(value); end
  def on_sclass(target, bodystmt); end
  def on_semicolon(value); end
  def on_stmts_add(statements, statement); end
  def on_stmts_new; end
  def on_string_add(string, part); end
  def on_string_concat(left, right); end
  def on_string_content; end
  def on_string_dvar(variable); end
  def on_string_embexpr(statements); end
  def on_string_literal(string); end
  def on_super(arguments); end
  def on_symbeg(value); end
  def on_symbol(value); end
  def on_symbol_literal(value); end
  def on_symbols_add(symbols, word); end
  def on_symbols_beg(value); end
  def on_symbols_new; end
  def on_tlambda(value); end
  def on_tlambeg(value); end
  def on_top_const_field(constant); end
  def on_top_const_ref(constant); end
  def on_tstring_beg(value); end
  def on_tstring_content(value); end
  def on_tstring_end(value); end
  def on_unary(operator, statement); end
  def on_undef(symbols); end
  def on_unless(predicate, statements, consequent); end
  def on_unless_mod(predicate, statement); end
  def on_until(predicate, statements); end
  def on_until_mod(predicate, statement); end
  def on_var_alias(left, right); end
  def on_var_field(value); end
  def on_var_ref(value); end
  def on_vcall(ident); end
  def on_void_stmt; end
  def on_when(arguments, statements, consequent); end
  def on_while(predicate, statements); end
  def on_while_mod(predicate, statement); end
  def on_word_add(word, part); end
  def on_word_new; end
  def on_words_add(words, word); end
  def on_words_beg(value); end
  def on_words_new; end
  def on_xstring_add(xstring, part); end
  def on_xstring_literal(xstring); end
  def on_xstring_new; end
  def on_yield(arguments); end
  def on_yield0; end
  def on_zsuper; end
  def source; end
  def tokens; end
end
class SyntaxTree::Parser::ParseError < StandardError
  def column; end
  def initialize(error, lineno, column); end
  def lineno; end
end
class SyntaxTree::Parser::SingleByteString
  def [](byteindex); end
  def initialize(start); end
  def start; end
end
class SyntaxTree::Parser::MultiByteString
  def [](byteindex); end
  def indices; end
  def initialize(start, line); end
  def start; end
end
class SyntaxTree::Parser::TokenList
  def <<(token); end
  def [](index); end
  def any?(&block); end
  def delete(value); end
  def delete_at(index); end
  def initialize; end
  def last_deleted; end
  def reverse_each(&block); end
  def rindex(&block); end
  def tokens; end
end
class SyntaxTree::Parser::PinVisitor < SyntaxTree::Visitor
  def initialize(pins); end
  def pins; end
  def self.visit(node, tokens); end
  def stack; end
  def visit(node); end
  def visit_var_ref(node); end
  extend Anonymous_SyntaxTree_BasicVisitor_VisitMethodsChecker_4
end
module Anonymous_SyntaxTree_BasicVisitor_VisitMethodsChecker_4
  def method_added(name); end
end
class SyntaxTree::Parser::Semicolon
  def initialize(location); end
  def location; end
end
