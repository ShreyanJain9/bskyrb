# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

module ActiveSupport
  def parse_json_times(); end

  def parse_json_times=(val); end
end

class ActiveSupport::ArrayInquirer
  def any?(*candidates); end
end

class ActiveSupport::ArrayInquirer
end

class ActiveSupport::BacktraceCleaner
  FORMATTED_GEMS_PATTERN = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::BigDecimalWithDefaultFormat
  def to_s(format=T.unsafe(nil)); end
end

module ActiveSupport::BigDecimalWithDefaultFormat
end

module ActiveSupport::Cache
  DEFAULT_COMPRESS_LIMIT = ::T.let(nil, ::T.untyped)
  OPTION_ALIASES = ::T.let(nil, ::T.untyped)
  UNIVERSAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::Coders
  MARK_61 = ::T.let(nil, ::T.untyped)
  MARK_70_COMPRESSED = ::T.let(nil, ::T.untyped)
  MARK_70_UNCOMPRESSED = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::NullStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
end

module ActiveSupport::Callbacks
  CALLBACK_FILTER_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::CodeGenerator
  def define_cached_method(name, namespace:, as: T.unsafe(nil), &block); end

  def execute(); end

  def initialize(owner, path, line); end
end

class ActiveSupport::CodeGenerator::MethodSet
  def apply(owner, path, line); end

  def define_cached_method(name, as: T.unsafe(nil)); end

  def initialize(namespace); end
  METHOD_CACHES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::CodeGenerator::MethodSet
end

class ActiveSupport::CodeGenerator
  def self.batch(owner, path, line); end
end

module ActiveSupport::Configurable
  def config(); end
end

module ActiveSupport::Configurable::ClassMethods
  def config(); end

  def configure(); end
end

class ActiveSupport::Configurable::Configuration
  def compile_methods!(); end
end

class ActiveSupport::Configurable::Configuration
  def self.compile_methods!(keys); end
end

module ActiveSupport::Configurable
  extend ::ActiveSupport::Concern
end

class ActiveSupport::ConfigurationFile
  def initialize(content_path); end

  def parse(context: T.unsafe(nil), **options); end
end

class ActiveSupport::ConfigurationFile::FormatError
end

class ActiveSupport::ConfigurationFile::FormatError
end

class ActiveSupport::ConfigurationFile
  def self.parse(content_path, **options); end
end

class ActiveSupport::Deprecation
  include ::Singleton
  include ::ActiveSupport::Deprecation::InstanceDelegator
  include ::ActiveSupport::Deprecation::Behavior
  include ::ActiveSupport::Deprecation::Reporting
  include ::ActiveSupport::Deprecation::Disallowed
  include ::ActiveSupport::Deprecation::MethodWrapper
  def deprecation_horizon(); end

  def deprecation_horizon=(deprecation_horizon); end

  def initialize(deprecation_horizon=T.unsafe(nil), gem_name=T.unsafe(nil)); end
end

module ActiveSupport::Deprecation::Behavior
  def behavior(); end

  def behavior=(behavior); end

  def debug(); end

  def debug=(debug); end

  def disallowed_behavior(); end

  def disallowed_behavior=(behavior); end
end

module ActiveSupport::Deprecation::Behavior
end

module ActiveSupport::Deprecation::DeprecatedConstantAccessor
end

module ActiveSupport::Deprecation::DeprecatedConstantAccessor
  def self.included(base); end
end

class ActiveSupport::Deprecation::DeprecatedConstantProxy
  def hash(*arg, **arg1, &arg2); end

  def initialize(old_const, new_const, deprecator=T.unsafe(nil), message: T.unsafe(nil)); end

  def instance_methods(*arg, **arg1, &arg2); end

  def name(*arg, **arg1, &arg2); end

  def respond_to?(*arg, **arg1, &arg2); end
end

class ActiveSupport::Deprecation::DeprecatedConstantProxy
  def self.new(*args, **options, &block); end
end

class ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy
  def initialize(instance, method, var=T.unsafe(nil), deprecator=T.unsafe(nil)); end
end

class ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy
end

class ActiveSupport::Deprecation::DeprecatedObjectProxy
  def initialize(object, message, deprecator=T.unsafe(nil)); end
end

class ActiveSupport::Deprecation::DeprecatedObjectProxy
end

class ActiveSupport::Deprecation::DeprecationProxy
end

class ActiveSupport::Deprecation::DeprecationProxy
  def self.new(*args, &block); end
end

module ActiveSupport::Deprecation::Disallowed
  def disallowed_warnings(); end

  def disallowed_warnings=(disallowed_warnings); end
end

module ActiveSupport::Deprecation::Disallowed
end

module ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
  def include(included_module); end

  def method_added(method_name); end
end

module ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
end

module ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
  def deprecation_warning(deprecated_method_name, message=T.unsafe(nil), caller_backtrace=T.unsafe(nil)); end

  def warn(message=T.unsafe(nil), callstack=T.unsafe(nil)); end
end

module ActiveSupport::Deprecation::InstanceDelegator
  def self.included(base); end
end

module ActiveSupport::Deprecation::MethodWrapper
  def deprecate_methods(target_module, *method_names); end
end

module ActiveSupport::Deprecation::MethodWrapper
end

module ActiveSupport::Deprecation::Reporting
  def allow(allowed_warnings=T.unsafe(nil), if: T.unsafe(nil), &block); end

  def deprecation_warning(deprecated_method_name, message=T.unsafe(nil), caller_backtrace=T.unsafe(nil)); end

  def gem_name(); end

  def gem_name=(gem_name); end

  def silence(&block); end

  def silenced(); end

  def silenced=(silenced); end

  def warn(message=T.unsafe(nil), callstack=T.unsafe(nil)); end
end

class ActiveSupport::Deprecation
  extend ::Singleton::SingletonClassMethods
  extend ::ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
  extend ::ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
  def self.allow(*arg, **arg1, &arg2); end

  def self.behavior(*arg, **arg1, &arg2); end

  def self.behavior=(arg); end

  def self.debug(*arg, **arg1, &arg2); end

  def self.debug=(arg); end

  def self.deprecate_methods(*arg, **arg1, &arg2); end

  def self.deprecation_horizon(*arg, **arg1, &arg2); end

  def self.deprecation_horizon=(arg); end

  def self.deprecation_warning(*arg, **arg1, &arg2); end

  def self.disallowed_behavior(*arg, **arg1, &arg2); end

  def self.disallowed_behavior=(arg); end

  def self.disallowed_warnings(*arg, **arg1, &arg2); end

  def self.disallowed_warnings=(arg); end

  def self.gem_name(*arg, **arg1, &arg2); end

  def self.gem_name=(arg); end

  def self.initialize(*arg, **arg1, &arg2); end

  def self.silence(*arg, **arg1, &arg2); end

  def self.silenced(*arg, **arg1, &arg2); end

  def self.silenced=(arg); end

  def self.warn(*arg, **arg1, &arg2); end
end

class ActiveSupport::Digest
end

class ActiveSupport::Digest
  def self.hash_digest_class(); end

  def self.hash_digest_class=(klass); end

  def self.hexdigest(arg); end
end

class ActiveSupport::Duration
  PARTS = ::T.let(nil, ::T.untyped)
  PARTS_IN_SECONDS = ::T.let(nil, ::T.untyped)
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
  SECONDS_PER_HOUR = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MINUTE = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MONTH = ::T.let(nil, ::T.untyped)
  SECONDS_PER_WEEK = ::T.let(nil, ::T.untyped)
  SECONDS_PER_YEAR = ::T.let(nil, ::T.untyped)
  VARIABLE_PARTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser
  def initialize(string); end

  def mode(); end

  def mode=(mode); end

  def parse!(); end

  def parts(); end

  def scanner(); end

  def sign(); end

  def sign=(sign); end
  COMMA = ::T.let(nil, ::T.untyped)
  DATE_COMPONENT = ::T.let(nil, ::T.untyped)
  DATE_COMPONENTS = ::T.let(nil, ::T.untyped)
  DATE_MARKER = ::T.let(nil, ::T.untyped)
  DATE_TO_PART = ::T.let(nil, ::T.untyped)
  PERIOD = ::T.let(nil, ::T.untyped)
  PERIOD_OR_COMMA = ::T.let(nil, ::T.untyped)
  SIGN_MARKER = ::T.let(nil, ::T.untyped)
  TIME_COMPONENT = ::T.let(nil, ::T.untyped)
  TIME_COMPONENTS = ::T.let(nil, ::T.untyped)
  TIME_MARKER = ::T.let(nil, ::T.untyped)
  TIME_TO_PART = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser::ParsingError
end

class ActiveSupport::Duration::ISO8601Parser::ParsingError
end

class ActiveSupport::Duration::ISO8601Parser
end

class ActiveSupport::Duration::ISO8601Serializer
  def initialize(duration, precision: T.unsafe(nil)); end

  def serialize(); end
  DATE_COMPONENTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Serializer
end

class ActiveSupport::EnumerableCoreExt::SoleItemExpectedError
end

class ActiveSupport::EnumerableCoreExt::SoleItemExpectedError
end

class ActiveSupport::EnvironmentInquirer
  def development?(); end

  def initialize(env); end

  def production?(); end

  def test?(); end
  DEFAULT_ENVIRONMENTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::EnvironmentInquirer
end

class ActiveSupport::ErrorReporter
  SEVERITIES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::ExecutionContext
end

module ActiveSupport::ExecutionContext
  def self.[]=(key, value); end

  def self.after_change(&block); end

  def self.clear(); end

  def self.set(**options); end

  def self.to_h(); end
end

class ActiveSupport::ExecutionWrapper
  Null = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Gzip
end

class ActiveSupport::Gzip::Stream
  def initialize(*arg); end
end

class ActiveSupport::Gzip::Stream
end

module ActiveSupport::Gzip
  def self.compress(source, level=T.unsafe(nil), strategy=T.unsafe(nil)); end

  def self.decompress(source); end
end

module ActiveSupport::Inflector
  ALLOWED_ENCODINGS_FOR_TRANSLITERATE = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::JSON::Encoding
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
  def encode(value); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
end

module ActiveSupport::JSON::Encoding
  def self.escape_html_entities_in_json(); end

  def self.escape_html_entities_in_json=(escape_html_entities_in_json); end

  def self.json_encoder(); end

  def self.json_encoder=(json_encoder); end

  def self.time_precision(); end

  def self.time_precision=(time_precision); end

  def self.use_standard_json_time_format(); end

  def self.use_standard_json_time_format=(use_standard_json_time_format); end
end

module ActiveSupport::JSON
  def self.decode(json); end

  def self.encode(value, options=T.unsafe(nil)); end

  def self.parse_error(); end
end

class ActiveSupport::KeyGenerator
  def generate_key(salt, key_size=T.unsafe(nil)); end

  def initialize(secret, options=T.unsafe(nil)); end
end

class ActiveSupport::KeyGenerator
  def self.hash_digest_class(); end

  def self.hash_digest_class=(klass); end
end

class ActiveSupport::LogSubscriber
  def colorize_logging(); end

  def colorize_logging=(val); end

  def debug(progname=T.unsafe(nil), &block); end

  def error(progname=T.unsafe(nil), &block); end

  def fatal(progname=T.unsafe(nil), &block); end

  def info(progname=T.unsafe(nil), &block); end

  def logger(); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end
end

class ActiveSupport::MessageEncryptor
  include ::ActiveSupport::Messages::Rotator::Encryptor
  include ::ActiveSupport::Messages::Rotator
  def encrypt_and_sign(value, expires_at: T.unsafe(nil), expires_in: T.unsafe(nil), purpose: T.unsafe(nil)); end
end

class ActiveSupport::MessageEncryptor::InvalidMessage
end

class ActiveSupport::MessageEncryptor::InvalidMessage
end

module ActiveSupport::MessageEncryptor::NullSerializer
end

module ActiveSupport::MessageEncryptor::NullSerializer
  def self.dump(value); end

  def self.load(value); end
end

module ActiveSupport::MessageEncryptor::NullVerifier
end

module ActiveSupport::MessageEncryptor::NullVerifier
  def self.generate(value); end

  def self.verify(value); end
end

ActiveSupport::MessageEncryptor::OpenSSLCipherError = OpenSSL::Cipher::CipherError

class ActiveSupport::MessageEncryptor
  def self.default_cipher(); end

  def self.key_len(cipher=T.unsafe(nil)); end

  def self.use_authenticated_message_encryption(); end

  def self.use_authenticated_message_encryption=(val); end
end

class ActiveSupport::MessageVerifier
  include ::ActiveSupport::Messages::Rotator::Verifier
  include ::ActiveSupport::Messages::Rotator
  def generate(value, expires_at: T.unsafe(nil), expires_in: T.unsafe(nil), purpose: T.unsafe(nil)); end

  def valid_message?(signed_message); end

  def verify(*args, **options); end
  SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_LENGTH = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::MessageVerifier::InvalidSignature
end

class ActiveSupport::MessageVerifier::InvalidSignature
end

class ActiveSupport::MessageVerifier
end

module ActiveSupport::Messages::Rotator
  def initialize(*secrets, on_rotation: T.unsafe(nil), **options); end

  def rotate(*secrets, **options); end
end

module ActiveSupport::Messages::Rotator::Encryptor
  include ::ActiveSupport::Messages::Rotator
  def decrypt_and_verify(*args, on_rotation: T.unsafe(nil), **options); end
end

module ActiveSupport::Messages::Rotator::Encryptor
end

module ActiveSupport::Messages::Rotator::Verifier
  include ::ActiveSupport::Messages::Rotator
  def verified(*args, on_rotation: T.unsafe(nil), **options); end
end

module ActiveSupport::Messages::Rotator::Verifier
end

module ActiveSupport::Messages::Rotator
end

class ActiveSupport::Multibyte::Chars
  include ::Comparable
  def =~(*arg, **arg1, &arg2); end

  def acts_like_string?(*arg, **arg1, &arg2); end

  def compose(); end

  def decompose(); end

  def grapheme_length(); end

  def initialize(string); end

  def limit(limit); end

  def match?(*arg, **arg1, &arg2); end

  def method_missing(method, *args, &block); end

  def reverse(); end

  def reverse!(*args); end

  def slice!(*args); end

  def split(*args); end

  def tidy_bytes(force=T.unsafe(nil)); end

  def tidy_bytes!(*args); end

  def titlecase(); end

  def titleize(); end

  def to_str(); end

  def wrapped_string(); end
end

class ActiveSupport::Multibyte::Chars
end

module ActiveSupport::Multibyte::Unicode
  def compose(codepoints); end

  def decompose(type, codepoints); end

  def tidy_bytes(string, force=T.unsafe(nil)); end
end

module ActiveSupport::Multibyte::Unicode
  extend ::ActiveSupport::Multibyte::Unicode
end

class ActiveSupport::NumberHelper::NumberConverter
  def execute(); end

  def initialize(number, options); end

  def namespace(); end

  def namespace=(namespace); end

  def namespace?(); end

  def number(); end

  def opts(); end

  def validate_float(); end

  def validate_float=(validate_float); end

  def validate_float?(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberConverter
  def self.convert(number, options); end

  def self.namespace(); end

  def self.namespace=(value); end

  def self.namespace?(); end

  def self.validate_float(); end

  def self.validate_float=(value); end

  def self.validate_float?(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
  def convert(); end
  DEFAULT_DELIMITER_REGEX = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
  def convert(); end
  DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
  INVERTED_DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
  def convert(); end
  STORAGE_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
end

class ActiveSupport::NumberHelper::RoundingHelper
  def digit_count(number); end

  def initialize(options); end

  def options(); end

  def round(number); end
end

class ActiveSupport::NumberHelper::RoundingHelper
end

module ActiveSupport::NumberHelper
  extend ::ActiveSupport::Autoload
end

class ActiveSupport::OptionMerger
  def initialize(context, options); end
end

class ActiveSupport::OptionMerger
end

class ActiveSupport::OrderedHash
  def encode_with(coder); end

  def nested_under_indifferent_access(); end

  def reject(*args, &block); end

  def select(*args, &block); end

  def to_yaml_type(); end
end

class ActiveSupport::OrderedOptions
  def [](key); end

  def []=(key, value); end

  def _get(arg); end

  def method_missing(name, *args); end
end

module ActiveSupport::PerThreadRegistry
  def instance(); end
end

module ActiveSupport::PerThreadRegistry
  def self.extended(object); end
end

module ActiveSupport::Rescuable
  def handler_for_rescue(exception); end

  def rescue_with_handler(exception); end
end

module ActiveSupport::Rescuable::ClassMethods
  def handler_for_rescue(exception, object: T.unsafe(nil)); end

  def rescue_with_handler(exception, object: T.unsafe(nil), visited_exceptions: T.unsafe(nil)); end
end

module ActiveSupport::Rescuable
  extend ::ActiveSupport::Concern
end

module ActiveSupport::RubyFeatures
  CLASS_SUBCLASSES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::SafeBuffer
  def %(args); end

  def *(*arg); end

  def +(other); end

  def <<(value); end

  def [](*args); end

  def []=(*args); end

  def bytesplice(*args, value); end

  def capitalize(*args, &block); end

  def capitalize!(*args); end

  def chomp(*args, &block); end

  def chomp!(*args); end

  def chop(*args, &block); end

  def chop!(*args); end

  def clone_empty(); end

  def concat(value); end

  def delete(*args, &block); end

  def delete!(*args); end

  def delete_prefix(*args, &block); end

  def delete_prefix!(*args); end

  def delete_suffix(*args, &block); end

  def delete_suffix!(*args); end

  def downcase(*args, &block); end

  def downcase!(*args); end

  def encode_with(coder); end

  def gsub(*args, &block); end

  def gsub!(*args, &block); end

  def initialize(str=T.unsafe(nil)); end

  def insert(index, value); end

  def lstrip(*args, &block); end

  def lstrip!(*args); end

  def next(*args, &block); end

  def next!(*args); end

  def prepend(value); end

  def replace(value); end

  def reverse(*args, &block); end

  def reverse!(*args); end

  def rstrip(*args, &block); end

  def rstrip!(*args); end

  def safe_concat(value); end

  def scrub(*args, &block); end

  def scrub!(*args); end

  def slice(*args, &block); end

  def slice!(*args); end

  def squeeze(*args, &block); end

  def squeeze!(*args); end

  def strip(*args, &block); end

  def strip!(*args); end

  def sub(*args, &block); end

  def sub!(*args, &block); end

  def succ(*args, &block); end

  def succ!(*args); end

  def swapcase(*args, &block); end

  def swapcase!(*args); end

  def tr(*args, &block); end

  def tr!(*args); end

  def tr_s(*args, &block); end

  def tr_s!(*args); end

  def unicode_normalize(*args, &block); end

  def unicode_normalize!(*args); end

  def upcase(*args, &block); end

  def upcase!(*args); end
end

class ActiveSupport::SafeBuffer::SafeConcatError
  def initialize(); end
end

class ActiveSupport::SafeBuffer::SafeConcatError
end

class ActiveSupport::SecureCompareRotator
  include ::ActiveSupport::SecurityUtils
  include ::ActiveSupport::Messages::Rotator
  def secure_compare!(other_value, on_rotation: T.unsafe(nil)); end
end

class ActiveSupport::SecureCompareRotator::InvalidMatch
end

class ActiveSupport::SecureCompareRotator::InvalidMatch
end

class ActiveSupport::SecureCompareRotator
end

module ActiveSupport::SecurityUtils
end

module ActiveSupport::SecurityUtils
  def self.fixed_length_secure_compare(a, b); end

  def self.secure_compare(a, b); end
end

class ActiveSupport::StringInquirer
end

class ActiveSupport::StringInquirer
end

class ActiveSupport::Subscriber
  def finish(name, id, payload); end

  def patterns(); end

  def publish_event(event); end

  def start(name, id, payload); end
end

class ActiveSupport::TestCase
  include ::ActiveSupport::Testing::TaggedLogging
  include ::ActiveSupport::Callbacks
  include ::ActiveSupport::Testing::Assertions
  include ::ActiveSupport::Testing::Deprecation
  include ::ActiveSupport::Testing::TimeHelpers
  include ::ActiveSupport::Testing::FileFixtures
  include ::ActiveSupport::Testing::SetupAndTeardown
  def __callbacks(); end

  def __callbacks?(); end

  def _run_setup_callbacks(&block); end

  def _run_teardown_callbacks(&block); end

  def _setup_callbacks(); end

  def _teardown_callbacks(); end

  def assert_no_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_not_empty(obj, msg=T.unsafe(nil)); end

  def assert_not_equal(exp, act, msg=T.unsafe(nil)); end

  def assert_not_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_includes(collection, obj, msg=T.unsafe(nil)); end

  def assert_not_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_nil(obj, msg=T.unsafe(nil)); end

  def assert_not_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_not_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def assert_not_same(exp, act, msg=T.unsafe(nil)); end

  def assert_raise(*exp); end

  def file_fixture_path(); end

  def file_fixture_path?(); end

  def method_name(); end
end

ActiveSupport::TestCase::Assertion = Minitest::Assertion

class ActiveSupport::TestCase
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(value); end

  def self.__callbacks?(); end

  def self._setup_callbacks(); end

  def self._setup_callbacks=(value); end

  def self._teardown_callbacks(); end

  def self._teardown_callbacks=(value); end

  def self.file_fixture_path(); end

  def self.file_fixture_path=(value); end

  def self.file_fixture_path?(); end

  def self.parallelize(workers: T.unsafe(nil), with: T.unsafe(nil), threshold: T.unsafe(nil)); end

  def self.parallelize_setup(&block); end

  def self.parallelize_teardown(&block); end

  def self.test_order=(new_order); end
end

module ActiveSupport::Testing::Assertions
  def assert_changes(expression, message=T.unsafe(nil), from: T.unsafe(nil), to: T.unsafe(nil), &block); end

  def assert_difference(expression, *args, &block); end

  def assert_no_changes(expression, message=T.unsafe(nil), from: T.unsafe(nil), &block); end

  def assert_no_difference(expression, message=T.unsafe(nil), &block); end

  def assert_not(object, message=T.unsafe(nil)); end

  def assert_nothing_raised(); end
  UNTRACKED = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::Assertions
end

module ActiveSupport::Testing::Deprecation
  def assert_deprecated(match=T.unsafe(nil), deprecator=T.unsafe(nil), &block); end

  def assert_not_deprecated(deprecator=T.unsafe(nil), &block); end

  def collect_deprecations(deprecator=T.unsafe(nil)); end
end

module ActiveSupport::Testing::Deprecation
end

module ActiveSupport::Testing::FileFixtures
  def file_fixture(fixture_name); end
end

module ActiveSupport::Testing::FileFixtures
  extend ::ActiveSupport::Concern
end

module ActiveSupport::Testing::SetupAndTeardown
  def after_teardown(); end

  def before_setup(); end
end

module ActiveSupport::Testing::SetupAndTeardown
  def self.prepended(klass); end
end

module ActiveSupport::Testing::TaggedLogging
  def before_setup(); end

  def tagged_logger=(tagged_logger); end
end

module ActiveSupport::Testing::TaggedLogging
end

module ActiveSupport::Testing::TimeHelpers
  def after_teardown(); end

  def freeze_time(&block); end

  def travel(duration, &block); end

  def travel_back(); end

  def travel_to(date_or_time); end

  def unfreeze_time(); end
end

module ActiveSupport::Testing::TimeHelpers
end

class ActiveSupport::TimeWithZone
  include ::DateAndTime::Compatibility
  NOT_SET = ::T.let(nil, ::T.untyped)
  PRECISIONS = ::T.let(nil, ::T.untyped)
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TimeZone
  MAPPING = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::ToJsonWithActiveSupportEncoder
  def to_json(options=T.unsafe(nil)); end
end

module ActiveSupport::ToJsonWithActiveSupportEncoder
end

module ActiveSupport::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini
  def backend(); end

  def backend=(name); end

  def depth(); end

  def depth=(depth); end

  def parse(*arg, **arg1, &arg2); end

  def rename_key(key, options=T.unsafe(nil)); end

  def to_tag(key, value, options); end

  def with_backend(name); end
  DEFAULT_ENCODINGS = ::T.let(nil, ::T.untyped)
  FORMATTING = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini::FileLike
  def content_type(); end

  def content_type=(content_type); end

  def original_filename(); end

  def original_filename=(original_filename); end
end

module ActiveSupport::XmlMini::FileLike
end

module ActiveSupport::XmlMini
  extend ::ActiveSupport::XmlMini
end

module ActiveSupport
  def self.escape_html_entities_in_json(*arg, **arg1, &arg2); end

  def self.escape_html_entities_in_json=(arg); end

  def self.json_encoder(*arg, **arg1, &arg2); end

  def self.json_encoder=(arg); end

  def self.parse_json_times(); end

  def self.parse_json_times=(val); end

  def self.time_precision(*arg, **arg1, &arg2); end

  def self.time_precision=(arg); end

  def self.use_standard_json_time_format(*arg, **arg1, &arg2); end

  def self.use_standard_json_time_format=(arg); end
end

module Addressable::IDNA
  ACE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  ACE_PREFIX = ::T.let(nil, ::T.untyped)
  COMPOSITION_TABLE = ::T.let(nil, ::T.untyped)
  PUNYCODE_BASE = ::T.let(nil, ::T.untyped)
  PUNYCODE_DAMP = ::T.let(nil, ::T.untyped)
  PUNYCODE_DELIMITER = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_BIAS = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_N = ::T.let(nil, ::T.untyped)
  PUNYCODE_MAXINT = ::T.let(nil, ::T.untyped)
  PUNYCODE_PRINT_ASCII = ::T.let(nil, ::T.untyped)
  PUNYCODE_SKEW = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMAX = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMIN = ::T.let(nil, ::T.untyped)
  UNICODE_DATA = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_CANONICAL = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMBINING_CLASS = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMPATIBILITY = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_EXCLUSION = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_LOWERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_TITLECASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_UPPERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  UNICODE_TABLE = ::T.let(nil, ::T.untyped)
  UTF8_REGEX = ::T.let(nil, ::T.untyped)
  UTF8_REGEX_MULTIBYTE = ::T.let(nil, ::T.untyped)
end

class Addressable::Template
  EXPRESSION = ::T.let(nil, ::T.untyped)
  JOINERS = ::T.let(nil, ::T.untyped)
  LEADERS = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  VARIABLE_LIST = ::T.let(nil, ::T.untyped)
  VARNAME = ::T.let(nil, ::T.untyped)
  VARSPEC = ::T.let(nil, ::T.untyped)
end

class Addressable::URI
  EMPTY_STR = ::T.let(nil, ::T.untyped)
  NORMPATH = ::T.let(nil, ::T.untyped)
  PARENT = ::T.let(nil, ::T.untyped)
  PORT_MAPPING = ::T.let(nil, ::T.untyped)
  RULE_2A = ::T.let(nil, ::T.untyped)
  RULE_2B_2C = ::T.let(nil, ::T.untyped)
  RULE_2D = ::T.let(nil, ::T.untyped)
  RULE_PREFIXED_PARENT = ::T.let(nil, ::T.untyped)
  SELF_REF = ::T.let(nil, ::T.untyped)
  SEQUENCE_ENCODING_TABLE = ::T.let(nil, ::T.untyped)
  SEQUENCE_UPCASED_PERCENT_ENCODING_TABLE = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
  URIREGEX = ::T.let(nil, ::T.untyped)
end

module Addressable::URI::CharacterClasses
  ALPHA = ::T.let(nil, ::T.untyped)
  AUTHORITY = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  GEN_DELIMS = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  PCHAR = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
end

module Addressable::URI::NormalizeCharacterClasses
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  PCHAR = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
end

module Addressable::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class ArgumentError
  include ::ErrorHighlight::CoreExt
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def deconstruct(); end

  def shelljoin(); end

  def to_csv(**options); end

  def to_h(); end
end

class Array
  def self.new(*arg); end

  def self.try_convert(arg); end
end

BasicObject::BasicObject = BasicObject

class Benchmark::Job
  def initialize(width); end
end

class Benchmark::Report
  def initialize(width=T.unsafe(nil), format=T.unsafe(nil)); end
end

class Benchmark::Tms
  def to_a(); end

  def to_h(); end
end

class BigDecimal
  include ::ActiveSupport::BigDecimalWithDefaultFormat
  def clone(); end

  def n_significant_digits(); end

  def precision(); end

  def precision_scale(); end

  def scale(); end

  def to_digits(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.interpret_loosely(arg); end
end

class Binding
  def clone(); end

  def irb(show_code: T.unsafe(nil)); end
end

module Bundler
  SAFE_MARSHAL_CLASSES = ::T.let(nil, ::T.untyped)
  SAFE_MARSHAL_ERROR = ::T.let(nil, ::T.untyped)
  SAFE_MARSHAL_PROC = ::T.let(nil, ::T.untyped)
end

class Bundler::APIResponseInvalidDependenciesError
  def status_code(); end
end

class Bundler::APIResponseInvalidDependenciesError
end

class Bundler::CurrentRuby
  def jruby_30?(); end

  def jruby_31?(); end

  def jruby_32?(); end

  def jruby_33?(); end

  def jruby_3?(); end

  def maglev_30?(); end

  def maglev_31?(); end

  def maglev_32?(); end

  def maglev_33?(); end

  def maglev_3?(); end

  def mingw_30?(); end

  def mingw_31?(); end

  def mingw_32?(); end

  def mingw_33?(); end

  def mingw_3?(); end

  def mri_30?(); end

  def mri_31?(); end

  def mri_32?(); end

  def mri_33?(); end

  def mri_3?(); end

  def mswin64_30?(); end

  def mswin64_31?(); end

  def mswin64_32?(); end

  def mswin64_33?(); end

  def mswin64_3?(); end

  def mswin_30?(); end

  def mswin_31?(); end

  def mswin_32?(); end

  def mswin_33?(); end

  def mswin_3?(); end

  def on_30?(); end

  def on_31?(); end

  def on_32?(); end

  def on_33?(); end

  def on_3?(); end

  def rbx_30?(); end

  def rbx_31?(); end

  def rbx_32?(); end

  def rbx_33?(); end

  def rbx_3?(); end

  def ruby_30?(); end

  def ruby_31?(); end

  def ruby_32?(); end

  def ruby_33?(); end

  def ruby_3?(); end

  def truffleruby_30?(); end

  def truffleruby_31?(); end

  def truffleruby_32?(); end

  def truffleruby_33?(); end

  def truffleruby_3?(); end

  def windows?(); end

  def windows_18?(); end

  def windows_19?(); end

  def windows_1?(); end

  def windows_20?(); end

  def windows_21?(); end

  def windows_22?(); end

  def windows_23?(); end

  def windows_24?(); end

  def windows_25?(); end

  def windows_26?(); end

  def windows_27?(); end

  def windows_2?(); end

  def windows_30?(); end

  def windows_31?(); end

  def windows_32?(); end

  def windows_33?(); end

  def windows_3?(); end

  def x64_mingw_30?(); end

  def x64_mingw_31?(); end

  def x64_mingw_32?(); end

  def x64_mingw_33?(); end

  def x64_mingw_3?(); end
end

class Bundler::Definition
  def deleted_deps(); end

  def dependencies_for(groups); end

  def locked_dependencies(); end

  def most_specific_locked_platform(); end

  def new_deps(); end

  def requested_dependencies(); end

  def resolution_mode=(options); end

  def resolve_only_locally!(); end

  def setup_sources_for_resolve(); end
end

class Bundler::Definition
  def self.no_lock(); end

  def self.no_lock=(no_lock); end
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def git(); end

  def github(); end

  def path(); end

  def ref(); end
  ALL_RUBY_VERSIONS = ::T.let(nil, ::T.untyped)
end

Bundler::Deprecate = Gem::Deprecate

module Bundler::Digest
  SHA1_MASK = ::T.let(nil, ::T.untyped)
  SHA1_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Digest
  def self.sha1(string); end
end

class Bundler::DirectoryRemovalError
  def initialize(orig_exception, msg); end

  def status_code(); end
end

class Bundler::DirectoryRemovalError
end

class Bundler::Dsl
  def check_primary_source_safety(); end
  GITHUB_PULL_REQUEST_URL = ::T.let(nil, ::T.untyped)
end

class Bundler::EndpointSpecification
  include ::Bundler::MatchRemoteMetadata
  include ::Bundler::FetchMetadata
end

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::EnvironmentPreserver
  def replace_with_backup(); end
end

class Bundler::EnvironmentPreserver
  def self.env_to_hash(env); end

  def self.from_env(); end
end

module Bundler::FetchMetadata
  def matches_current_ruby?(); end

  def matches_current_rubygems?(); end
end

module Bundler::FetchMetadata
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end

  def self.ln_sr(src, dest, target_directory: T.unsafe(nil), force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
end

module Bundler::ForcePlatform
end

module Bundler::ForcePlatform
end

class Bundler::GemHelper
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_checksum(built_gem_path=T.unsafe(nil)); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def current_branch(); end

  def default_remote(); end

  def gem_command(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_input(cmd); end

  def sh_with_status(cmd, &block); end

  def spec_path(); end

  def tag_prefix=(tag_prefix); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end

  def self.tag_prefix=(prefix); end
end

class Bundler::GemHelpers::PlatformMatch
  def self.specificity_score(spec_platform, user_platform); end
end

module Bundler::GemHelpers
  def self.local_platform(); end

  def self.same_deps(spec, exemplary_spec); end

  def self.same_specificity(platform, spec, exemplary_spec); end

  def self.sort_best_platform_match(matching, platform); end
end

class Bundler::GemVersionPromoter
  def level(); end

  def level=(value); end

  def major?(); end

  def minor?(); end

  def pre(); end

  def pre=(pre); end

  def pre?(); end

  def sort_versions(package, specs); end

  def strict(); end

  def strict=(strict); end
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def definition(); end
end

class Bundler::LazySpecification
  include ::Bundler::ForcePlatform
  def eql?(other); end

  def force_ruby_platform(); end

  def force_ruby_platform=(force_ruby_platform); end

  def materialize_for_installation(); end
end

class Bundler::LockfileParser
  def may_include_redundant_platform_specific_gems?(); end
end

class Bundler::LockfileParser
  def self.bundled_with(); end
end

module Bundler::MatchMetadata
  def matches_current_ruby?(); end

  def matches_current_rubygems?(); end
end

module Bundler::MatchMetadata
end

module Bundler::MatchRemoteMetadata
  include ::Bundler::MatchMetadata
  include ::Bundler::FetchMetadata
end

module Bundler::MatchRemoteMetadata
end

class Bundler::PermissionError
  def parent_folder(); end

  def permission_type(); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def add_dependency_names(names); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*arg); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def identifier(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def local!(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def spec_names(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_plugins(); end

  def plugin_commands(plugin); end

  def unregister_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.list(); end

  def self.save_plugin(name, spec, optional_plugin=T.unsafe(nil)); end

  def self.uninstall(names, options); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::PubGrub::Incompatibility
  def cause(); end

  def conflict?(); end

  def eql?(other); end

  def external_incompatibilities(); end

  def failure?(); end

  def initialize(terms, cause:, custom_explanation: T.unsafe(nil)); end

  def terms(); end
end

class Bundler::PubGrub::Incompatibility
end

class Bundler::RemoteSpecification
  include ::Bundler::MatchRemoteMetadata
  include ::Bundler::MatchMetadata
  include ::Bundler::FetchMetadata
end

class Bundler::Resolver
  include ::Bundler::GemHelpers
  def all_versions_for(package); end

  def find_names_to_relax(incompatibility); end

  def incompatibilities_for(package, version); end

  def no_versions_incompatibility_for(package, unsatisfied_term); end

  def parse_dependency(package, dependency); end

  def raise_not_found!(package); end

  def setup_solver(); end

  def solve_versions(root:, logger:); end

  def source_for(name); end

  def versions_for(package, range=T.unsafe(nil)); end
end

class Bundler::Resolver::Base
  def [](name); end

  def base_requirements(); end

  def delete(specs); end

  def get_package(name); end

  def include_prereleases(names); end

  def initialize(source_requirements, dependencies, base, platforms, options); end

  def packages(); end

  def requirements(); end

  def source_requirements(); end

  def unlock_names(names); end
end

class Bundler::Resolver::Base
end

class Bundler::Resolver::Candidate
  include ::Comparable
  def ==(other); end

  def dependencies(); end

  def eql?(other); end

  def generic!(); end

  def initialize(version, specs: T.unsafe(nil)); end

  def platform_specific!(); end

  def prerelease?(); end

  def segments(); end

  def sort_obj(); end

  def to_specs(package); end

  def version(); end
end

class Bundler::Resolver::Candidate
end

class Bundler::Resolver::Incompatibility
  def extended_explanation(); end

  def initialize(terms, cause:, custom_explanation: T.unsafe(nil), extended_explanation: T.unsafe(nil)); end
end

class Bundler::Resolver::Incompatibility
end

class Bundler::Resolver::Package
  def ==(other); end

  def consider_prereleases!(); end

  def current_platform?(); end

  def dependency(); end

  def force_ruby_platform?(); end

  def ignores_prereleases?(); end

  def initialize(name, platforms, locked_specs:, unlock:, prerelease: T.unsafe(nil), dependency: T.unsafe(nil)); end

  def locked_version(); end

  def meta?(); end

  def name(); end

  def platforms(); end

  def prerelease_specified?(); end

  def root?(); end

  def unlock?(); end
end

class Bundler::Resolver::Package
end

class Bundler::Resolver::Root
  def initialize(name); end
end

class Bundler::Resolver::Root
end

class Bundler::Resolver::SpecGroup
  def dependencies(); end

  def empty?(); end

  def sorted_spec_names(); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubygemsIntegration
  def add_default_gems_to(specs); end

  def add_to_load_path(paths); end

  def all_specs(); end

  def backport_ext_builder_monitor(); end

  def correct_for_windows_path(path); end

  def default_stubs(); end

  def find_bundler(version); end

  def find_name(name); end

  def gem_remote_fetcher(); end

  def load_env_plugins(); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def supports_bundler_trampolining?(); end
end

class Bundler::SelfManager
  def install_locked_bundler_and_restart_with_it_if_needed(); end

  def restart_with_locked_bundler_if_needed(); end

  def update_bundler_and_restart_with_it_if_needed(target); end
end

class Bundler::SelfManager
end

class Bundler::Settings
  def processor_count(); end
  STRING_KEYS = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Path
  def self.keyword_init?(); end
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Settings
  def self.key_for(key); end
end

class Bundler::SolveFailure
  def status_code(); end
end

class Bundler::SolveFailure
end

class Bundler::Source
  def add_dependency_names(names); end

  def cached!(); end

  def identifier(); end

  def local!(); end

  def local_only!(); end

  def remote!(); end

  def spec_names(); end
end

class Bundler::Source::Git
  def current_branch(); end

  def glob(); end

  def local?(); end
end

class Bundler::Source::Rubygems
  def default_cache_path_for(dir); end

  def dependency_api_available?(); end

  def fetch_gem_if_possible(spec, previous_spec=T.unsafe(nil)); end

  def multiple_remotes?(); end

  def no_remotes?(); end

  def package_path(cache_path, spec); end

  def remote_names(); end
end

class Bundler::Source::RubygemsAggregate
  def identifier(); end

  def initialize(sources, source_map); end

  def source_map(); end

  def sources(); end

  def specs(); end
end

class Bundler::Source::RubygemsAggregate
end

class Bundler::SourceList
  def add_global_rubygems_remote(uri); end

  def aggregate_global_source?(); end

  def expired_sources?(replacement_sources); end

  def get_with_fallback(source); end

  def global_path_source(); end

  def implicit_global_source?(); end

  def local_only!(); end

  def lock_other_sources(); end

  def lock_rubygems_sources(); end

  def merged_gem_lockfile_sections!(replacement_source); end

  def merged_gem_lockfile_sections?(); end

  def non_default_explicit_sources(); end

  def non_global_rubygems_sources(); end
end

class Bundler::SourceMap
  def all_requirements(); end

  def dependencies(); end

  def direct_requirements(); end

  def initialize(sources, dependencies, locked_specs); end

  def locked_requirements(); end

  def locked_specs(); end

  def pinned_spec_names(skip=T.unsafe(nil)); end

  def sources(); end
end

class Bundler::SourceMap
end

class Bundler::SpecSet
  include ::Enumerable
  include ::Bundler::TSort
  def -(other); end

  def delete(spec); end

  def delete_by_name(name); end

  def incomplete_ruby_specs?(deps); end

  def incomplete_specs(); end

  def missing_specs(); end
end

class Bundler::StubSpecification
  def extensions(); end

  def full_gem_path=(path); end

  def gem_build_complete_path(); end

  def manually_installed?(); end
end

module Bundler::TSort
  def each_strongly_connected_component(&block); end

  def each_strongly_connected_component_from(node, id_map=T.unsafe(nil), stack=T.unsafe(nil), &block); end

  def strongly_connected_components(); end

  def tsort(); end

  def tsort_each(&block); end

  def tsort_each_child(node); end

  def tsort_each_node(); end
end

class Bundler::TSort::Cyclic
end

class Bundler::TSort::Cyclic
end

module Bundler::TSort
  def self.each_strongly_connected_component(each_node, each_child); end

  def self.each_strongly_connected_component_from(node, each_child, id_map=T.unsafe(nil), stack=T.unsafe(nil)); end

  def self.strongly_connected_components(each_node, each_child); end

  def self.tsort(each_node, each_child); end

  def self.tsort_each(each_node, each_child); end
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  Correctable = ::T.let(nil, ::T.untyped)
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base::ClassMethods
  def all_commands(); end

  def all_tasks(); end

  def allow_incompatible_default_type!(); end

  def argument(name, options=T.unsafe(nil)); end

  def arguments(); end

  def attr_accessor(*arg); end

  def attr_reader(*arg); end

  def attr_writer(*arg); end

  def baseclass(); end

  def basename(); end

  def build_option(name, options, scope); end

  def build_options(options, scope); end

  def check_default_type(); end

  def check_default_type!(); end

  def check_unknown_options(); end

  def check_unknown_options!(); end

  def check_unknown_options?(config); end

  def class_option(name, options=T.unsafe(nil)); end

  def class_options(options=T.unsafe(nil)); end

  def class_options_help(shell, groups=T.unsafe(nil)); end

  def commands(); end

  def create_command(meth); end

  def create_task(meth); end

  def disable_required_check?(command_name); end

  def dispatch(command, given_args, given_opts, config); end

  def exit_on_failure?(); end

  def find_and_refresh_command(name); end

  def find_and_refresh_task(name); end

  def from_superclass(method, default=T.unsafe(nil)); end

  def group(name=T.unsafe(nil)); end

  def handle_argument_error(command, error, args, arity); end

  def handle_no_command_error(command, has_namespace=T.unsafe(nil)); end

  def handle_no_task_error(command, has_namespace=T.unsafe(nil)); end

  def inherited(klass); end

  def initialize_added(); end

  def is_thor_reserved_word?(word, type); end

  def method_added(meth); end

  def namespace(name=T.unsafe(nil)); end

  def no_commands(&block); end

  def no_commands?(); end

  def no_commands_context(); end

  def no_tasks(&block); end

  def print_options(shell, options, group_name=T.unsafe(nil)); end

  def public_command(*names); end

  def public_task(*names); end

  def remove_argument(*names); end

  def remove_class_option(*names); end

  def remove_command(*names); end

  def remove_task(*names); end

  def start(given_args=T.unsafe(nil), config=T.unsafe(nil)); end

  def stop_on_unknown_option?(command_name); end

  def strict_args_position(); end

  def strict_args_position!(); end

  def strict_args_position?(config); end

  def tasks(); end
end

module Bundler::Thor::Base::ClassMethods
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def except(*keys); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def reverse_merge!(other_hash); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*arg); end

  def self.printable_tasks(*arg); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation::ClassMethods
  def prepare_for_invocation(key, name); end
end

module Bundler::Thor::Invocation::ClassMethods
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end

  def unshift(arg, is_value: T.unsafe(nil)); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

module Bundler::Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Bundler::Thor::RakeCompat
  def self.included(base); end

  def self.rake_classes(); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_error(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
  def answer_match(possibilities, answer, case_insensitive); end

  def as_unicode(); end

  def ask(statement, *args); end

  def ask_filtered(statement, color, options); end

  def ask_simply(statement, color, options); end

  def base(); end

  def base=(base); end

  def can_display_colors?(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def error(statement); end

  def file_collision(destination); end

  def file_collision_help(); end

  def git_merge_tool(); end

  def indent(count=T.unsafe(nil)); end

  def is?(value); end

  def lookup_color(color); end

  def merge(destination, content); end

  def merge_tool(); end

  def mute(); end

  def mute?(); end

  def no?(statement, color=T.unsafe(nil)); end

  def padding(); end

  def padding=(value); end

  def prepare_message(message, *color); end

  def print_in_columns(array); end

  def print_table(array, options=T.unsafe(nil)); end

  def print_wrapped(message, options=T.unsafe(nil)); end

  def quiet?(); end

  def say(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_error(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_status(status, message, log_status=T.unsafe(nil)); end

  def set_color(string, *arg); end

  def show_diff(destination, content); end

  def stderr(); end

  def stdout(); end

  def terminal_width(); end

  def truncate(string, width); end

  def unix?(); end

  def yes?(statement, color=T.unsafe(nil)); end
  DEFAULT_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
end

class Bundler::Thor::Shell::Color
  def are_colors_disabled?(); end

  def are_colors_supported?(); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Color
end

class Bundler::Thor::Shell::HTML
  def ask(statement, color=T.unsafe(nil)); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::HTML
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg=T.unsafe(nil), newline=T.unsafe(nil)); end

  def confirm?(); end

  def debug(msg=T.unsafe(nil), newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg=T.unsafe(nil), newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def error?(); end

  def info(msg=T.unsafe(nil), newline=T.unsafe(nil)); end

  def info?(); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg=T.unsafe(nil), newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def warn?(); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

class Bundler::UI::Silent
  def confirm?(); end

  def error?(); end

  def info?(); end

  def warn?(); end
end

module Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ABS_URI_REF = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  REL_URI_REF = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCURICOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  UNSAFE = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::BadURIError
end

class Bundler::URI::BadURIError
end

class Bundler::URI::Error
end

class Bundler::URI::Error
end

class Bundler::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Bundler::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::File
end

class Bundler::URI::Generic
  include ::Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def decoded_password(); end

  def decoded_user(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Bundler::URI::HTTP
  def authority(); end

  def origin(); end

  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTP
end

class Bundler::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTPS
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAP
end

class Bundler::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAPS
end

class Bundler::URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::MailTo
end

Bundler::URI::Parser = Bundler::URI::RFC2396_Parser

Bundler::URI::REGEXP = Bundler::URI::RFC2396_REGEXP

class Bundler::URI::RFC2396_Parser
  include ::Bundler::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class Bundler::URI::RFC2396_Parser
end

module Bundler::URI::RFC2396_REGEXP
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
end

module Bundler::URI::RFC2396_REGEXP
end

class Bundler::URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::RFC3986_Parser
end

module Bundler::URI::Util
end

module Bundler::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

class Bundler::URI::WS
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::WS
end

class Bundler::URI::WSS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::WSS
end

module Bundler::URI
  def self.decode_uri_component(str, enc=T.unsafe(nil)); end

  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_uri_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.for(scheme, *arguments, default: T.unsafe(nil)); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.register_scheme(scheme, klass); end

  def self.scheme_list(); end

  def self.split(uri); end
end

module Bundler::URINormalizer
end

module Bundler::URINormalizer
  def self.normalize_suffix(uri, trailing_slash: T.unsafe(nil)); end
end

module Bundler
  def self.configure_gem_home_and_path(path=T.unsafe(nil)); end

  def self.create_bundle_path(); end

  def self.gem_version(); end

  def self.most_specific_locked_platform?(platform); end

  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.preferred_gemfile_name(); end

  def self.reset_settings_and_root!(); end

  def self.safe_load_marshal(data); end

  def self.self_manager(); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end
end

module Byebug
  PORT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoirbSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutolistSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoprySetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutosaveSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::CallstyleSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Command
  extend ::Byebug::Helpers::StringHelper
end

class Byebug::Context
  extend ::Byebug::Helpers::PathHelper
end

class Byebug::FullpathSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistfileSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistsizeSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::ListsizeSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::LocalInterface
  EOF_ALIAS = ::T.let(nil, ::T.untyped)
end

class Byebug::Printers::Base
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Byebug::SavefileSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Setting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::ThreadsTable
end

class Byebug::ThreadsTable
end

class Byebug::WidthSetting
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class CGI
  VERSION = ::T.let(nil, ::T.untyped)
end

class CGI::Cookie
  DOMAIN_VALUE_RE = ::T.let(nil, ::T.untyped)
  PATH_VALUE_RE = ::T.let(nil, ::T.untyped)
  TOKEN_RE = ::T.let(nil, ::T.untyped)
end

module CGI::Escape
  def escapeURIComponent(arg); end

  def unescapeURIComponent(*arg); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

module CGI::Util
  def escapeURIComponent(arg); end

  def unescapeURIComponent(*arg); end
end

class CSV
  def close(*args, **arg, &block); end

  def close_read(*args, **arg, &block); end

  def close_write(*args, **arg, &block); end

  def closed?(*args, **arg, &block); end

  def external_encoding(*args, **arg, &block); end

  def fcntl(*args, **arg, &block); end

  def fileno(*args, **arg, &block); end

  def flush(*args, **arg, &block); end

  def fsync(*args, **arg, &block); end

  def internal_encoding(*args, **arg, &block); end

  def isatty(*args, **arg, &block); end

  def max_field_size(); end

  def pid(*args, **arg, &block); end

  def pos(*args, **arg, &block); end

  def pos=(*args, **arg, &block); end

  def reopen(*args, **arg, &block); end

  def seek(*args, **arg, &block); end

  def string(*args, **arg, &block); end

  def sync(*args, **arg, &block); end

  def sync=(*args, **arg, &block); end

  def tell(*args, **arg, &block); end

  def truncate(*args, **arg, &block); end

  def tty?(*args, **arg, &block); end
  ConverterEncoding = ::T.let(nil, ::T.untyped)
  Converters = ::T.let(nil, ::T.untyped)
  DateMatcher = ::T.let(nil, ::T.untyped)
  DateTimeMatcher = ::T.let(nil, ::T.untyped)
  HeaderConverters = ::T.let(nil, ::T.untyped)
end

class CSV::FieldInfo
  def header(); end

  def header=(_); end

  def index(); end

  def index=(_); end

  def line(); end

  def line=(_); end

  def quoted?(); end
end

class CSV::FieldInfo
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class CSV::FieldsConverter
  include ::Enumerable
  def add_converter(name=T.unsafe(nil), &converter); end

  def convert(fields, headers, lineno, quoted_fields); end

  def each(&block); end

  def empty?(); end

  def initialize(options=T.unsafe(nil)); end
end

class CSV::FieldsConverter
end

module CSV::InputRecordSeparator
end

module CSV::InputRecordSeparator
  def self.value(); end
end

class CSV::MalformedCSVError
  def line_number(); end

  def lineno(); end
end

class CSV::Parser
  def column_separator(); end

  def field_size_limit(); end

  def header_row?(); end

  def headers(); end

  def initialize(input, options); end

  def liberal_parsing?(); end

  def line(); end

  def lineno(); end

  def max_field_size(); end

  def parse(&block); end

  def quote_character(); end

  def return_headers?(); end

  def row_separator(); end

  def skip_blanks?(); end

  def skip_lines(); end

  def unconverted_fields?(); end

  def use_headers?(); end
  SCANNER_TEST = ::T.let(nil, ::T.untyped)
  STRING_SCANNER_SCAN_ACCEPT_STRING = ::T.let(nil, ::T.untyped)
end

class CSV::Parser::InputsScanner
  def check(pattern); end

  def each_line(row_separator); end

  def eos?(); end

  def initialize(inputs, encoding, row_separator, chunk_size: T.unsafe(nil)); end

  def keep_back(); end

  def keep_drop(); end

  def keep_end(); end

  def keep_start(); end

  def rest(); end

  def scan(pattern); end

  def scan_all(pattern); end
end

class CSV::Parser::InputsScanner
end

class CSV::Parser::InvalidEncoding
end

class CSV::Parser::InvalidEncoding
end

class CSV::Parser::Scanner
  def each_line(row_separator); end

  def initialize(*args); end

  def keep_back(); end

  def keep_drop(); end

  def keep_end(); end

  def keep_start(); end

  def scan_all(arg); end
end

class CSV::Parser::Scanner
end

class CSV::Parser::UnexpectedError
end

class CSV::Parser::UnexpectedError
end

class CSV::Parser::UnoptimizedStringIO
  def each_line(*args, &block); end

  def eof?(); end

  def gets(*args); end

  def initialize(string); end
end

class CSV::Parser::UnoptimizedStringIO
end

class CSV::Parser
end

class CSV::Row
  def deconstruct(); end

  def deconstruct_keys(keys); end

  def dig(index_or_header, *indexes); end

  def each_pair(&block); end

  def empty?(*args, **arg, &block); end

  def length(*args, **arg, &block); end

  def size(*args, **arg, &block); end

  def to_ary(*arg); end
end

class CSV::Row
  extend ::Forwardable
end

class CSV::Table
  def initialize(array_of_rows, headers: T.unsafe(nil)); end

  def table(); end
end

class CSV::Table
  extend ::Forwardable
end

class CSV::Writer
  def <<(row); end

  def headers(); end

  def initialize(output, options); end

  def lineno(); end

  def rewind(); end
end

class CSV::Writer
end

class CSV
  extend ::Forwardable
  def self.generate_lines(rows, **options); end
end

class Class
  def json_creatable?(); end
end

class Complex
  def to_d(*args); end
end

module Concurrent
  NULL = ::T.let(nil, ::T.untyped)
  NULL_LOGGER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExecutorService
  FALLBACK_POLICIES = ::T.let(nil, ::T.untyped)
end

Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

class Concurrent::ConcurrentUpdateError
  CONC_UP_ERR_BACKTRACE = ::T.let(nil, ::T.untyped)
end

class Concurrent::FiberLocalVar
  LOCALS = ::T.let(nil, ::T.untyped)
end

class Concurrent::LockFreeStack
  EMPTY = ::T.let(nil, ::T.untyped)
end

Concurrent::LockLocalVar = Concurrent::FiberLocalVar

class Concurrent::MVar
  EMPTY = ::T.let(nil, ::T.untyped)
  TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::Maybe
  NONE = ::T.let(nil, ::T.untyped)
end

module Concurrent::Promises::InternalStates
  PENDING = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  RESOLVED = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReentrantReadWriteLock
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  READER_BITS = ::T.let(nil, ::T.untyped)
  READ_LOCK_MASK = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
  WRITER_BITS = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_HELD = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_MASK = ::T.let(nil, ::T.untyped)
end

class Concurrent::RubyThreadPoolExecutor
  DEFAULT_MAX_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_QUEUE_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MIN_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_SYNCHRONOUS = ::T.let(nil, ::T.untyped)
  DEFAULT_THREAD_IDLETIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::SerializedExecutionDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Concurrent::SynchronizedDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Concurrent::ThreadLocalVar
  LOCALS = ::T.let(nil, ::T.untyped)
end

module Concurrent::ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

class Concurrent::TimerTask
  EXECUTION_INTERVAL = ::T.let(nil, ::T.untyped)
  TIMEOUT_INTERVAL = ::T.let(nil, ::T.untyped)
end

class Concurrent::Transaction
  ABORTED = ::T.let(nil, ::T.untyped)
end

module Concurrent::Utility::NativeInteger
  MAX_VALUE = ::T.let(nil, ::T.untyped)
  MIN_VALUE = ::T.let(nil, ::T.untyped)
end

class Crack::JSON
  DATE_REGEX = ::T.let(nil, ::T.untyped)
end

class Date
  def deconstruct_keys(arg); end

  def default_inspect(); end

  def infinite?(); end

  def readable_inspect(); end

  def to_default_s(); end

  def to_fs(format=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class DateTime
  def self.new(*arg); end
end

class Delegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

module DidYouMean::Correctable
  def corrections(); end

  def detailed_message(highlight: T.unsafe(nil), did_you_mean: T.unsafe(nil), **arg); end

  def original_message(); end

  def spell_checker(); end
end

class DidYouMean::Formatter
  def message_for(corrections); end
end

class DidYouMean::Formatter
  def self.message_for(corrections); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def names_to_exclude(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*arg); end
end

class DidYouMean::PatternKeyNameChecker
  def corrections(); end

  def initialize(no_matching_pattern_key_error); end
end

class DidYouMean::PatternKeyNameChecker
end

DidYouMean::PlainFormatter = DidYouMean::Formatter

class DidYouMean::RequirePathChecker
  def corrections(); end

  def initialize(exception); end

  def path(); end
end

class DidYouMean::RequirePathChecker
  def self.requireables(); end
end

class DidYouMean::TreeSpellChecker
  def augment(); end

  def correct(input); end

  def dictionary(); end

  def dictionary_without_leaves(); end

  def dimensions(); end

  def find_leaves(path); end

  def initialize(dictionary:, separator: T.unsafe(nil), augment: T.unsafe(nil)); end

  def plausible_dimensions(input); end

  def possible_paths(states); end

  def separator(); end

  def tree_depth(); end
end

class DidYouMean::TreeSpellChecker
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.correct_error(error_class, spell_checker); end

  def self.formatter(); end

  def self.formatter=(formatter); end

  def self.spell_checkers(); end
end

module Digest
  VERSION = ::T.let(nil, ::T.untyped)
end

class Dir
  def children(); end

  def each_child(); end
end

module Dir::Tmpname
  UNUSABLE_CHARS = ::T.let(nil, ::T.untyped)
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

module ERB::Escape
end

module ERB::Escape
  def self.html_escape(arg); end
end

module ERB::Util
  include ::ERB::Escape
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_ONCE_REGEXP = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE_REGEXP = ::T.let(nil, ::T.untyped)
  TAG_NAME_FOLLOWING_REGEXP = ::T.let(nil, ::T.untyped)
  TAG_NAME_REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
  TAG_NAME_START_REGEXP = ::T.let(nil, ::T.untyped)
  TAG_NAME_START_REGEXP_SET = ::T.let(nil, ::T.untyped)
end

module ERB::Util
  def self.html_escape_once(s); end

  def self.json_escape(s); end

  def self.unwrapped_html_escape(s); end

  def self.xml_name_escape(name); end
end

class Encoding
  def _dump(*arg); end
  CESU_8 = ::T.let(nil, ::T.untyped)
  CP720 = ::T.let(nil, ::T.untyped)
  IBM720 = ::T.let(nil, ::T.untyped)
end

class Encoding::Converter
  def initialize(*arg); end
  LF_NEWLINE_DECORATOR = ::T.let(nil, ::T.untyped)
end

class Encoding
  def self._load(arg); end
end

module Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def as_json(options=T.unsafe(nil)); end

  def compact(); end
end

module Enumerable
  extend ::ActiveSupport::EnumerableCoreExt::Constants
end

class Enumerator
  def +(arg); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*arg); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Generator
  def each(*arg, &blk); end

  def initialize(*arg); end
end

class Enumerator::Producer
  def each(&blk); end
end

class Enumerator::Producer
end

class Enumerator::Product
  def each(&blk); end
end

class Enumerator::Product
end

class Enumerator
  def self.product(*arg); end
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

module ErrorHighlight::CoreExt
  def detailed_message(highlight: T.unsafe(nil), error_highlight: T.unsafe(nil), **arg); end
end

module Etc
  VERSION = ::T.let(nil, ::T.untyped)
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Exception
  def detailed_message(*arg); end
end

class ExitCalledError
end

class ExitCalledError
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

class Fiber
  def backtrace(*arg); end

  def backtrace_locations(*arg); end

  def blocking?(); end

  def initialize(*arg); end

  def storage(); end

  def storage=(storage); end

  def transfer(*arg); end
end

class Fiber
  def self.[](arg); end

  def self.[]=(arg, arg1); end

  def self.blocking(); end

  def self.blocking?(); end

  def self.current(); end

  def self.current_scheduler(); end

  def self.schedule(*arg); end

  def self.scheduler(); end

  def self.set_scheduler(arg); end
end

module Fiddle
  ALIGN_INT16_T = ::T.let(nil, ::T.untyped)
  ALIGN_INT32_T = ::T.let(nil, ::T.untyped)
  ALIGN_INT64_T = ::T.let(nil, ::T.untyped)
  ALIGN_INT8_T = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  Qfalse = ::T.let(nil, ::T.untyped)
  Qnil = ::T.let(nil, ::T.untyped)
  Qtrue = ::T.let(nil, ::T.untyped)
  Qundef = ::T.let(nil, ::T.untyped)
  RTLD_GLOBAL = ::T.let(nil, ::T.untyped)
  RTLD_LAZY = ::T.let(nil, ::T.untyped)
  RTLD_NOW = ::T.let(nil, ::T.untyped)
  SIZEOF_CONST_STRING = ::T.let(nil, ::T.untyped)
  SIZEOF_INT16_T = ::T.let(nil, ::T.untyped)
  SIZEOF_INT32_T = ::T.let(nil, ::T.untyped)
  SIZEOF_INT64_T = ::T.let(nil, ::T.untyped)
  SIZEOF_INT8_T = ::T.let(nil, ::T.untyped)
  SIZEOF_UCHAR = ::T.let(nil, ::T.untyped)
  SIZEOF_UINT = ::T.let(nil, ::T.untyped)
  SIZEOF_UINT16_T = ::T.let(nil, ::T.untyped)
  SIZEOF_UINT32_T = ::T.let(nil, ::T.untyped)
  SIZEOF_UINT64_T = ::T.let(nil, ::T.untyped)
  SIZEOF_UINT8_T = ::T.let(nil, ::T.untyped)
  SIZEOF_ULONG = ::T.let(nil, ::T.untyped)
  SIZEOF_ULONG_LONG = ::T.let(nil, ::T.untyped)
  SIZEOF_USHORT = ::T.let(nil, ::T.untyped)
  TYPE_CONST_STRING = ::T.let(nil, ::T.untyped)
  TYPE_INT16_T = ::T.let(nil, ::T.untyped)
  TYPE_INT32_T = ::T.let(nil, ::T.untyped)
  TYPE_INT64_T = ::T.let(nil, ::T.untyped)
  TYPE_INT8_T = ::T.let(nil, ::T.untyped)
  TYPE_UCHAR = ::T.let(nil, ::T.untyped)
  TYPE_UINT = ::T.let(nil, ::T.untyped)
  TYPE_UINT16_T = ::T.let(nil, ::T.untyped)
  TYPE_UINT32_T = ::T.let(nil, ::T.untyped)
  TYPE_UINT64_T = ::T.let(nil, ::T.untyped)
  TYPE_UINT8_T = ::T.let(nil, ::T.untyped)
  TYPE_ULONG = ::T.let(nil, ::T.untyped)
  TYPE_ULONG_LONG = ::T.let(nil, ::T.untyped)
  TYPE_USHORT = ::T.let(nil, ::T.untyped)
  TYPE_VARIADIC = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WINDOWS = ::T.let(nil, ::T.untyped)
end

class Fiddle::CStruct
  include ::Enumerable
  def each(&blk); end

  def each_pair(); end

  def replace(another); end

  def to_h(); end
end

class Fiddle::CStruct
  def self.entity_class(); end

  def self.offsetof(name, members, types); end
end

module Fiddle::CStructBuilder
end

module Fiddle::CStructBuilder
  def self.create(klass, types, members); end
end

class Fiddle::CStructEntity
  include ::Fiddle::PackInfo
  include ::Fiddle::ValueUtil
  def [](*args); end

  def []=(*args); end

  def assign_names(members); end

  def initialize(addr, types, func=T.unsafe(nil)); end

  def set_ctypes(types); end

  def to_s(); end
end

class Fiddle::CStructEntity
  def self.alignment(types); end

  def self.malloc(types, func=T.unsafe(nil), size=T.unsafe(nil), &block); end

  def self.size(types); end
end

class Fiddle::CUnion
end

class Fiddle::CUnion
  def self.entity_class(); end

  def self.offsetof(name, members, types); end
end

class Fiddle::CUnionEntity
end

class Fiddle::CUnionEntity
end

class Fiddle::ClearedReferenceError
end

class Fiddle::ClearedReferenceError
end

class Fiddle::Closure
  def free(); end

  def freed?(); end
end

class Fiddle::Closure
  def self.create(*args); end
end

class Fiddle::CompositeHandler
  def [](symbol); end

  def handlers(); end

  def initialize(handlers); end

  def sym(symbol); end
end

class Fiddle::CompositeHandler
end

class Fiddle::Error
end

class Fiddle::Error
end

class Fiddle::Function
  def need_gvl?(); end

  def to_proc(); end
end

class Fiddle::Handle
  def file_name(); end

  def sym_defined?(arg); end

  def to_ptr(); end
end

class Fiddle::Handle
  def self.sym_defined?(arg); end
end

module Fiddle::Importer
  include ::Fiddle
  include ::Fiddle::CParser
end

module Fiddle::Importer
  extend ::Fiddle::Importer
  extend ::Fiddle
  extend ::Fiddle::CParser
end

class Fiddle::MemoryView
  def [](*arg); end

  def byte_size(); end

  def format(); end

  def initialize(arg); end

  def item_size(); end

  def ndim(); end

  def obj(); end

  def readonly?(); end

  def release(); end

  def shape(); end

  def strides(); end

  def sub_offsets(); end
end

class Fiddle::MemoryView
  def self.export(arg); end
end

module Fiddle::PackInfo
  ALIGN_MAP = ::T.let(nil, ::T.untyped)
  PACK_MAP = ::T.let(nil, ::T.untyped)
  SIZE_MAP = ::T.let(nil, ::T.untyped)
end

module Fiddle::PackInfo
  def self.align(addr, align); end
end

class Fiddle::Packer
  include ::Fiddle::PackInfo
  def initialize(types); end

  def pack(ary); end

  def size(); end

  def unpack(ary); end
end

class Fiddle::Packer
  def self.[](*types); end
end

class Fiddle::Pinned
  def clear(); end

  def cleared?(); end

  def initialize(arg); end

  def ref(); end
end

class Fiddle::Pinned
end

class Fiddle::Pointer
  def call_free(); end

  def freed?(); end
end

class Fiddle::StructArray
  include ::Fiddle::ValueUtil
  def []=(index, value); end

  def initialize(ptr, type, initial_values); end

  def to_ptr(); end
end

class Fiddle::StructArray
end

module Fiddle::Types
  CHAR = ::T.let(nil, ::T.untyped)
  CONST_STRING = ::T.let(nil, ::T.untyped)
  DOUBLE = ::T.let(nil, ::T.untyped)
  FLOAT = ::T.let(nil, ::T.untyped)
  INT = ::T.let(nil, ::T.untyped)
  INT16_T = ::T.let(nil, ::T.untyped)
  INT32_T = ::T.let(nil, ::T.untyped)
  INT64_T = ::T.let(nil, ::T.untyped)
  INT8_T = ::T.let(nil, ::T.untyped)
  INTPTR_T = ::T.let(nil, ::T.untyped)
  LONG = ::T.let(nil, ::T.untyped)
  LONG_LONG = ::T.let(nil, ::T.untyped)
  PTRDIFF_T = ::T.let(nil, ::T.untyped)
  SHORT = ::T.let(nil, ::T.untyped)
  SIZE_T = ::T.let(nil, ::T.untyped)
  SSIZE_T = ::T.let(nil, ::T.untyped)
  UCHAR = ::T.let(nil, ::T.untyped)
  UINT = ::T.let(nil, ::T.untyped)
  UINT16_T = ::T.let(nil, ::T.untyped)
  UINT32_T = ::T.let(nil, ::T.untyped)
  UINT64_T = ::T.let(nil, ::T.untyped)
  UINT8_T = ::T.let(nil, ::T.untyped)
  UINTPTR_T = ::T.let(nil, ::T.untyped)
  ULONG = ::T.let(nil, ::T.untyped)
  ULONG_LONG = ::T.let(nil, ::T.untyped)
  USHORT = ::T.let(nil, ::T.untyped)
  VARIADIC = ::T.let(nil, ::T.untyped)
  VOID = ::T.let(nil, ::T.untyped)
  VOIDP = ::T.let(nil, ::T.untyped)
end

module Fiddle::Types
end

module Fiddle::ValueUtil
  def signed_value(val, ty); end

  def unsigned_value(val, ty); end

  def wrap_arg(arg, ty, funcs=T.unsafe(nil), &block); end

  def wrap_args(args, tys, funcs, &block); end
end

module Fiddle::ValueUtil
end

class File
  def self.absolute_path?(arg); end

  def self.atomic_write(file_name, temp_dir=T.unsafe(nil)); end

  def self.probe_stat_in(dir); end
end

FileList = Rake::FileList

module FileUtils
  include ::FileUtils::StreamUtils_
  LN_SUPPORTED = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
  def self.ln_sr(src, dest, target_directory: T.unsafe(nil), force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

module Forwardable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(full_mark: T.unsafe(nil), immediate_mark: T.unsafe(nil), immediate_sweep: T.unsafe(nil)); end
end

module GC
  def self.latest_compact_info(); end

  def self.measure_total_time(); end

  def self.measure_total_time=(flag); end

  def self.total_time(); end

  def self.using_rvargc?(); end

  def self.verify_transient_heap_internal_consistency(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  HAVE_OPENSSL = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
  UNTAINT = ::T.let(nil, ::T.untyped)
end

class Gem::BasicSpecification
  def plugins(); end
end

class Gem::ConfigFile
  def ipv4_fallback_enabled(); end

  def ipv4_fallback_enabled=(ipv4_fallback_enabled); end

  def last_update_check(); end

  def last_update_check=(timestamp); end

  def state_file_name(); end

  def state_file_writable?(); end
  DEFAULT_IPV4_FALLBACK_ENABLED = ::T.let(nil, ::T.untyped)
end

class Gem::Dependency
  include ::Bundler::ForcePlatform
  def force_ruby_platform(); end

  def prioritizes_bundler?(); end
end

class Gem::DependencyList
  include ::Gem::TSort
end

module Gem::Deprecate
  def deprecate(name, repl, year, month); end
end

module Gem::Deprecate
  def self.next_rubygems_major_version(); end

  def self.rubygems_deprecate(name, replacement=T.unsafe(nil)); end

  def self.rubygems_deprecate_command(version=T.unsafe(nil)); end
end

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::Builder
  def self.ruby(); end
end

class Gem::Ext::CargoBuilder
  def build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil), cargo_dir=T.unsafe(nil)); end

  def build_env(); end

  def cargo_command(cargo_toml, dest_path, args=T.unsafe(nil), crate_name=T.unsafe(nil)); end

  def initialize(); end

  def profile(); end

  def profile=(profile); end

  def runner(); end

  def runner=(runner); end

  def spec(); end

  def spec=(spec); end
end

class Gem::Ext::CargoBuilder::DylibNotFoundError
  def initialize(dir); end
end

class Gem::Ext::CargoBuilder::DylibNotFoundError
end

class Gem::Ext::CargoBuilder
end

class Gem::Ext::ExtConfBuilder
end

class Gem::Ext::ExtConfBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil), extension_dir=T.unsafe(nil)); end

  def self.get_relative_path(path, base); end
end

class Gem::Installer
  include ::Gem::InstallerUninstallerUtils
  def ensure_writable_dir(dir); end

  def explicit_version_requirement(name); end

  def gemdeps_load(name); end

  def generate_plugins(); end
end

Gem::Installer::ExtensionBuildError = Gem::Ext::BuildError

class Gem::Installer::FakePackage
  def copy_to(path); end

  def data_mode(); end

  def data_mode=(data_mode); end

  def dir_mode(); end

  def dir_mode=(dir_mode); end

  def extract_files(destination_dir, pattern=T.unsafe(nil)); end

  def initialize(spec); end

  def prog_mode(); end

  def prog_mode=(prog_mode); end

  def spec(); end

  def spec=(spec); end
end

class Gem::Installer::FakePackage
end

class Gem::Installer
  def self.inherited(klass); end
end

module Gem::InstallerUninstallerUtils
  def regenerate_plugins_for(spec, plugins_dir); end

  def remove_plugins_for(spec, plugins_dir); end
end

module Gem::InstallerUninstallerUtils
end

class Gem::Licenses
  LICENSE_REF = ::T.let(nil, ::T.untyped)
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::Platform
  def normalized_linux_version(); end

  def normalized_linux_version_ext(); end
  WINDOWS = ::T.let(nil, ::T.untyped)
  X64_LINUX = ::T.let(nil, ::T.untyped)
  X64_LINUX_MUSL = ::T.let(nil, ::T.untyped)
end

class Gem::Platform
  def self.match_gem?(platform, gem_name); end

  def self.match_spec?(spec); end

  def self.sort_priority(platform); end
end

class Gem::Request
  extend ::Gem::UserInteraction
  extend ::Gem::DefaultUserInteraction
  extend ::Gem::Text
end

class Gem::RequestSet
  include ::Gem::TSort
end

class Gem::RequestSet::Lockfile::Tokenizer::Token
  def self.keyword_init?(); end
end

class Gem::Requirement
  def _sorted_requirements(); end
end

class Gem::Resolver::APISet::GemParser
  def parse(line); end
end

class Gem::Resolver::APISet::GemParser
end

class Gem::Resolver::APISpecification
  def self.new(set, api_data); end
end

class Gem::Resolver::ActivationRequest
  def eql?(other); end
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::IndexSpecification
  def ==(other); end
end

class Gem::Resolver::InstallerSet
  def force(); end

  def force=(force); end
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

module Gem::Resolver::Molinillo::Delegates::ResolutionState
  def unused_unwind_options(); end
end

module Gem::Resolver::Molinillo::Delegates::SpecificationProvider
  def dependencies_equal?(dependencies, other_dependencies); end
end

class Gem::Resolver::Molinillo::DependencyGraph
  include ::Gem::TSort
end

class Gem::Resolver::Molinillo::DependencyGraph::Edge
  def self.keyword_init?(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::Resolver::Molinillo::DependencyGraph::Vertex
  def _path_to?(other, visited=T.unsafe(nil)); end

  def _recursive_predecessors(vertices=T.unsafe(nil)); end

  def _recursive_successors(vertices=T.unsafe(nil)); end
end

class Gem::Resolver::Molinillo::ResolutionState
  def unused_unwind_options(); end

  def unused_unwind_options=(_); end
end

class Gem::Resolver::Molinillo::ResolutionState
  def self.keyword_init?(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::Conflict
  def possibility_set(); end

  def possibility_set=(_); end

  def underlying_error(); end

  def underlying_error=(_); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::Conflict
  def self.keyword_init?(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::PossibilitySet
  def dependencies(); end

  def dependencies=(_); end

  def latest_version(); end

  def possibilities(); end

  def possibilities=(_); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::PossibilitySet
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::UnwindDetails
  include ::Comparable
  def all_requirements(); end

  def conflicting_requirements(); end

  def conflicting_requirements=(_); end

  def requirement_tree(); end

  def requirement_tree=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements_unwound_to_instead(); end

  def requirements_unwound_to_instead=(_); end

  def reversed_requirement_tree_index(); end

  def state_index(); end

  def state_index=(_); end

  def state_requirement(); end

  def state_requirement=(_); end

  def sub_dependencies_to_avoid(); end

  def unwinding_to_primary_requirement?(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::UnwindDetails
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module Gem::Resolver::Molinillo::SpecificationProvider
  def dependencies_equal?(dependencies, other_dependencies); end
end

class Gem::Resolver::Molinillo::VersionConflict
  include ::Gem::Resolver::Molinillo::Delegates::SpecificationProvider
  def message_with_trees(opts=T.unsafe(nil)); end

  def specification_provider(); end
end

class Gem::Resolver::Specification
  def required_ruby_version(); end

  def required_rubygems_version(); end
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil), num_results=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchMetadata
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  include ::Gem::Specification::YamlBackfiller
  def _deprecated_validate_dependencies(); end

  def _deprecated_validate_metadata(); end

  def _deprecated_validate_permissions(); end

  def deleted_gem?(); end

  def flatten_require_paths(); end

  def removed_method_calls(); end

  def to_ruby(); end
  LATEST_RUBY_WITHOUT_PATCH_VERSIONS = ::T.let(nil, ::T.untyped)
  REMOVED_METHODS = ::T.let(nil, ::T.untyped)
end

module Gem::Specification::YamlBackfiller
  def to_yaml(opts=T.unsafe(nil)); end
end

module Gem::Specification::YamlBackfiller
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
  def self.add_spec(spec); end

  def self.find_by_full_name(full_name); end

  def self.latest_spec_for(name); end

  def self.remove_spec(spec); end

  def self.stubs_for_pattern(pattern, match_platform=T.unsafe(nil)); end
end

class Gem::SpecificationPolicy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_duplicate_dependencies(); end

  def validate_metadata(); end

  def validate_optional(strict); end

  def validate_permissions(); end

  def validate_required!(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

module Gem::TSort
  def each_strongly_connected_component(&block); end

  def each_strongly_connected_component_from(node, id_map=T.unsafe(nil), stack=T.unsafe(nil), &block); end

  def strongly_connected_components(); end

  def tsort(); end

  def tsort_each(&block); end

  def tsort_each_child(node); end

  def tsort_each_node(); end
end

module Gem::TSort
  def self.each_strongly_connected_component(each_node, each_child); end

  def self.each_strongly_connected_component_from(node, each_child, id_map=T.unsafe(nil), stack=T.unsafe(nil)); end

  def self.strongly_connected_components(each_node, each_child); end

  def self.tsort(each_node, each_child); end

  def self.tsort_each(each_node, each_child); end
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

class Gem::UnknownCommandError
  def initialize(unknown_command); end

  def unknown_command(); end
end

class Gem::UnknownCommandError
  def self.attach_correctable(); end
end

class Gem::UnknownCommandSpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end
end

class Gem::UnknownCommandSpellChecker
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

module Gem::Util
  def self._deprecated_silent_system(*command); end
end

Gem::Version::Requirement = Gem::Requirement

module Gem
  def self.activated_gem_paths(); end

  def self.cache_home(); end

  def self.config_home(); end

  def self.data_home(); end

  def self.disable_system_update_message(); end

  def self.disable_system_update_message=(disable_system_update_message); end

  def self.discover_gems_on_require(); end

  def self.discover_gems_on_require=(discover_gems_on_require); end

  def self.find_config_file(); end

  def self.open_file(path, flags, &block); end

  def self.plugin_suffix_pattern(); end

  def self.plugin_suffix_regexp(); end

  def self.plugindir(install_dir=T.unsafe(nil)); end

  def self.solaris_platform?(); end

  def self.state_file(); end

  def self.state_home(); end
end

class HTTParty::Decompressor
  SupportedEncodings = ::T.let(nil, ::T.untyped)
end

class HTTParty::Request::Body
  MULTIPART_FORM_DATA_REPLACEMENT_TABLE = ::T.let(nil, ::T.untyped)
end

class HTTParty::Response::Headers
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class HTTParty::ResponseFragment
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def deconstruct_keys(arg); end
end

class Hash
  def self.ruby2_keywords_hash(arg); end

  def self.ruby2_keywords_hash?(arg); end
end

module Hashdiff
  VERSION = ::T.let(nil, ::T.untyped)
end

module I18n
  DEFAULT_INTERPOLATION_PATTERNS = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  INTERPOLATION_PATTERN = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def deep_interpolate(locale, data, values=T.unsafe(nil)); end

  def default(locale, object, subject, options=T.unsafe(nil)); end

  def eager_load!(); end

  def eager_loaded?(); end

  def exists?(locale, key, options=T.unsafe(nil)); end

  def interpolate(locale, subject, values=T.unsafe(nil)); end

  def load_file(filename); end

  def load_json(filename); end

  def load_rb(filename); end

  def load_translations(*filenames); end

  def load_yaml(filename); end

  def load_yml(filename); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralization_key(entry, count); end

  def pluralize(locale, entry, count); end

  def reload!(); end

  def resolve(locale, object, subject, options=T.unsafe(nil)); end

  def resolve_entry(locale, object, subject, options=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def translate_localization_format(locale, object, format, options); end
end

module I18n::Backend::Base
end

module I18n::Backend::Cache
  def _fetch(cache_key, &block); end

  def cache_key(locale, key, options); end

  def fetch(cache_key, &block); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Cache
end

module I18n::Backend::CacheFile
  def load_file(filename); end

  def normalized_path(file); end

  def path_roots(); end

  def path_roots=(path_roots); end
end

module I18n::Backend::CacheFile
end

module I18n::Backend::Cascade
  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end
end

module I18n::Backend::Cascade
end

class I18n::Backend::Chain
  include ::I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def backends(); end

  def backends=(backends); end

  def eager_load!(); end

  def exists?(locale, key, options=T.unsafe(nil)); end

  def init_translations(); end

  def initialize(*backends); end

  def initialized?(); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def namespace_lookup?(result, options); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translate(locale, key, default_options=T.unsafe(nil)); end

  def translations(); end
end

module I18n::Backend::Chain::Implementation
end

class I18n::Backend::Chain
end

module I18n::Backend::Flatten
  def escape_default_separator(key); end

  def find_link(locale, key); end

  def flatten_keys(hash, escape, prev_key=T.unsafe(nil), &block); end

  def flatten_translations(locale, data, escape, subtree); end

  def links(); end

  def normalize_flat_keys(locale, key, scope, separator); end

  def resolve_link(locale, key); end

  def store_link(locale, key, link); end
  FLATTEN_SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_ESCAPE_CHAR = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Flatten
  def self.escape_default_separator(key); end

  def self.normalize_flat_keys(locale, key, scope, separator); end
end

module I18n::Backend::Gettext
  def load_po(filename); end

  def normalize(locale, data); end

  def normalize_pluralization(locale, key, value); end

  def parse(filename); end
end

class I18n::Backend::Gettext::PoData
  def set_comment(msgid_or_sym, comment); end
end

class I18n::Backend::Gettext::PoData
end

module I18n::Backend::Gettext
end

module I18n::Backend::InterpolationCompiler
  def compile_all_strings_in(data); end

  def interpolate(locale, string, values); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::InterpolationCompiler::Compiler
  def compile_if_an_interpolation(string); end

  def compile_interpolation_token(key); end

  def compiled_interpolation_body(str); end

  def direct_key(key); end

  def escape_key_sym(key); end

  def escape_plain_str(str); end

  def handle_interpolation_token(interpolation, matchdata); end

  def interpolate_key(key); end

  def interpolate_or_raise_missing(key); end

  def interpolated_str?(str); end

  def missing_key(key); end

  def nil_key(key); end

  def reserved_key(key); end

  def tokenize(str); end
  INTERPOLATION_SYNTAX_PATTERN = ::T.let(nil, ::T.untyped)
  TOKENIZER = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::InterpolationCompiler::Compiler
  extend ::I18n::Backend::InterpolationCompiler::Compiler
end

module I18n::Backend::InterpolationCompiler
end

class I18n::Backend::KeyValue
  include ::I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def init_translations(); end

  def initialize(store, subtrees=T.unsafe(nil)); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def store(); end

  def store=(store); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translations(); end
end

module I18n::Backend::KeyValue::Implementation
end

class I18n::Backend::KeyValue::SubtreeProxy
  def [](key); end

  def has_key?(key); end

  def initialize(master_key, store); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end
end

class I18n::Backend::KeyValue::SubtreeProxy
end

class I18n::Backend::KeyValue
end

class I18n::Backend::LazyLoadable
  def initialize(lazy_load: T.unsafe(nil)); end

  def initialized_locales(); end
end

class I18n::Backend::LazyLoadable::FilenameIncorrect
  def initialize(file, expected_locale, unexpected_locales); end
end

class I18n::Backend::LazyLoadable::FilenameIncorrect
end

class I18n::Backend::LazyLoadable
end

module I18n::Backend::Memoize
  def available_locales(); end

  def eager_load!(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def memoized_lookup(); end

  def reload!(); end

  def reset_memoizations!(locale=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::Memoize
end

module I18n::Backend::Metadata
  def interpolate(locale, entry, values=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def with_metadata(metadata, &block); end
end

module I18n::Backend::Metadata
  def self.included(base); end
end

module I18n::Backend::Pluralization
  def pluralize(locale, entry, count); end

  def pluralizer(locale); end

  def pluralizers(); end
end

module I18n::Backend::Pluralization
end

class I18n::Backend::Simple
  include ::I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def eager_load!(); end

  def init_translations(); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translations(do_init: T.unsafe(nil)); end
end

module I18n::Backend::Simple::Implementation
end

class I18n::Backend::Simple
end

module I18n::Backend::Transliterator
  def transliterate(locale, string, replacement=T.unsafe(nil)); end
  DEFAULT_REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
  def initialize(rule=T.unsafe(nil)); end

  def transliterate(string, replacement=T.unsafe(nil)); end
  DEFAULT_APPROXIMATIONS = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
end

class I18n::Backend::Transliterator::ProcTransliterator
  def initialize(rule); end

  def transliterate(string, replacement=T.unsafe(nil)); end
end

class I18n::Backend::Transliterator::ProcTransliterator
end

module I18n::Backend::Transliterator
  def self.get(rule=T.unsafe(nil)); end
end

module I18n::Gettext
  CONTEXT_SEPARATOR = ::T.let(nil, ::T.untyped)
  PLURAL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module I18n::Gettext::Helpers
  def N_(msgsid); end

  def _(msgid, options=T.unsafe(nil)); end

  def gettext(msgid, options=T.unsafe(nil)); end

  def n_(msgid, msgid_plural, n=T.unsafe(nil)); end

  def ngettext(msgid, msgid_plural, n=T.unsafe(nil)); end

  def np_(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def npgettext(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def ns_(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def nsgettext(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def p_(msgctxt, msgid); end

  def pgettext(msgctxt, msgid); end

  def s_(msgid, separator=T.unsafe(nil)); end

  def sgettext(msgid, separator=T.unsafe(nil)); end
end

module I18n::Gettext::Helpers
end

module I18n::Gettext
  def self.extract_scope(msgid, separator); end

  def self.plural_keys(*args); end
end

class I18n::InvalidFilenames
  NUMBER_OF_ERRORS_SHOWN = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag
  RFC4646_FORMATS = ::T.let(nil, ::T.untyped)
  RFC4646_SUBTAGS = ::T.let(nil, ::T.untyped)
end

class I18n::Locale::Tag::Rfc4646
  include ::I18n::Locale::Tag::Parents
  def to_sym(); end
end

module I18n::Locale::Tag::Rfc4646::Parser
  PATTERN = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Rfc4646::Parser
  def self.match(tag); end
end

class I18n::Locale::Tag::Rfc4646
  def self.parser(); end

  def self.parser=(parser); end

  def self.tag(tag); end
end

class I18n::Middleware
  def call(env); end

  def initialize(app); end
end

class I18n::Middleware
end

module I18n::MissingTranslation::Base
  PERMITTED_KEYS = ::T.let(nil, ::T.untyped)
end

module I18n::Tests
end

module I18n::Tests::Localization
end

module I18n::Tests::Localization
  def self.included(base); end
end

module I18n::Tests
end

module I18n
  def self.cache_key_digest(); end

  def self.cache_key_digest=(key_digest); end

  def self.cache_namespace(); end

  def self.cache_namespace=(namespace); end

  def self.cache_store(); end

  def self.cache_store=(store); end

  def self.perform_caching?(); end
end

class IO
  def beep(); end

  def check_winsize_changed(); end

  def clear_screen(); end

  def console_mode(); end

  def console_mode=(console_mode); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(cursor); end

  def cursor_down(arg); end

  def cursor_left(arg); end

  def cursor_right(arg); end

  def cursor_up(arg); end

  def echo=(echo); end

  def echo?(); end

  def erase_line(arg); end

  def erase_screen(arg); end

  def getch(*arg); end

  def getpass(*arg); end

  def goto(arg, arg1); end

  def goto_column(arg); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*arg); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def path(); end

  def pathconf(arg); end

  def pressed?(); end

  def raw(*arg); end

  def raw!(*arg); end

  def ready?(); end

  def scroll_backward(arg); end

  def scroll_forward(arg); end

  def timeout(); end

  def timeout=(timeout); end

  def to_path(); end

  def wait(*arg); end

  def wait_priority(*arg); end

  def wait_readable(*arg); end

  def wait_writable(*arg); end

  def winsize(); end

  def winsize=(winsize); end
  PRIORITY = ::T.let(nil, ::T.untyped)
  READABLE = ::T.let(nil, ::T.untyped)
  WRITABLE = ::T.let(nil, ::T.untyped)
end

class IO::Buffer
  include ::Comparable
  def &(arg); end

  def ^(arg); end

  def and!(arg); end

  def clear(*arg); end

  def copy(*arg); end

  def each(*arg, &blk); end

  def each_byte(*arg); end

  def empty?(); end

  def external?(); end

  def free(); end

  def get_string(*arg); end

  def get_value(arg, arg1); end

  def get_values(arg, arg1); end

  def hexdump(); end

  def initialize(*arg); end

  def internal?(); end

  def locked(); end

  def locked?(); end

  def mapped?(); end

  def not!(); end

  def null?(); end

  def or!(arg); end

  def pread(*arg); end

  def pwrite(*arg); end

  def read(*arg); end

  def readonly?(); end

  def resize(arg); end

  def set_string(*arg); end

  def set_value(arg, arg1, arg2); end

  def set_values(arg, arg1, arg2); end

  def shared?(); end

  def size(); end

  def slice(*arg); end

  def transfer(); end

  def valid?(); end

  def values(*arg); end

  def write(*arg); end

  def xor!(arg); end

  def |(arg); end

  def ~(); end
  BIG_ENDIAN = ::T.let(nil, ::T.untyped)
  DEFAULT_SIZE = ::T.let(nil, ::T.untyped)
  EXTERNAL = ::T.let(nil, ::T.untyped)
  HOST_ENDIAN = ::T.let(nil, ::T.untyped)
  INTERNAL = ::T.let(nil, ::T.untyped)
  LITTLE_ENDIAN = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MAPPED = ::T.let(nil, ::T.untyped)
  NETWORK_ENDIAN = ::T.let(nil, ::T.untyped)
  PAGE_SIZE = ::T.let(nil, ::T.untyped)
  PRIVATE = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
  SHARED = ::T.let(nil, ::T.untyped)
end

class IO::Buffer::AccessError
end

class IO::Buffer::AccessError
end

class IO::Buffer::AllocationError
end

class IO::Buffer::AllocationError
end

class IO::Buffer::InvalidatedError
end

class IO::Buffer::InvalidatedError
end

class IO::Buffer::LockedError
end

class IO::Buffer::LockedError
end

class IO::Buffer::MaskError
end

class IO::Buffer::MaskError
end

class IO::Buffer
  def self.for(arg); end

  def self.map(*arg); end

  def self.size_of(arg); end
end

class IO::ConsoleMode
  def echo=(echo); end

  def raw(*arg); end

  def raw!(*arg); end
end

class IO::ConsoleMode
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO::TimeoutError
end

class IO::TimeoutError
end

class IO
  def self.console(*arg); end

  def self.new(*arg); end
end

class IPAddr
  def ==(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def netmask(); end

  def zone_id(); end

  def zone_id=(zid); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module IRB
  IRBRC_EXT = ::T.let(nil, ::T.untyped)
  MagicFile = ::T.let(nil, ::T.untyped)
  STDIN_FILE_NAME = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module IRB::Color
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  REVERSE = ::T.let(nil, ::T.untyped)
  UNDERLINE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

module IRB::Color
  def self.clear(colorable: T.unsafe(nil)); end

  def self.colorable?(); end

  def self.colorize(text, seq, colorable: T.unsafe(nil)); end

  def self.colorize_code(code, complete: T.unsafe(nil), ignore_error: T.unsafe(nil), colorable: T.unsafe(nil), local_variables: T.unsafe(nil)); end

  def self.inspect_colorable?(obj, seen: T.unsafe(nil)); end
end

class IRB::Context
  def __exit__(*arg); end

  def __inspect__(); end

  def __to_s__(); end

  def command_aliases(); end

  def command_aliases=(command_aliases); end

  def echo_on_assignment(); end

  def echo_on_assignment=(echo_on_assignment); end

  def echo_on_assignment?(); end

  def evaluate(line, line_no, exception: T.unsafe(nil)); end

  def extra_doc_dirs(); end

  def extra_doc_dirs=(extra_doc_dirs); end

  def initialize(irb, workspace=T.unsafe(nil), input_method=T.unsafe(nil)); end

  def inspect_last_value(); end

  def newline_before_multiline_output(); end

  def newline_before_multiline_output=(newline_before_multiline_output); end

  def newline_before_multiline_output?(); end

  def symbol_alias?(command); end

  def transform_args?(command); end

  def use_autocomplete(); end

  def use_autocomplete?(); end

  def use_multiline(); end

  def use_multiline?(); end

  def use_reline(); end

  def use_reline?(); end

  def use_singleline(); end

  def use_singleline?(); end
  IDNAME_IVARS = ::T.let(nil, ::T.untyped)
  NOPRINTING_IVARS = ::T.let(nil, ::T.untyped)
  NO_INSPECTING_IVARS = ::T.let(nil, ::T.untyped)
end

class IRB::DefaultEncodings
  def external(); end

  def external=(_); end

  def internal(); end

  def internal=(_); end
end

class IRB::DefaultEncodings
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

module IRB::ExtendCommandBundle
  def irb(*opts, **kwargs, &b); end

  def irb_backtrace(*opts, **kwargs, &b); end

  def irb_break(*opts, **kwargs, &b); end

  def irb_catch(*opts, **kwargs, &b); end

  def irb_change_workspace(*opts, **kwargs, &b); end

  def irb_continue(*opts, **kwargs, &b); end

  def irb_current_working_workspace(*opts, **kwargs, &b); end

  def irb_debug(*opts, **kwargs, &b); end

  def irb_debug_info(*opts, **kwargs, &b); end

  def irb_delete(*opts, **kwargs, &b); end

  def irb_edit(*opts, **kwargs, &b); end

  def irb_fg(*opts, **kwargs, &b); end

  def irb_finish(*opts, **kwargs, &b); end

  def irb_help(*opts, **kwargs, &b); end

  def irb_info(*opts, **kwargs, &b); end

  def irb_jobs(*opts, **kwargs, &b); end

  def irb_kill(*opts, **kwargs, &b); end

  def irb_ls(*opts, **kwargs, &b); end

  def irb_measure(*opts, **kwargs, &b); end

  def irb_next(*opts, **kwargs, &b); end

  def irb_pop_workspace(*opts, **kwargs, &b); end

  def irb_push_workspace(*opts, **kwargs, &b); end

  def irb_show_cmds(*opts, **kwargs, &b); end

  def irb_show_source(*opts, **kwargs, &b); end

  def irb_source(*opts, **kwargs, &b); end

  def irb_step(*opts, **kwargs, &b); end

  def irb_whereami(*opts, **kwargs, &b); end

  def irb_workspaces(*opts, **kwargs, &b); end
end

IRB::ExtendCommandBundle::EXCB = IRB::ExtendCommandBundle

module IRB::ExtendCommandBundle
  def self.all_commands_info(); end

  def self.irb_original_method_name(method_name); end

  def self.load_command(command); end
end

class IRB::FileInputMethod
  def close(); end

  def initialize(file); end
end

class IRB::FileInputMethod
  def self.open(file, &block); end
end

module IRB::InputCompletor
  BASIC_WORD_BREAK_CHARACTERS = ::T.let(nil, ::T.untyped)
  CompletionProc = ::T.let(nil, ::T.untyped)
  CompletionRequireProc = ::T.let(nil, ::T.untyped)
  GEM_PATHS = ::T.let(nil, ::T.untyped)
  Operators = ::T.let(nil, ::T.untyped)
  PerfectMatchedProc = ::T.let(nil, ::T.untyped)
  ReservedWords = ::T.let(nil, ::T.untyped)
end

module IRB::InputCompletor
  def self.absolute_path?(p); end

  def self.ignored_modules(); end

  def self.retrieve_completion_data(input, bind: T.unsafe(nil), doc_namespace: T.unsafe(nil)); end

  def self.retrieve_files_to_require_from_load_path(); end

  def self.retrieve_files_to_require_relative_from_current_dir(); end

  def self.retrieve_gem_and_system_load_path(); end

  def self.select_message(receiver, message, candidates, sep=T.unsafe(nil)); end
end

class IRB::InputMethod
  def initialize(file=T.unsafe(nil)); end

  def winsize(); end
end

class IRB::Inspector
  def initialize(inspect_proc, init_proc=T.unsafe(nil)); end
end

class IRB::Irb
  def assignment_expression?(line); end

  def convert_invalid_byte_sequence(str, enc); end

  def debug_break(); end

  def encode_with_invalid_byte_sequence(str, enc); end

  def handle_exception(exc); end

  def initialize(workspace=T.unsafe(nil), input_method=T.unsafe(nil)); end

  def output_value(omit=T.unsafe(nil)); end

  def prompt(prompt, ltype, indent, line_no); end
  ASSIGNMENT_NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
  def String(mes); end

  def encoding(); end

  def find(file, paths=T.unsafe(nil)); end

  def format(*opts); end

  def gets(*rs); end

  def initialize(locale=T.unsafe(nil)); end

  def lang(); end

  def load(file, priv=T.unsafe(nil)); end

  def modifier(); end

  def print(*opts); end

  def printf(*opts); end

  def puts(*opts); end

  def readline(*rs); end

  def require(file, priv=T.unsafe(nil)); end

  def territory(); end
  LOCALE_DIR = ::T.let(nil, ::T.untyped)
  LOCALE_NAME_RE = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
end

class IRB::OutputMethod::NotImplementedError
  def initialize(val); end
end

class IRB::ReadlineInputMethod
  def initialize(); end
end

class IRB::ReadlineInputMethod
  def self.initialize_readline(); end
end

class IRB::RelineInputMethod
  def auto_indent(&block); end

  def check_termination(&block); end

  def dynamic_prompt(&block); end

  def initialize(); end
  SHOW_DOC_DIALOG = ::T.let(nil, ::T.untyped)
end

class IRB::StdioInputMethod
  def initialize(); end
end

class IRB::WorkSpace
  def initialize(*main); end

  def local_variable_get(name); end

  def local_variable_set(name, value); end
end

module IRB
  def self.Inspector(inspect, init=T.unsafe(nil)); end

  def self.delete_caller(); end

  def self.init_config(ap_path); end

  def self.init_error(); end

  def self.load_modules(); end

  def self.parse_opts(argv: T.unsafe(nil)); end

  def self.rc_file(ext=T.unsafe(nil)); end

  def self.rc_file_generators(); end

  def self.run_config(); end

  def self.set_measure_callback(type=T.unsafe(nil), arg=T.unsafe(nil), &block); end

  def self.setup(ap_path, argv: T.unsafe(nil)); end

  def self.unset_measure_callback(type=T.unsafe(nil)); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def ceildiv(other); end

  def to_bn(); end
  GMP_VERSION = ::T.let(nil, ::T.untyped)
end

class Integer
  def self.try_convert(arg); end
end

class JSON::Ext::Generator::State
  def escape_slash(); end

  def escape_slash=(escape_slash); end

  def escape_slash?(); end
end

class JSON::Ext::Generator::State
  def self.from_state(arg); end
end

class JSON::Ext::Parser
  def initialize(*arg); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module JSON
  def self.create_fast_state(); end

  def self.create_pretty_state(); end
end

module Kernel
  def pretty_inspect(); end
end

module Kernel
  def self.at_exit(); end

  def self.exit(*arg); end

  def self.require(arg); end
end

class KeyError
  include ::DidYouMean::Correctable
end

module LanguageServer::Protocol
  VERSION = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CodeActionKind
  EMPTY = ::T.let(nil, ::T.untyped)
  QUICK_FIX = ::T.let(nil, ::T.untyped)
  REFACTOR = ::T.let(nil, ::T.untyped)
  REFACTOR_EXTRACT = ::T.let(nil, ::T.untyped)
  REFACTOR_INLINE = ::T.let(nil, ::T.untyped)
  REFACTOR_REWRITE = ::T.let(nil, ::T.untyped)
  SOURCE = ::T.let(nil, ::T.untyped)
  SOURCE_FIX_ALL = ::T.let(nil, ::T.untyped)
  SOURCE_ORGANIZE_IMPORTS = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CodeActionTriggerKind
  AUTOMATIC = ::T.let(nil, ::T.untyped)
  INVOKED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CompletionItemKind
  CLASS = ::T.let(nil, ::T.untyped)
  COLOR = ::T.let(nil, ::T.untyped)
  CONSTANT = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_MEMBER = ::T.let(nil, ::T.untyped)
  EVENT = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  FILE = ::T.let(nil, ::T.untyped)
  FOLDER = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODULE = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  SNIPPET = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  UNIT = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CompletionItemTag
  DEPRECATED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::CompletionTriggerKind
  INVOKED = ::T.let(nil, ::T.untyped)
  TRIGGER_CHARACTER = ::T.let(nil, ::T.untyped)
  TRIGGER_FOR_INCOMPLETE_COMPLETIONS = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::DiagnosticSeverity
  ERROR = ::T.let(nil, ::T.untyped)
  HINT = ::T.let(nil, ::T.untyped)
  INFORMATION = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::DiagnosticTag
  DEPRECATED = ::T.let(nil, ::T.untyped)
  UNNECESSARY = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::DocumentDiagnosticReportKind
  FULL = ::T.let(nil, ::T.untyped)
  UNCHANGED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::DocumentHighlightKind
  READ = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  WRITE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::ErrorCodes
  CONTENT_MODIFIED = ::T.let(nil, ::T.untyped)
  INTERNAL_ERROR = ::T.let(nil, ::T.untyped)
  INVALID_PARAMS = ::T.let(nil, ::T.untyped)
  INVALID_REQUEST = ::T.let(nil, ::T.untyped)
  JSONRPC_RESERVED_ERROR_RANGE_END = ::T.let(nil, ::T.untyped)
  JSONRPC_RESERVED_ERROR_RANGE_START = ::T.let(nil, ::T.untyped)
  LSP_RESERVED_ERROR_RANGE_END = ::T.let(nil, ::T.untyped)
  LSP_RESERVED_ERROR_RANGE_START = ::T.let(nil, ::T.untyped)
  METHOD_NOT_FOUND = ::T.let(nil, ::T.untyped)
  PARSE_ERROR = ::T.let(nil, ::T.untyped)
  REQUEST_CANCELLED = ::T.let(nil, ::T.untyped)
  REQUEST_FAILED = ::T.let(nil, ::T.untyped)
  SERVER_CANCELLED = ::T.let(nil, ::T.untyped)
  SERVER_ERROR_END = ::T.let(nil, ::T.untyped)
  SERVER_ERROR_START = ::T.let(nil, ::T.untyped)
  SERVER_NOT_INITIALIZED = ::T.let(nil, ::T.untyped)
  UNKNOWN_ERROR_CODE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::FailureHandlingKind
  ABORT = ::T.let(nil, ::T.untyped)
  TEXT_ONLY_TRANSACTIONAL = ::T.let(nil, ::T.untyped)
  TRANSACTIONAL = ::T.let(nil, ::T.untyped)
  UNDO = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::FileChangeType
  CHANGED = ::T.let(nil, ::T.untyped)
  CREATED = ::T.let(nil, ::T.untyped)
  DELETED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::FileOperationPatternKind
  FILE = ::T.let(nil, ::T.untyped)
  FOLDER = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::FoldingRangeKind
  COMMENT = ::T.let(nil, ::T.untyped)
  IMPORTS = ::T.let(nil, ::T.untyped)
  REGION = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::InitializeErrorCodes
  UNKNOWN_PROTOCOL_VERSION = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::InlayHintKind
  PARAMETER = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::InsertTextFormat
  PLAIN_TEXT = ::T.let(nil, ::T.untyped)
  SNIPPET = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::InsertTextMode
  ADJUST_INDENTATION = ::T.let(nil, ::T.untyped)
  AS_IS = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::MarkupKind
  MARKDOWN = ::T.let(nil, ::T.untyped)
  PLAIN_TEXT = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::MessageType
  ERROR = ::T.let(nil, ::T.untyped)
  INFO = ::T.let(nil, ::T.untyped)
  LOG = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::MonikerKind
  EXPORT = ::T.let(nil, ::T.untyped)
  IMPORT = ::T.let(nil, ::T.untyped)
  LOCAL = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::NotebookCellKind
  CODE = ::T.let(nil, ::T.untyped)
  MARKUP = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::PositionEncodingKind
  UTF16 = ::T.let(nil, ::T.untyped)
  UTF32 = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::PrepareSupportDefaultBehavior
  IDENTIFIER = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::ResourceOperationKind
  CREATE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  RENAME = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SemanticTokenModifiers
  ABSTRACT = ::T.let(nil, ::T.untyped)
  ASYNC = ::T.let(nil, ::T.untyped)
  DECLARATION = ::T.let(nil, ::T.untyped)
  DEFAULT_LIBRARY = ::T.let(nil, ::T.untyped)
  DEFINITION = ::T.let(nil, ::T.untyped)
  DEPRECATED = ::T.let(nil, ::T.untyped)
  DOCUMENTATION = ::T.let(nil, ::T.untyped)
  MODIFICATION = ::T.let(nil, ::T.untyped)
  READONLY = ::T.let(nil, ::T.untyped)
  STATIC = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SemanticTokenTypes
  CLASS = ::T.let(nil, ::T.untyped)
  COMMENT = ::T.let(nil, ::T.untyped)
  DECORATOR = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_MEMBER = ::T.let(nil, ::T.untyped)
  EVENT = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
  MACRO = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODIFIER = ::T.let(nil, ::T.untyped)
  NAMESPACE = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PARAMETER = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SignatureHelpTriggerKind
  CONTENT_CHANGE = ::T.let(nil, ::T.untyped)
  INVOKED = ::T.let(nil, ::T.untyped)
  TRIGGER_CHARACTER = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SymbolKind
  ARRAY = ::T.let(nil, ::T.untyped)
  BOOLEAN = ::T.let(nil, ::T.untyped)
  CLASS = ::T.let(nil, ::T.untyped)
  CONSTANT = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_MEMBER = ::T.let(nil, ::T.untyped)
  EVENT = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  FILE = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  KEY = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODULE = ::T.let(nil, ::T.untyped)
  NAMESPACE = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PACKAGE = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::SymbolTag
  DEPRECATED = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::TextDocumentSaveReason
  AFTER_DELAY = ::T.let(nil, ::T.untyped)
  FOCUS_OUT = ::T.let(nil, ::T.untyped)
  MANUAL = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::TextDocumentSyncKind
  FULL = ::T.let(nil, ::T.untyped)
  INCREMENTAL = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::TokenFormat
  RELATIVE = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::UniquenessLevel
  DOCUMENT = ::T.let(nil, ::T.untyped)
  GLOBAL = ::T.let(nil, ::T.untyped)
  GROUP = ::T.let(nil, ::T.untyped)
  PROJECT = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
end

module LanguageServer::Protocol::Constant::WatchKind
  CHANGE = ::T.let(nil, ::T.untyped)
  CREATE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
end

module Listen
  VERSION = ::T.let(nil, ::T.untyped)
end

module Listen::Adapter
  OPTIMIZED_ADAPTERS = ::T.let(nil, ::T.untyped)
  POLLING_FALLBACK_MESSAGE = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::BSD
  BUNDLER_DECLARE_GEM = ::T.let(nil, ::T.untyped)
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Base
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Darwin
  DEFAULTS = ::T.let(nil, ::T.untyped)
  INCOMPATIBLE_GEM_VERSION = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Linux
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
  README_URL = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Polling
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Windows
  BUNDLER_DECLARE_GEM = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Event::Loop
  MAX_STARTUP_SECONDS = ::T.let(nil, ::T.untyped)
end

Listen::Event::Loop::Error = Listen::Error

Listen::Event::Loop::NotStarted = Listen::Error::NotStarted

class Listen::Listener::Config
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Listen::Record::SymlinkDetector
  README_URL = ::T.let(nil, ::T.untyped)
  SYMLINK_LOOP_ERROR = ::T.let(nil, ::T.untyped)
end

Listen::Record::SymlinkDetector::Error = Listen::Error

class Listen::Silencer
  DEFAULT_IGNORED_EXTENSIONS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORED_FILES = ::T.let(nil, ::T.untyped)
end

class LoadError
  include ::DidYouMean::Correctable
end

class Logger
  def debug!(); end

  def error!(); end

  def fatal!(); end

  def info!(); end

  def warn!(); end
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  DatetimeFormat = ::T.let(nil, ::T.untyped)
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

class MatchData
  def deconstruct(); end

  def deconstruct_keys(arg); end

  def match(arg); end

  def match_length(arg); end
end

module MiniMime
  VERSION = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db
  LOCK = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db::RandomAccessDb
  MAX_CACHED = ::T.let(nil, ::T.untyped)
end

class MiniMime::Info
  BINARY_ENCODINGS = ::T.let(nil, ::T.untyped)
end

MiniTest = Minitest

module Minitest
  VERSION = ::T.let(nil, ::T.untyped)
end

module Minitest::Assertions
  E = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class Minitest::BacktraceFilter
  MT_RE = ::T.let(nil, ::T.untyped)
end

class Minitest::Runnable
  SIGNALS = ::T.let(nil, ::T.untyped)
end

class Minitest::Spec
  TYPES = ::T.let(nil, ::T.untyped)
end

module Minitest::Spec::DSL
  TYPES = ::T.let(nil, ::T.untyped)
end

class Minitest::Test
  PASSTHROUGH_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  SETUP_METHODS = ::T.let(nil, ::T.untyped)
  TEARDOWN_METHODS = ::T.let(nil, ::T.untyped)
end

class Minitest::Unit
  VERSION = ::T.let(nil, ::T.untyped)
end

class Module
  def deprecate(*method_names); end

  def undefined_instance_methods(); end
  DELEGATION_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
  DELEGATION_RESERVED_METHOD_NAMES = ::T.let(nil, ::T.untyped)
  RUBY_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
end

class Monitor
  def enter(); end

  def exit(); end

  def mon_check_owner(); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_enter(); end

  def try_mon_enter(); end

  def wait_for_cond(arg, arg1); end
end

module MonitorMixin
  def initialize(*arg, **arg1, &arg2); end
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

module MultiXml
  CONTENT_ROOT = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  DISALLOWED_XML_TYPES = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  REQUIREMENT_MAP = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

module Mutex_m
  VERSION = ::T.let(nil, ::T.untyped)
end

class NameError
  include ::ErrorHighlight::CoreExt
  include ::DidYouMean::Correctable
end

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  def extra_chain_cert(); end

  def extra_chain_cert=(extra_chain_cert); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def ipaddr(); end

  def ipaddr=(addr); end

  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def response_body_encoding(); end

  def response_body_encoding=(value); end

  def verify_hostname(); end

  def verify_hostname=(verify_hostname); end

  def write_timeout(); end

  def write_timeout=(sec); end
  VERSION = ::T.let(nil, ::T.untyped)
end

Net::HTTP::ProxyMod = Net::HTTP::ProxyDelta

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPClientException

Net::HTTPClientErrorCode = Net::HTTPClientError

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

Net::HTTPInformation::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPInformationCode = Net::HTTPInformation

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError

Net::HTTPRedirectionCode = Net::HTTPRedirection

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

class Net::HTTPResponse
  def body_encoding(); end

  def body_encoding=(value); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end
end

class Net::HTTPResponse::Inflater
  def bytes_inflated(); end
end

Net::HTTPResponseReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

Net::HTTPServerErrorCode = Net::HTTPServerError

Net::HTTPSession = Net::HTTP

Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPSuccessCode = Net::HTTPSuccess

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::Protocol
  VERSION = ::T.let(nil, ::T.untyped)
end

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  def =~(arg); end

  def to_d(); end
end

class NoMatchingPatternKeyError
  include ::DidYouMean::Correctable
  def key(); end

  def matchee(); end
end

class NoMatchingPatternKeyError
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::PP::ObjectMixin
  include ::ActiveSupport::Dependencies::RequireDependency
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def html_safe?(); end

  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

module Open3
  VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(arg); end

  def abs(); end

  def get_flags(arg); end

  def mod_sqrt(arg); end

  def negative?(); end

  def set_flags(arg); end
  CONSTTIME = ::T.let(nil, ::T.untyped)
end

module OpenSSL::Buffering
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def getbyte(); end
end

class OpenSSL::Buffering::Buffer
  def <<(string); end

  def concat(string); end

  def initialize(); end
  BINARY = ::T.let(nil, ::T.untyped)
end

class OpenSSL::Buffering::Buffer
end

class OpenSSL::Cipher
  def ccm_data_len=(ccm_data_len); end
end

class OpenSSL::HMAC
  def ==(other); end

  def base64digest(); end
end

class OpenSSL::HMAC
  def self.base64digest(digest, key, data); end
end

module OpenSSL::Marshal
  def _dump(_level); end
end

module OpenSSL::Marshal::ClassMethods
  def _load(string); end
end

module OpenSSL::Marshal::ClassMethods
end

module OpenSSL::Marshal
  def self.included(base); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::DH
  include ::OpenSSL::Marshal
end

class OpenSSL::PKey::DH
  extend ::OpenSSL::Marshal::ClassMethods
  def self.new(*args, &blk); end
end

class OpenSSL::PKey::DSA
  include ::OpenSSL::Marshal
end

class OpenSSL::PKey::DSA
  extend ::OpenSSL::Marshal::ClassMethods
  def self.new(*args, &blk); end
end

class OpenSSL::PKey::EC
  include ::OpenSSL::Marshal
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def add(arg); end

  def to_octet_string(arg); end
end

class OpenSSL::PKey::EC
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::PKey::PKey
  def compare?(arg); end

  def decrypt(*arg); end

  def derive(*arg); end

  def encrypt(*arg); end

  def oid(); end

  def private_to_der(*arg); end

  def private_to_pem(*arg); end

  def public_to_der(); end

  def public_to_pem(); end

  def sign_raw(*arg); end

  def to_text(); end

  def verify_raw(*arg); end

  def verify_recover(*arg); end
end

class OpenSSL::PKey::RSA
  include ::OpenSSL::Marshal
end

class OpenSSL::PKey::RSA
  extend ::OpenSSL::Marshal::ClassMethods
  def self.new(*args, &blk); end
end

module OpenSSL::PKey
  def self.generate_key(*arg); end

  def self.generate_parameters(*arg); end
end

module OpenSSL::SSL
  OP_ALLOW_CLIENT_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CLEANSE_PLAINTEXT = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_DISABLE_TLSEXT_CA_NAMES = ::T.let(nil, ::T.untyped)
  OP_ENABLE_KTLS = ::T.let(nil, ::T.untyped)
  OP_ENABLE_MIDDLEBOX_COMPAT = ::T.let(nil, ::T.untyped)
  OP_IGNORE_UNEXPECTED_EOF = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ANTI_REPLAY = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_PRIORITIZE_CHACHA = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLContext
  def alpn_protocols(); end

  def alpn_protocols=(alpn_protocols); end

  def alpn_select_cb(); end

  def alpn_select_cb=(alpn_select_cb); end

  def ciphersuites=(ciphersuites); end

  def enable_fallback_scsv(); end

  def keylog_cb(); end

  def keylog_cb=(keylog_cb); end

  def max_version=(version); end

  def min_version=(version); end

  def tmp_dh=(tmp_dh); end
  DEFAULT_TMP_DH_CALLBACK = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLSocket
  def alpn_protocol(); end

  def export_keying_material(*arg); end

  def finished_message(); end

  def peer_finished_message(); end

  def tmp_key(); end
end

class OpenSSL::SSL::SSLSocket
  def self.open(remote_host, remote_port, local_host=T.unsafe(nil), local_port=T.unsafe(nil), context: T.unsafe(nil)); end
end

module OpenSSL::SSL::SocketForwarder
  def fileno(); end
end

module OpenSSL::Timestamp
end

class OpenSSL::Timestamp::Factory
  def additional_certs(); end

  def additional_certs=(additional_certs); end

  def allowed_digests(); end

  def allowed_digests=(allowed_digests); end

  def create_timestamp(arg, arg1, arg2); end

  def default_policy_id(); end

  def default_policy_id=(default_policy_id); end

  def gen_time(); end

  def gen_time=(gen_time); end

  def serial_number(); end

  def serial_number=(serial_number); end
end

class OpenSSL::Timestamp::Factory
end

class OpenSSL::Timestamp::Request
  def algorithm(); end

  def algorithm=(algorithm); end

  def cert_requested=(cert_requested); end

  def cert_requested?(); end

  def initialize(*arg); end

  def message_imprint(); end

  def message_imprint=(message_imprint); end

  def nonce(); end

  def nonce=(nonce); end

  def policy_id(); end

  def policy_id=(policy_id); end

  def to_der(); end

  def version(); end

  def version=(version); end
end

class OpenSSL::Timestamp::Request
end

class OpenSSL::Timestamp::Response
  def failure_info(); end

  def initialize(arg); end

  def status(); end

  def status_text(); end

  def to_der(); end

  def token(); end

  def token_info(); end

  def tsa_certificate(); end

  def verify(*arg); end
  GRANTED = ::T.let(nil, ::T.untyped)
  GRANTED_WITH_MODS = ::T.let(nil, ::T.untyped)
  REJECTION = ::T.let(nil, ::T.untyped)
  REVOCATION_NOTIFICATION = ::T.let(nil, ::T.untyped)
  REVOCATION_WARNING = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class OpenSSL::Timestamp::Response
end

class OpenSSL::Timestamp::TimestampError
end

class OpenSSL::Timestamp::TimestampError
end

class OpenSSL::Timestamp::TokenInfo
  def algorithm(); end

  def gen_time(); end

  def initialize(arg); end

  def message_imprint(); end

  def nonce(); end

  def ordering(); end

  def policy_id(); end

  def serial_number(); end

  def to_der(); end

  def version(); end
end

class OpenSSL::Timestamp::TokenInfo
end

module OpenSSL::Timestamp
end

module OpenSSL::X509
  V_ERR_CA_KEY_TOO_SMALL = ::T.let(nil, ::T.untyped)
  V_ERR_CA_MD_TOO_WEAK = ::T.let(nil, ::T.untyped)
  V_ERR_CRL_PATH_VALIDATION_ERROR = ::T.let(nil, ::T.untyped)
  V_ERR_DANE_NO_MATCH = ::T.let(nil, ::T.untyped)
  V_ERR_DIFFERENT_CRL_SCOPE = ::T.let(nil, ::T.untyped)
  V_ERR_EE_KEY_TOO_SMALL = ::T.let(nil, ::T.untyped)
  V_ERR_EMAIL_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_EXCLUDED_VIOLATION = ::T.let(nil, ::T.untyped)
  V_ERR_HOSTNAME_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_CALL = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_NON_CA = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_POLICY_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_IP_ADDRESS_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_KEYUSAGE_NO_CRL_SIGN = ::T.let(nil, ::T.untyped)
  V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE = ::T.let(nil, ::T.untyped)
  V_ERR_NO_EXPLICIT_POLICY = ::T.let(nil, ::T.untyped)
  V_ERR_NO_VALID_SCTS = ::T.let(nil, ::T.untyped)
  V_ERR_OCSP_CERT_UNKNOWN = ::T.let(nil, ::T.untyped)
  V_ERR_OCSP_VERIFY_FAILED = ::T.let(nil, ::T.untyped)
  V_ERR_OCSP_VERIFY_NEEDED = ::T.let(nil, ::T.untyped)
  V_ERR_PATH_LOOP = ::T.let(nil, ::T.untyped)
  V_ERR_PERMITTED_VIOLATION = ::T.let(nil, ::T.untyped)
  V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED = ::T.let(nil, ::T.untyped)
  V_ERR_PROXY_PATH_LENGTH_EXCEEDED = ::T.let(nil, ::T.untyped)
  V_ERR_PROXY_SUBJECT_NAME_VIOLATION = ::T.let(nil, ::T.untyped)
  V_ERR_STORE_LOOKUP = ::T.let(nil, ::T.untyped)
  V_ERR_SUBTREE_MINMAX = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256 = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_ALGORITHM = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_CURVE = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_VERSION = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_LOS_NOT_ALLOWED = ::T.let(nil, ::T.untyped)
  V_ERR_UNABLE_TO_GET_CRL_ISSUER = ::T.let(nil, ::T.untyped)
  V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_UNHANDLED_CRITICAL_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_UNNESTED_RESOURCE = ::T.let(nil, ::T.untyped)
  V_ERR_UNSPECIFIED = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_CONSTRAINT_TYPE = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_EXTENSION_FEATURE = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_NAME_SYNTAX = ::T.let(nil, ::T.untyped)
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_PARTIAL_CHAIN = ::T.let(nil, ::T.untyped)
  V_FLAG_SUITEB_128_LOS = ::T.let(nil, ::T.untyped)
  V_FLAG_SUITEB_128_LOS_ONLY = ::T.let(nil, ::T.untyped)
  V_FLAG_SUITEB_192_LOS = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
  V_FLAG_USE_CHECK_TIME = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  include ::OpenSSL::Marshal
  def ==(other); end
end

class OpenSSL::X509::Attribute
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::CRL
  include ::OpenSSL::Marshal
  include ::OpenSSL::X509::Extension::AuthorityKeyIdentifier
  include ::OpenSSL::X509::Extension::Helpers
  def ==(other); end
end

class OpenSSL::X509::CRL
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::Certificate
  include ::OpenSSL::Marshal
  include ::OpenSSL::X509::Extension::SubjectKeyIdentifier
  include ::OpenSSL::X509::Extension::AuthorityKeyIdentifier
  include ::OpenSSL::X509::Extension::CRLDistributionPoints
  include ::OpenSSL::X509::Extension::AuthorityInfoAccess
  include ::OpenSSL::X509::Extension::Helpers
end

class OpenSSL::X509::Certificate
  extend ::OpenSSL::Marshal::ClassMethods
  def self.load(arg); end

  def self.load_file(path); end
end

class OpenSSL::X509::Extension
  include ::OpenSSL::Marshal
  def ==(other); end

  def value_der(); end
end

module OpenSSL::X509::Extension::AuthorityInfoAccess
  include ::OpenSSL::X509::Extension::Helpers
  def ca_issuer_uris(); end

  def ocsp_uris(); end
end

module OpenSSL::X509::Extension::AuthorityInfoAccess
end

module OpenSSL::X509::Extension::AuthorityKeyIdentifier
  include ::OpenSSL::X509::Extension::Helpers
  def authority_key_identifier(); end
end

module OpenSSL::X509::Extension::AuthorityKeyIdentifier
end

module OpenSSL::X509::Extension::CRLDistributionPoints
  include ::OpenSSL::X509::Extension::Helpers
  def crl_uris(); end
end

module OpenSSL::X509::Extension::CRLDistributionPoints
end

module OpenSSL::X509::Extension::Helpers
  def find_extension(oid); end
end

module OpenSSL::X509::Extension::Helpers
end

module OpenSSL::X509::Extension::SubjectKeyIdentifier
  include ::OpenSSL::X509::Extension::Helpers
  def subject_key_identifier(); end
end

module OpenSSL::X509::Extension::SubjectKeyIdentifier
end

class OpenSSL::X509::Extension
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::Name
  include ::OpenSSL::Marshal
  def to_utf8(); end
end

class OpenSSL::X509::Name
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::Request
  include ::OpenSSL::Marshal
  def ==(other); end
end

class OpenSSL::X509::Request
  extend ::OpenSSL::Marshal::ClassMethods
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end

  def self.fixed_length_secure_compare(arg, arg1); end

  def self.secure_compare(a, b); end
end

class OpenStruct
  def __id__!(); end

  def __send__!(*arg); end

  def class!(); end

  def clone!(freeze: T.unsafe(nil)); end

  def define_singleton_method!(*arg); end

  def delete_field!(name, &block); end

  def dig!(name, *names); end

  def display!(*arg); end

  def dup!(); end

  def each_pair!(); end

  def encode_with(coder); end

  def encode_with!(coder); end

  def enum_for!(*arg); end

  def extend!(mod, *args); end

  def freeze!(); end

  def gem!(dep, *reqs); end

  def hash!(); end

  def init_with(coder); end

  def init_with!(coder); end

  def inspect!(); end

  def instance_eval!(*arg); end

  def instance_exec!(*arg); end

  def instance_variable_get!(arg); end

  def instance_variable_set!(arg, arg1); end

  def instance_variables!(); end

  def itself!(); end

  def marshal_dump!(); end

  def method!(arg); end

  def methods!(*arg); end

  def object_id!(); end

  def private_methods!(*arg); end

  def protected_methods!(*arg); end

  def public_method!(arg); end

  def public_methods!(*arg); end

  def public_send!(*arg); end

  def remove_instance_variable!(arg); end

  def send!(*arg); end

  def singleton_class!(); end

  def singleton_method!(arg); end

  def singleton_methods!(*arg); end

  def tap!(); end

  def then!(); end

  def to_enum!(*arg); end

  def to_h!(&block); end

  def to_s!(); end

  def yield_self!(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class OptionParser
  def additional_message(typ, opt); end

  def raise_unknown(); end

  def raise_unknown=(raise_unknown); end

  def require_exact(); end

  def require_exact=(require_exact); end
  Version = ::T.let(nil, ::T.untyped)
end

class OptionParser::List
  def get_candidates(id); end
end

class OptionParser::ParseError
  def additional(); end

  def additional=(additional); end
end

class OptionParser::Switch
  def pretty_print_contents(q); end
end

class OptionParser::Switch::NoArgument
  def pretty_head(); end
end

class OptionParser::Switch::OptionalArgument
  def pretty_head(); end
end

class OptionParser::Switch::PlacedArgument
  def pretty_head(); end
end

class OptionParser::Switch::RequiredArgument
  def pretty_head(); end
end

class PP
  def self.width_for(out); end
end

module Parallel
  Stop = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Parallel::UserInterruptHandler
  INTERRUPT_SIGNAL = ::T.let(nil, ::T.untyped)
end

ParseError = Racc::ParseError

module Parser
  MESSAGES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Parser::Context
  FLAGS = ::T.let(nil, ::T.untyped)
end

class Parser::Diagnostic
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer
  ESCAPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_BEGIN = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  PUNCTUATION = ::T.let(nil, ::T.untyped)
  PUNCTUATION_BEGIN = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
  TAB_WIDTH = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Literal
  DELIMITERS = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::LexerStrings
  ESCAPES = ::T.let(nil, ::T.untyped)
  ESCAPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  REGEXP_META_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class Parser::MaxNumparamStack
  ORDINARY_PARAMS = ::T.let(nil, ::T.untyped)
end

module Parser::Meta
  NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Rewriter
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby24
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby31
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Buffer
  ENCODING_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Comment::Associator
  MAGIC_COMMENT_RE = ::T.let(nil, ::T.untyped)
  POSTFIX_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Rewriter
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Source::TreeRewriter
  ACTIONS = ::T.let(nil, ::T.untyped)
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  POLICY_TO_LEVEL = ::T.let(nil, ::T.untyped)
end

class Parser::StaticEnvironment
  ANONYMOUS_BLOCKARG = ::T.let(nil, ::T.untyped)
  ANONYMOUS_KWRESTARG = ::T.let(nil, ::T.untyped)
  ANONYMOUS_RESTARG = ::T.let(nil, ::T.untyped)
  FORWARD_ARGS = ::T.let(nil, ::T.untyped)
end

class Pathname
  def lutime(arg, arg1); end
end

class Proc
  def <<(arg); end

  def >>(arg); end

  def clone(); end
end

class Process::Status
  def self.wait(*arg); end
end

class Process::Tms
  def self.keyword_init?(); end
end

module Process
  extend ::ActiveSupport::ForkTracker::ModernCoreExt
  def self.exit(*arg); end
end

class ProgressBar::Base
  RUNNING_AVERAGE_RATE_DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  SMOOTHING_DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Bar
  DEFAULT_PROGRESS_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_REMAINDER_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_UPA_STEPS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Time
  ELAPSED_LABEL = ::T.let(nil, ::T.untyped)
  ESTIMATED_LABEL = ::T.let(nil, ::T.untyped)
  NO_TIME_ELAPSED_TEXT = ::T.let(nil, ::T.untyped)
  OOB_FRIENDLY_TIME_TEXT = ::T.let(nil, ::T.untyped)
  OOB_LIMIT_IN_HOURS = ::T.let(nil, ::T.untyped)
  OOB_TEXT_TO_FORMAT = ::T.let(nil, ::T.untyped)
  OOB_TIME_FORMATS = ::T.let(nil, ::T.untyped)
  OOB_UNKNOWN_TIME_TEXT = ::T.let(nil, ::T.untyped)
  TIME_FORMAT = ::T.let(nil, ::T.untyped)
  WALL_CLOCK_FORMAT = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Title
  DEFAULT_TITLE = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::Molecule
  BAR_MOLECULES = ::T.let(nil, ::T.untyped)
  MOLECULES = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::String
  ANSI_SGR_PATTERN = ::T.let(nil, ::T.untyped)
  MOLECULE_PATTERN = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Output
  DEFAULT_OUTPUT_STREAM = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::NonTty
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::Tty
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Progress
  DEFAULT_BEGINNING_POSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_TOTAL = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Projector
  NAME_TO_PROJECTOR_MAP = ::T.let(nil, ::T.untyped)
end

ProgressBar::Projector::DEFAULT_PROJECTOR = ProgressBar::Projectors::SmoothedAverage

class ProgressBar::Projectors::SmoothedAverage
  DEFAULT_BEGINNING_POSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_STRENGTH = ::T.let(nil, ::T.untyped)
end

module ProgressBar::Refinements::Enumerator
  ARITY_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Time
  TIME_MOCKING_LIBRARY_METHODS = ::T.let(nil, ::T.untyped)
end

module Psych
  VERSION = ::T.let(nil, ::T.untyped)
end

class Psych::AliasesNotEnabled
  def initialize(); end
end

class Psych::AliasesNotEnabled
end

class Psych::AnchorNotDefined
  def initialize(anchor_name); end
end

class Psych::AnchorNotDefined
end

class Psych::ScalarScanner
  INTEGER_LEGACY = ::T.let(nil, ::T.untyped)
  INTEGER_STRICT = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::RestrictedYAMLTree
  def visit_Symbol(sym); end
  DEFAULT_PERMITTED_CLASSES = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::RestrictedYAMLTree
end

class Psych::Visitors::Visitor
  def self.dispatch_cache(); end
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.config(); end

  def self.domain_types(*args, **arg, &block); end

  def self.domain_types=(*args, **arg, &block); end

  def self.dump_tags(*args, **arg, &block); end

  def self.dump_tags=(*args, **arg, &block); end

  def self.libyaml_version(); end

  def self.load_tags(*args, **arg, &block); end

  def self.load_tags=(*args, **arg, &block); end

  def self.remove_type(type_tag); end

  def self.safe_dump(o, io=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.safe_load_file(filename, **kwargs); end

  def self.unsafe_load(yaml, filename: T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil), freeze: T.unsafe(nil), strict_integer: T.unsafe(nil)); end

  def self.unsafe_load_file(filename, **kwargs); end
end

module PublicSuffix
  BANG = ::T.let(nil, ::T.untyped)
  DOT = ::T.let(nil, ::T.untyped)
  STAR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PublicSuffix::List
  DEFAULT_LIST_PATH = ::T.let(nil, ::T.untyped)
end

module RBS
  VERSION = ::T.let(nil, ::T.untyped)
end

module RBS::BuiltinNames
  Array = ::T.let(nil, ::T.untyped)
  BasicObject = ::T.let(nil, ::T.untyped)
  Class = ::T.let(nil, ::T.untyped)
  Comparable = ::T.let(nil, ::T.untyped)
  Enumerable = ::T.let(nil, ::T.untyped)
  Enumerator = ::T.let(nil, ::T.untyped)
  FalseClass = ::T.let(nil, ::T.untyped)
  Float = ::T.let(nil, ::T.untyped)
  Hash = ::T.let(nil, ::T.untyped)
  Integer = ::T.let(nil, ::T.untyped)
  Kernel = ::T.let(nil, ::T.untyped)
  Module = ::T.let(nil, ::T.untyped)
  Numeric = ::T.let(nil, ::T.untyped)
  Object = ::T.let(nil, ::T.untyped)
  Range = ::T.let(nil, ::T.untyped)
  Regexp = ::T.let(nil, ::T.untyped)
  Set = ::T.let(nil, ::T.untyped)
  String = ::T.let(nil, ::T.untyped)
  Symbol = ::T.let(nil, ::T.untyped)
  TrueClass = ::T.let(nil, ::T.untyped)
end

class RBS::Collection::Config
  PATH = ::T.let(nil, ::T.untyped)
end

class RBS::Collection::Sources::Git
  METADATA_FILENAME = ::T.let(nil, ::T.untyped)
end

class RBS::Collection::Sources::Stdlib
  REPO = ::T.let(nil, ::T.untyped)
end

class RBS::EnvironmentLoader
  DEFAULT_CORE_ROOT = ::T.let(nil, ::T.untyped)
end

RBS::Location::WithChildren = RBS::Location

class RBS::Parser
  KEYWORDS = ::T.let(nil, ::T.untyped)
end

RBS::Parser::LexerError = RBS::ParsingError

class RBS::Parser::LocatedValue
end

class RBS::Parser::LocatedValue
end

RBS::Parser::SemanticsError = RBS::ParsingError

RBS::Parser::SyntaxError = RBS::ParsingError

class RBS::Repository
  DEFAULT_STDLIB_ROOT = ::T.let(nil, ::T.untyped)
end

class REXML::Light::Node
  NAMESPLIT = ::T.let(nil, ::T.untyped)
  PARENTS = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::BaseParser
  EXTERNAL_ID_PUBLIC = ::T.let(nil, ::T.untyped)
  EXTERNAL_ID_SYSTEM = ::T.let(nil, ::T.untyped)
  PUBLIC_ID = ::T.let(nil, ::T.untyped)
  QNAME = ::T.let(nil, ::T.untyped)
  QNAME_STR = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::XPathParser
  LOCAL_NAME_WILDCARD = ::T.let(nil, ::T.untyped)
  PREFIX_WILDCARD = ::T.let(nil, ::T.untyped)
end

class REXML::XPathParser
  DEBUG = ::T.let(nil, ::T.untyped)
end

module Racc
  Copyright = ::T.let(nil, ::T.untyped)
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

class Ractor::ClosedError
end

class Ractor::ClosedError
end

class Ractor::Error
end

class Ractor::Error
end

class Ractor::IsolationError
end

class Ractor::IsolationError
end

class Ractor::MovedError
end

class Ractor::MovedError
end

class Ractor::MovedObject
  def !(*arg); end

  def !=(*arg); end

  def ==(*arg); end

  def __id__(*arg); end

  def equal?(*arg); end
end

class Ractor::MovedObject
end

class Ractor::RemoteError
  def ractor(); end
end

class Ractor::RemoteError
end

class Ractor::UnsafeError
end

class Ractor::UnsafeError
end

class Ractor
  def self.new(*args, name: T.unsafe(nil), &block); end
end

module Rake
  EARLY = ::T.let(nil, ::T.untyped)
  EMPTY_TASK_ARGS = ::T.let(nil, ::T.untyped)
  LATE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rake::Application
  DEFAULT_RAKEFILES = ::T.let(nil, ::T.untyped)
end

module Rake::Backtrace
  SUPPRESSED_PATHS = ::T.let(nil, ::T.untyped)
  SUPPRESSED_PATHS_RE = ::T.let(nil, ::T.untyped)
  SUPPRESS_PATTERN = ::T.let(nil, ::T.untyped)
  SYS_KEYS = ::T.let(nil, ::T.untyped)
  SYS_PATHS = ::T.let(nil, ::T.untyped)
end

module Rake::DSL
  include ::FileUtils::StreamUtils_
end

class Rake::FileList
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PROCS = ::T.let(nil, ::T.untyped)
  DELEGATING_METHODS = ::T.let(nil, ::T.untyped)
  GLOB_PATTERN = ::T.let(nil, ::T.untyped)
  MUST_DEFINE = ::T.let(nil, ::T.untyped)
  MUST_NOT_DEFINE = ::T.let(nil, ::T.untyped)
  SPECIAL_RETURN = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  include ::FileUtils::StreamUtils_
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  extend ::FileUtils::StreamUtils_
end

class Rake::InvocationChain
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::LinkedList
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::Promise
  NOT_SET = ::T.let(nil, ::T.untyped)
end

class Rake::Scope
  EMPTY = ::T.let(nil, ::T.untyped)
end

module Rake::Version
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  NUMBERS = ::T.let(nil, ::T.untyped)
  OTHER = ::T.let(nil, ::T.untyped)
end

module Rake
  extend ::FileUtils::StreamUtils_
end

RakeFileUtils = Rake::FileUtilsExt

class Random::Base
  include ::Random::Formatter
  def bytes(arg); end

  def initialize(*arg); end

  def seed(); end
end

class Random::Base
  extend ::Random::Formatter
end

class Random
  def self.bytes(arg); end

  def self.seed(); end
end

class Range
  def %(arg); end

  def entries(); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

module Readline
  def self.completion_quote_character(); end
end

class Regexp
  def timeout(); end
  TOKEN_KEYS = ::T.let(nil, ::T.untyped)
end

Regexp::Expression::Alternation::OPERAND = Regexp::Expression::Alternative

Regexp::Expression::Anchor::BOL = Regexp::Expression::Anchor::BeginningOfLine

Regexp::Expression::Anchor::BOS = Regexp::Expression::Anchor::BeginningOfString

Regexp::Expression::Anchor::EOL = Regexp::Expression::Anchor::EndOfLine

Regexp::Expression::Anchor::EOS = Regexp::Expression::Anchor::EndOfString

Regexp::Expression::Anchor::EOSobEOL = Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine

Regexp::Expression::Backref = Regexp::Expression::Backreference

Regexp::Expression::CharacterSet::Intersection::OPERAND = Regexp::Expression::CharacterSet::IntersectedSequence

Regexp::Expression::Escape = Regexp::Expression::EscapeSequence

Regexp::Expression::MatchLength = Regexp::MatchLength

Regexp::Expression::Nonposixclass = Regexp::Expression::PosixClass

Regexp::Expression::Nonproperty = Regexp::Expression::UnicodeProperty

Regexp::Expression::Posixclass = Regexp::Expression::PosixClass

Regexp::Expression::Property = Regexp::Expression::UnicodeProperty

class Regexp::Expression::Quantifier
  MODES = ::T.let(nil, ::T.untyped)
end

Regexp::Expression::Set = Regexp::Expression::CharacterSet

class Regexp::Lexer
  CLOSING_TOKENS = ::T.let(nil, ::T.untyped)
  CONDITION_TOKENS = ::T.let(nil, ::T.untyped)
  OPENING_TOKENS = ::T.let(nil, ::T.untyped)
end

class Regexp::Parser
  ENC_FLAGS = ::T.let(nil, ::T.untyped)
  MOD_FLAGS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

Regexp::Parser::UP = Regexp::Expression::UnicodeProperty

Regexp::Parser::UPTokens = Regexp::Syntax::Token::UnicodeProperty

module Regexp::Syntax
  VERSION_CONST_REGEXP = ::T.let(nil, ::T.untyped)
  VERSION_FORMAT = ::T.let(nil, ::T.untyped)
  VERSION_REGEXP = ::T.let(nil, ::T.untyped)
end

Regexp::Syntax::CURRENT = Regexp::Syntax::V3_2_0

module Regexp::Syntax::Token
  All = ::T.let(nil, ::T.untyped)
  Map = ::T.let(nil, ::T.untyped)
  Types = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Alternation
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Anchor
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  MatchStart = ::T.let(nil, ::T.untyped)
  String = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Assertion
  All = ::T.let(nil, ::T.untyped)
  Lookahead = ::T.let(nil, ::T.untyped)
  Lookbehind = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

Regexp::Syntax::Token::Backref = Regexp::Syntax::Token::Backreference

module Regexp::Syntax::Token::Backreference
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  NumberRef = ::T.let(nil, ::T.untyped)
  Plain = ::T.let(nil, ::T.untyped)
  RecursionLevel = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  V1_8_6 = ::T.let(nil, ::T.untyped)
  V1_9_1 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterSet
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterType
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Clustered = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Conditional
  All = ::T.let(nil, ::T.untyped)
  Condition = ::T.let(nil, ::T.untyped)
  Delimiters = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Escape
  ASCII = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Control = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Meta = ::T.let(nil, ::T.untyped)
  Octal = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  Unicode = ::T.let(nil, ::T.untyped)
end

Regexp::Syntax::Token::EscapeSequence = Regexp::Syntax::Token::Escape

module Regexp::Syntax::Token::FreeSpace
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Group
  All = ::T.let(nil, ::T.untyped)
  Atomic = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Comment = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Named = ::T.let(nil, ::T.untyped)
  Passive = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  V1_8_6 = ::T.let(nil, ::T.untyped)
  V2_4_1 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Keep
  All = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Literal
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Meta
  All = ::T.let(nil, ::T.untyped)
  Alternation = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::PosixClass
  All = ::T.let(nil, ::T.untyped)
  Extensions = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  Standard = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

Regexp::Syntax::Token::Property = Regexp::Syntax::Token::UnicodeProperty

module Regexp::Syntax::Token::Quantifier
  All = ::T.let(nil, ::T.untyped)
  Greedy = ::T.let(nil, ::T.untyped)
  Interval = ::T.let(nil, ::T.untyped)
  IntervalAll = ::T.let(nil, ::T.untyped)
  IntervalPossessive = ::T.let(nil, ::T.untyped)
  IntervalReluctant = ::T.let(nil, ::T.untyped)
  Possessive = ::T.let(nil, ::T.untyped)
  Reluctant = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  V1_8_6 = ::T.let(nil, ::T.untyped)
end

Regexp::Syntax::Token::Set = Regexp::Syntax::Token::CharacterSet

module Regexp::Syntax::Token::SubexpressionCall
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty
  Age = ::T.let(nil, ::T.untyped)
  Age_V1_9_3 = ::T.let(nil, ::T.untyped)
  Age_V2_0_0 = ::T.let(nil, ::T.untyped)
  Age_V2_2_0 = ::T.let(nil, ::T.untyped)
  Age_V2_3_0 = ::T.let(nil, ::T.untyped)
  Age_V2_4_0 = ::T.let(nil, ::T.untyped)
  Age_V2_5_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_2 = ::T.let(nil, ::T.untyped)
  Age_V2_6_3 = ::T.let(nil, ::T.untyped)
  Age_V3_1_0 = ::T.let(nil, ::T.untyped)
  Age_V3_2_0 = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  CharType_V1_9_0 = ::T.let(nil, ::T.untyped)
  CharType_V2_5_0 = ::T.let(nil, ::T.untyped)
  Derived = ::T.let(nil, ::T.untyped)
  Derived_V1_9_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_0_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_4_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_5_0 = ::T.let(nil, ::T.untyped)
  Emoji = ::T.let(nil, ::T.untyped)
  Emoji_V2_5_0 = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  POSIX = ::T.let(nil, ::T.untyped)
  Script = ::T.let(nil, ::T.untyped)
  Script_V1_9_0 = ::T.let(nil, ::T.untyped)
  Script_V1_9_3 = ::T.let(nil, ::T.untyped)
  Script_V2_0_0 = ::T.let(nil, ::T.untyped)
  Script_V2_2_0 = ::T.let(nil, ::T.untyped)
  Script_V2_3_0 = ::T.let(nil, ::T.untyped)
  Script_V2_4_0 = ::T.let(nil, ::T.untyped)
  Script_V2_5_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_2 = ::T.let(nil, ::T.untyped)
  Script_V3_1_0 = ::T.let(nil, ::T.untyped)
  Script_V3_2_0 = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  UnicodeBlock = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V1_9_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_0_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_2_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_3_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_4_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_5_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_2 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V3_1_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V3_2_0 = ::T.let(nil, ::T.untyped)
  V1_9_0 = ::T.let(nil, ::T.untyped)
  V1_9_3 = ::T.let(nil, ::T.untyped)
  V2_0_0 = ::T.let(nil, ::T.untyped)
  V2_2_0 = ::T.let(nil, ::T.untyped)
  V2_3_0 = ::T.let(nil, ::T.untyped)
  V2_4_0 = ::T.let(nil, ::T.untyped)
  V2_5_0 = ::T.let(nil, ::T.untyped)
  V2_6_0 = ::T.let(nil, ::T.untyped)
  V2_6_2 = ::T.let(nil, ::T.untyped)
  V2_6_3 = ::T.let(nil, ::T.untyped)
  V3_1_0 = ::T.let(nil, ::T.untyped)
  V3_2_0 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty::Category
  All = ::T.let(nil, ::T.untyped)
  Codepoint = ::T.let(nil, ::T.untyped)
  Letter = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  Punctuation = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Symbol = ::T.let(nil, ::T.untyped)
end

class Regexp::TimeoutError
end

class Regexp::TimeoutError
end

class Regexp
  def self.linear_time?(*arg); end
end

module Reline
  DEFAULT_DIALOG_CONTEXT = ::T.let(nil, ::T.untyped)
  DEFAULT_DIALOG_PROC_AUTOCOMPLETE = ::T.let(nil, ::T.untyped)
  FILENAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  HISTORY = ::T.let(nil, ::T.untyped)
  USERNAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Reline::ANSI
  CAPNAME_KEY_BINDINGS = ::T.let(nil, ::T.untyped)
  END_BRACKETED_PASTE = ::T.let(nil, ::T.untyped)
  START_BRACKETED_PASTE = ::T.let(nil, ::T.untyped)
end

class Reline::Config
  KEYSEQ_PATTERN = ::T.let(nil, ::T.untyped)
  VARIABLE_NAMES = ::T.let(nil, ::T.untyped)
  VARIABLE_NAME_SYMBOLS = ::T.let(nil, ::T.untyped)
end

class Reline::Core
  ATTR_READER_NAMES = ::T.let(nil, ::T.untyped)
end

class Reline::Core
  extend ::Forwardable
end

class Reline::DialogRenderInfo
  def fg_color(); end

  def fg_color=(_); end

  def pointer_bg_color(); end

  def pointer_bg_color=(_); end

  def pointer_fg_color(); end

  def pointer_fg_color=(_); end
end

class Reline::GeneralIO
  def self.hide_cursor(); end

  def self.show_cursor(); end
end

Reline::IOGate = Reline::ANSI

Reline::Key = Struct::Key

class Reline::KeyActor::Base
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::Emacs
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::ViCommand
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::ViInsert
  MAPPING = ::T.let(nil, ::T.untyped)
end

module Reline::KillRing::State
  CONTINUED = ::T.let(nil, ::T.untyped)
  FRESH = ::T.let(nil, ::T.untyped)
  PROCESSED = ::T.let(nil, ::T.untyped)
  YANK = ::T.let(nil, ::T.untyped)
end

class Reline::LineEditor
  DIALOG_DEFAULT_HEIGHT = ::T.let(nil, ::T.untyped)
  PROMPT_LIST_CACHE_TIMEOUT = ::T.let(nil, ::T.untyped)
  VI_MOTIONS = ::T.let(nil, ::T.untyped)
end

Reline::LineEditor::CompletionJourneyData = Struct::CompletionJourneyData

module Reline::LineEditor::CompletionState
  COMPLETION = ::T.let(nil, ::T.untyped)
  JOURNEY = ::T.let(nil, ::T.untyped)
  MENU = ::T.let(nil, ::T.untyped)
  MENU_WITH_PERFECT_MATCH = ::T.let(nil, ::T.untyped)
  NORMAL = ::T.let(nil, ::T.untyped)
  PERFECT_MATCH = ::T.let(nil, ::T.untyped)
end

Reline::LineEditor::MenuInfo = Struct::MenuInfo

module Reline::Terminfo
  extend ::Fiddle
  extend ::Fiddle::CParser
end

class Reline::Unicode
  CSI_REGEXP = ::T.let(nil, ::T.untyped)
  CSI_REGEXP_INDEX = ::T.let(nil, ::T.untyped)
  EscapedChars = ::T.let(nil, ::T.untyped)
  EscapedPairs = ::T.let(nil, ::T.untyped)
  GRAPHEME_CLUSTER_INDEX = ::T.let(nil, ::T.untyped)
  HalfwidthDakutenHandakuten = ::T.let(nil, ::T.untyped)
  MBCharWidthRE = ::T.let(nil, ::T.untyped)
  NON_PRINTING_END = ::T.let(nil, ::T.untyped)
  NON_PRINTING_END_INDEX = ::T.let(nil, ::T.untyped)
  NON_PRINTING_START = ::T.let(nil, ::T.untyped)
  NON_PRINTING_START_INDEX = ::T.let(nil, ::T.untyped)
  OSC_REGEXP = ::T.let(nil, ::T.untyped)
  OSC_REGEXP_INDEX = ::T.let(nil, ::T.untyped)
  WIDTH_SCANNER = ::T.let(nil, ::T.untyped)
end

class Reline::Unicode::EastAsianWidth
  TYPE_A = ::T.let(nil, ::T.untyped)
  TYPE_F = ::T.let(nil, ::T.untyped)
  TYPE_H = ::T.let(nil, ::T.untyped)
  TYPE_N = ::T.let(nil, ::T.untyped)
  TYPE_NA = ::T.let(nil, ::T.untyped)
  TYPE_W = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS
  def extract_resources(msg, name, typeclass); end
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config
  def initialize(config_info=T.unsafe(nil)); end
end

class Resolv::DNS::Label::Str
  def initialize(string); end
end

class Resolv::DNS::Message
  def initialize(id=T.unsafe(nil)); end
end

class Resolv::DNS::Message::MessageDecoder
  def initialize(data); end
end

class Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
  def initialize(msg, data, sock, host, port); end
end

class Resolv::DNS::Resource
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::LOC
  def initialize(version, ssize, hprecision, vprecision, latitude, longitude, altitude); end
end

class Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.random(arg); end
end

class Resolv::IPv6
  Regex_8HexLinkLocal = ::T.let(nil, ::T.untyped)
  Regex_CompressedHexLinkLocal = ::T.let(nil, ::T.untyped)
end

class Ripper
  def column(); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def encoding(); end

  def end_seen?(); end

  def error?(); end

  def filename(); end

  def initialize(*arg); end

  def lineno(); end

  def parse(); end

  def state(); end

  def token(); end

  def yydebug(); end

  def yydebug=(yydebug); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Ripper::Filter
  def initialize(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end
end

class Ripper::Lexer
  def errors(); end

  def lex(**kw); end

  def parse(raise_errors: T.unsafe(nil)); end

  def scan(**kw); end

  def tokenize(**kw); end
end

class Ripper::Lexer::Elem
  def [](index); end

  def event(); end

  def event=(event); end

  def initialize(pos, event, tok, state, message=T.unsafe(nil)); end

  def message(); end

  def message=(message); end

  def pos(); end

  def pos=(pos); end

  def state(); end

  def state=(state); end

  def to_a(); end

  def tok(); end

  def tok=(tok); end
end

class Ripper::Lexer::Elem
end

class Ripper::Lexer::State
  def &(i); end

  def ==(i); end

  def [](index); end

  def allbits?(i); end

  def anybits?(i); end

  def initialize(i); end

  def nobits?(i); end

  def to_i(); end

  def to_int(); end

  def |(i); end
end

class Ripper::Lexer::State
end

class Ripper::Lexer
end

class Ripper::SexpBuilder
  def on_BEGIN(*args); end

  def on_CHAR(tok); end

  def on_END(*args); end

  def on___end__(tok); end

  def on_alias(*args); end

  def on_alias_error(*args); end

  def on_aref(*args); end

  def on_aref_field(*args); end

  def on_arg_ambiguous(*args); end

  def on_arg_paren(*args); end

  def on_args_add(*args); end

  def on_args_add_block(*args); end

  def on_args_add_star(*args); end

  def on_args_forward(*args); end

  def on_args_new(*args); end

  def on_array(*args); end

  def on_aryptn(*args); end

  def on_assign(*args); end

  def on_assign_error(*args); end

  def on_assoc_new(*args); end

  def on_assoc_splat(*args); end

  def on_assoclist_from_args(*args); end

  def on_backref(tok); end

  def on_backtick(tok); end

  def on_bare_assoc_hash(*args); end

  def on_begin(*args); end

  def on_binary(*args); end

  def on_block_var(*args); end

  def on_blockarg(*args); end

  def on_bodystmt(*args); end

  def on_brace_block(*args); end

  def on_break(*args); end

  def on_call(*args); end

  def on_case(*args); end

  def on_class(*args); end

  def on_class_name_error(*args); end

  def on_comma(tok); end

  def on_command(*args); end

  def on_command_call(*args); end

  def on_comment(tok); end

  def on_const(tok); end

  def on_const_path_field(*args); end

  def on_const_path_ref(*args); end

  def on_const_ref(*args); end

  def on_cvar(tok); end

  def on_def(*args); end

  def on_defined(*args); end

  def on_defs(*args); end

  def on_do_block(*args); end

  def on_dot2(*args); end

  def on_dot3(*args); end

  def on_dyna_symbol(*args); end

  def on_else(*args); end

  def on_elsif(*args); end

  def on_embdoc(tok); end

  def on_embdoc_beg(tok); end

  def on_embdoc_end(tok); end

  def on_embexpr_beg(tok); end

  def on_embexpr_end(tok); end

  def on_embvar(tok); end

  def on_ensure(*args); end

  def on_excessed_comma(*args); end

  def on_fcall(*args); end

  def on_field(*args); end

  def on_float(tok); end

  def on_fndptn(*args); end

  def on_for(*args); end

  def on_gvar(tok); end

  def on_hash(*args); end

  def on_heredoc_beg(tok); end

  def on_heredoc_end(tok); end

  def on_hshptn(*args); end

  def on_ident(tok); end

  def on_if(*args); end

  def on_if_mod(*args); end

  def on_ifop(*args); end

  def on_ignored_nl(tok); end

  def on_ignored_sp(tok); end

  def on_imaginary(tok); end

  def on_in(*args); end

  def on_int(tok); end

  def on_ivar(tok); end

  def on_kw(tok); end

  def on_kwrest_param(*args); end

  def on_label(tok); end

  def on_label_end(tok); end

  def on_lambda(*args); end

  def on_lbrace(tok); end

  def on_lbracket(tok); end

  def on_lparen(tok); end

  def on_magic_comment(*args); end

  def on_massign(*args); end

  def on_method_add_arg(*args); end

  def on_method_add_block(*args); end

  def on_mlhs_add(*args); end

  def on_mlhs_add_post(*args); end

  def on_mlhs_add_star(*args); end

  def on_mlhs_new(*args); end

  def on_mlhs_paren(*args); end

  def on_module(*args); end

  def on_mrhs_add(*args); end

  def on_mrhs_add_star(*args); end

  def on_mrhs_new(*args); end

  def on_mrhs_new_from_args(*args); end

  def on_next(*args); end

  def on_nl(tok); end

  def on_nokw_param(*args); end

  def on_op(tok); end

  def on_opassign(*args); end

  def on_operator_ambiguous(*args); end

  def on_param_error(*args); end

  def on_params(*args); end

  def on_paren(*args); end

  def on_period(tok); end

  def on_program(*args); end

  def on_qsymbols_add(*args); end

  def on_qsymbols_beg(tok); end

  def on_qsymbols_new(*args); end

  def on_qwords_add(*args); end

  def on_qwords_beg(tok); end

  def on_qwords_new(*args); end

  def on_rational(tok); end

  def on_rbrace(tok); end

  def on_rbracket(tok); end

  def on_redo(*args); end

  def on_regexp_add(*args); end

  def on_regexp_beg(tok); end

  def on_regexp_end(tok); end

  def on_regexp_literal(*args); end

  def on_regexp_new(*args); end

  def on_rescue(*args); end

  def on_rescue_mod(*args); end

  def on_rest_param(*args); end

  def on_retry(*args); end

  def on_return(*args); end

  def on_return0(*args); end

  def on_rparen(tok); end

  def on_sclass(*args); end

  def on_semicolon(tok); end

  def on_sp(tok); end

  def on_stmts_add(*args); end

  def on_stmts_new(*args); end

  def on_string_add(*args); end

  def on_string_concat(*args); end

  def on_string_content(*args); end

  def on_string_dvar(*args); end

  def on_string_embexpr(*args); end

  def on_string_literal(*args); end

  def on_super(*args); end

  def on_symbeg(tok); end

  def on_symbol(*args); end

  def on_symbol_literal(*args); end

  def on_symbols_add(*args); end

  def on_symbols_beg(tok); end

  def on_symbols_new(*args); end

  def on_tlambda(tok); end

  def on_tlambeg(tok); end

  def on_top_const_field(*args); end

  def on_top_const_ref(*args); end

  def on_tstring_beg(tok); end

  def on_tstring_content(tok); end

  def on_tstring_end(tok); end

  def on_unary(*args); end

  def on_undef(*args); end

  def on_unless(*args); end

  def on_unless_mod(*args); end

  def on_until(*args); end

  def on_until_mod(*args); end

  def on_var_alias(*args); end

  def on_var_field(*args); end

  def on_var_ref(*args); end

  def on_vcall(*args); end

  def on_void_stmt(*args); end

  def on_when(*args); end

  def on_while(*args); end

  def on_while_mod(*args); end

  def on_word_add(*args); end

  def on_word_new(*args); end

  def on_words_add(*args); end

  def on_words_beg(tok); end

  def on_words_new(*args); end

  def on_words_sep(tok); end

  def on_xstring_add(*args); end

  def on_xstring_literal(*args); end

  def on_xstring_new(*args); end

  def on_yield(*args); end

  def on_yield0(*args); end

  def on_zsuper(*args); end
end

class Ripper::TokenPattern
  def initialize(pattern); end

  def match(str); end

  def match_list(tokens); end
  MAP = ::T.let(nil, ::T.untyped)
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::MatchData
  def initialize(tokens, match); end

  def string(n=T.unsafe(nil)); end
end

class Ripper::TokenPattern::MatchData
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern
  def self.compile(*arg, **arg1); end
end

class Ripper
  def self.dedent_string(arg, arg1); end

  def self.lex_state_name(arg); end

  def self.token_match(src, pattern); end
end

class RuboCop::AST::Builder
  NODE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Node
  ARGUMENT_TYPES = ::T.let(nil, ::T.untyped)
  ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  BASIC_CONDITIONALS = ::T.let(nil, ::T.untyped)
  BASIC_LITERALS = ::T.let(nil, ::T.untyped)
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  COMPOSITE_LITERALS = ::T.let(nil, ::T.untyped)
  CONDITIONALS = ::T.let(nil, ::T.untyped)
  EQUALS_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  FALSEY_LITERALS = ::T.let(nil, ::T.untyped)
  IMMUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  LITERALS = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  OPERATOR_KEYWORDS = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
  REFERENCES = ::T.let(nil, ::T.untyped)
  SHORTHAND_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYWORDS = ::T.let(nil, ::T.untyped)
  TRUTHY_LITERALS = ::T.let(nil, ::T.untyped)
  VARIABLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern
  VAR = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Compiler::Debug
  def comments(*args, **arg, &block); end

  def node_ids(); end

  def tokens(*args, **arg, &block); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer
  def compiler(); end

  def initialize(pattern, compiler: T.unsafe(nil)); end

  def node_pattern(); end

  def pattern(); end

  def test(ruby, trace: T.unsafe(nil)); end
  COLOR_SCHEME = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer::Result
  def color_map(color_scheme=T.unsafe(nil)); end

  def colorize(color_scheme=T.unsafe(nil)); end

  def colorizer(); end

  def colorizer=(_); end

  def match_map(); end

  def matched?(node); end

  def returned(); end

  def returned=(_); end

  def ruby_ast(); end

  def ruby_ast=(_); end

  def trace(); end

  def trace=(_); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer::Result
  def self.[](*arg); end

  def self.keyword_init?(); end

  def self.members(); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer
end

module RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
  def do_compile(); end
end

module RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::NodePatternSubcompiler
  include ::RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::NodePatternSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::SequenceSubcompiler
  include ::RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::SequenceSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::Trace
  def enter(node_id); end

  def matched?(node_id); end

  def success(node_id); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Trace
end

class RuboCop::AST::NodePattern::Compiler::Debug
end

class RuboCop::AST::NodePattern::Compiler::SequenceSubcompiler
  DELTA = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::LexerRex
  CALL = ::T.let(nil, ::T.untyped)
  CONST_NAME = ::T.let(nil, ::T.untyped)
  IDENTIFIER = ::T.let(nil, ::T.untyped)
  NODE_TYPE = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  REGEXP_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Node
  MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Node::Repetition
  ARITIES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Parser
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Parser::WithMeta
  def comments(); end

  def tokens(); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Builder
  def emit_atom(type, token); end

  def emit_call(type, selector_t, args=T.unsafe(nil)); end

  def emit_list(type, begin_t, children, end_t); end

  def emit_unary_op(type, operator_t=T.unsafe(nil), *children); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Builder
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Lexer
  def initialize(str_or_buffer); end

  def pos(); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Lexer
end

class RuboCop::AST::NodePattern::Parser::WithMeta
end

module RuboCop::AST::NodePattern::Sets
  MAX = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  SET_0_1 = ::T.let(nil, ::T.untyped)
  SET_0_1_2 = ::T.let(nil, ::T.untyped)
  SET_10_10 = ::T.let(nil, ::T.untyped)
  SET_1_1 = ::T.let(nil, ::T.untyped)
  SET_ADD_DEPENDENCY_ADD_RUNTIME_DEPENDENCY_ADD_DEVELOPMENT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  SET_ANY_EMPTY = ::T.let(nil, ::T.untyped)
  SET_ATTR_READER_ATTR_WRITER_ATTR_ACCESSOR_ATTR = ::T.let(nil, ::T.untyped)
  SET_BRANCH_REF_TAG = ::T.let(nil, ::T.untyped)
  SET_CALLER_CALLER_LOCATIONS = ::T.let(nil, ::T.untyped)
  SET_CAPTURE2_CAPTURE2E_CAPTURE3_ETC = ::T.let(nil, ::T.untyped)
  SET_CIPHER_DIGEST = ::T.let(nil, ::T.untyped)
  SET_CLASS_EVAL_INSTANCE_EVAL = ::T.let(nil, ::T.untyped)
  SET_CLASS_EVAL_MODULE_EVAL = ::T.let(nil, ::T.untyped)
  SET_CLASS_MODULE = ::T.let(nil, ::T.untyped)
  SET_CLASS_MODULE_STRUCT = ::T.let(nil, ::T.untyped)
  SET_CLONE_DUP_FREEZE = ::T.let(nil, ::T.untyped)
  SET_COUNT_LENGTH_SIZE = ::T.let(nil, ::T.untyped)
  SET_DEFINE_METHOD = ::T.let(nil, ::T.untyped)
  SET_DEFINE_METHOD_DEFINE_SINGLETON_METHOD = ::T.let(nil, ::T.untyped)
  SET_DOWNCASE_UPCASE = ::T.let(nil, ::T.untyped)
  SET_EACH_WITH_INDEX_WITH_INDEX = ::T.let(nil, ::T.untyped)
  SET_EACH_WITH_OBJECT_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  SET_ENV = ::T.let(nil, ::T.untyped)
  SET_ESCAPE_ENCODE_UNESCAPE_DECODE = ::T.let(nil, ::T.untyped)
  SET_EXIST_EXISTS = ::T.let(nil, ::T.untyped)
  SET_FILETEST_FILE_DIR_SHELL = ::T.let(nil, ::T.untyped)
  SET_FILE_DIR = ::T.let(nil, ::T.untyped)
  SET_FILE_FILETEST = ::T.let(nil, ::T.untyped)
  SET_FILE_TEMPFILE_STRINGIO = ::T.let(nil, ::T.untyped)
  SET_FIRST_LAST__ETC = ::T.let(nil, ::T.untyped)
  SET_FIXNUM_BIGNUM = ::T.let(nil, ::T.untyped)
  SET_FLATTEN_FLATTEN = ::T.let(nil, ::T.untyped)
  SET_FORMAT_SPRINTF_PRINTF = ::T.let(nil, ::T.untyped)
  SET_GETHOSTBYADDR_GETHOSTBYNAME = ::T.let(nil, ::T.untyped)
  SET_GSUB_GSUB = ::T.let(nil, ::T.untyped)
  SET_GSUB_GSUB_SUB_SUB = ::T.let(nil, ::T.untyped)
  SET_INCLUDE_EXTEND_PREPEND = ::T.let(nil, ::T.untyped)
  SET_INCLUDE_MEMBER = ::T.let(nil, ::T.untyped)
  SET_INSTANCE_EVAL_CLASS_EVAL_MODULE_EVAL = ::T.let(nil, ::T.untyped)
  SET_INSTANCE_EXEC_CLASS_EXEC_MODULE_EXEC = ::T.let(nil, ::T.untyped)
  SET_IO_FILE = ::T.let(nil, ::T.untyped)
  SET_KEYS_VALUES = ::T.let(nil, ::T.untyped)
  SET_KEY_HAS_KEY_FETCH_ETC = ::T.let(nil, ::T.untyped)
  SET_LAST_FIRST = ::T.let(nil, ::T.untyped)
  SET_LENGTH_SIZE = ::T.let(nil, ::T.untyped)
  SET_LOAD_RESTORE = ::T.let(nil, ::T.untyped)
  SET_MAP_COLLECT = ::T.let(nil, ::T.untyped)
  SET_MATCH_MATCH = ::T.let(nil, ::T.untyped)
  SET_MATCH__MATCH = ::T.let(nil, ::T.untyped)
  SET_MATCH___MATCH = ::T.let(nil, ::T.untyped)
  SET_MODULE_FUNCTION_RUBY2_KEYWORDS = ::T.let(nil, ::T.untyped)
  SET_NEW_ = ::T.let(nil, ::T.untyped)
  SET_NEW_COMPILE = ::T.let(nil, ::T.untyped)
  SET_NEW_OPEN = ::T.let(nil, ::T.untyped)
  SET_NIL_ = ::T.let(nil, ::T.untyped)
  SET_PIPELINE_PIPELINE_R_PIPELINE_RW_ETC = ::T.let(nil, ::T.untyped)
  SET_PRESENT_ANY_BLANK_EMPTY = ::T.let(nil, ::T.untyped)
  SET_PRIVATE_PROTECTED = ::T.let(nil, ::T.untyped)
  SET_PRIVATE_PROTECTED_PUBLIC = ::T.let(nil, ::T.untyped)
  SET_PUBLIC_CONSTANT_PRIVATE_CONSTANT = ::T.let(nil, ::T.untyped)
  SET_PUBLIC_PROTECTED_PRIVATE_MODULE_FUNCTION = ::T.let(nil, ::T.untyped)
  SET_RAISE_FAIL = ::T.let(nil, ::T.untyped)
  SET_RAISE_FAIL_THROW_ETC = ::T.let(nil, ::T.untyped)
  SET_READ_BINREAD = ::T.let(nil, ::T.untyped)
  SET_REDUCE_INJECT = ::T.let(nil, ::T.untyped)
  SET_REJECT_REJECT = ::T.let(nil, ::T.untyped)
  SET_REQUIRE_REQUIRE_RELATIVE = ::T.let(nil, ::T.untyped)
  SET_SELECT_FILTER_FIND_ALL_REJECT = ::T.let(nil, ::T.untyped)
  SET_SELECT_SELECT = ::T.let(nil, ::T.untyped)
  SET_SEND_PUBLIC_SEND___SEND__ = ::T.let(nil, ::T.untyped)
  SET_SORT_BY_SORT = ::T.let(nil, ::T.untyped)
  SET_SORT_MIN_MAX = ::T.let(nil, ::T.untyped)
  SET_SPAWN_SYSTEM = ::T.let(nil, ::T.untyped)
  SET_SPRINTF_FORMAT = ::T.let(nil, ::T.untyped)
  SET_START_WITH_END_WITH = ::T.let(nil, ::T.untyped)
  SET_START_WITH_STARTS_WITH_END_WITH_ENDS_WITH = ::T.let(nil, ::T.untyped)
  SET_STRUCT_CLASS = ::T.let(nil, ::T.untyped)
  SET_SUCC_PRED_NEXT = ::T.let(nil, ::T.untyped)
  SET_TO_ENUM_ENUM_FOR = ::T.let(nil, ::T.untyped)
  SET_TO_H_TO_HASH = ::T.let(nil, ::T.untyped)
  SET_TO_I_TO_F_TO_C_TO_R = ::T.let(nil, ::T.untyped)
  SET_TRUE_FALSE = ::T.let(nil, ::T.untyped)
  SET_ZERO_POSITIVE_NEGATIVE = ::T.let(nil, ::T.untyped)
  SET__ = ::T.let(nil, ::T.untyped)
  SET__AT_SLICE = ::T.let(nil, ::T.untyped)
  SET__EQL_ = ::T.let(nil, ::T.untyped)
  SET__EQUAL_EQL = ::T.let(nil, ::T.untyped)
  SET__FETCH = ::T.let(nil, ::T.untyped)
  SET__GLOB = ::T.let(nil, ::T.untyped)
  SET___ = ::T.let(nil, ::T.untyped)
  SET___10 = ::T.let(nil, ::T.untyped)
  SET___2 = ::T.let(nil, ::T.untyped)
  SET___3 = ::T.let(nil, ::T.untyped)
  SET___4 = ::T.let(nil, ::T.untyped)
  SET___5 = ::T.let(nil, ::T.untyped)
  SET___6 = ::T.let(nil, ::T.untyped)
  SET___7 = ::T.let(nil, ::T.untyped)
  SET___8 = ::T.let(nil, ::T.untyped)
  SET___9 = ::T.let(nil, ::T.untyped)
  SET___EQL_ETC = ::T.let(nil, ::T.untyped)
  SET___EQL_INCLUDE = ::T.let(nil, ::T.untyped)
  SET___METHOD_____CALLEE__ = ::T.let(nil, ::T.untyped)
  SET____ = ::T.let(nil, ::T.untyped)
  SET____ETC = ::T.let(nil, ::T.untyped)
  SET____ETC_2 = ::T.let(nil, ::T.untyped)
  SET____ETC_3 = ::T.let(nil, ::T.untyped)
  SET_____2 = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::ParameterizedNode::RestArguments
  EMPTY_ARGUMENTS = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::ProcessedSource
  STRING_SOURCE_NAME = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::RuboCopCompatibility
  INCOMPATIBLE_COPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Token
  LEFT_PAREN_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::Traversal
  TYPE_TO_METHOD = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::Version
  STRING = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI
  DEFAULT_PARALLEL_OPTIONS = ::T.let(nil, ::T.untyped)
  STATUS_ERROR = ::T.let(nil, ::T.untyped)
  STATUS_INTERRUPTED = ::T.let(nil, ::T.untyped)
  STATUS_OFFENSES = ::T.let(nil, ::T.untyped)
  STATUS_SUCCESS = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::AutoGenerateConfig
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
  PHASE_1 = ::T.let(nil, ::T.untyped)
  PHASE_1_DISABLED = ::T.let(nil, ::T.untyped)
  PHASE_1_OVERRIDDEN = ::T.let(nil, ::T.untyped)
  PHASE_1_SKIPPED = ::T.let(nil, ::T.untyped)
  PHASE_2 = ::T.let(nil, ::T.untyped)
  YAML_OPTIONAL_DOC_START = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::ExecuteRunner
  INTEGRATION_FORMATTERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::InitDotfile
  DOTFILE = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::SuggestExtensions
  INCLUDED_FORMATTERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::CommentConfig
  CONFIG_DISABLED_LINE_RANGE_MIN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Config
  DEFAULT_RAILS_VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigFinder
  DEFAULT_FILE = ::T.let(nil, ::T.untyped)
  DOTFILE = ::T.let(nil, ::T.untyped)
  RUBOCOP_HOME = ::T.let(nil, ::T.untyped)
  XDG_CONFIG = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigFinder
  extend ::RuboCop::FileFinder
end

class RuboCop::ConfigLoader
  DEFAULT_FILE = ::T.let(nil, ::T.untyped)
  DOTFILE = ::T.let(nil, ::T.untyped)
  RUBOCOP_HOME = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigLoader
  extend ::RuboCop::FileFinder
end

class RuboCop::ConfigObsoletion
  COP_RULE_CLASSES = ::T.let(nil, ::T.untyped)
  DEFAULT_RULES_FILE = ::T.let(nil, ::T.untyped)
  PARAMETER_RULE_CLASSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::ChangedEnforcedStyles
  BASE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::ChangedParameter
  BASE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigObsoletion::RemovedCop
  BASE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigRegeneration
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
  COMMAND_REGEX = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigValidator
  COMMON_PARAMS = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMS = ::T.let(nil, ::T.untyped)
  NEW_COPS_VALUES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Alignment
  SPACE = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::AllowedIdentifiers
  SIGILS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::AmbiguousCopName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Base
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::DuplicatedGem
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::GemComment
  CHECKED_OPTIONS_CONFIG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICTIVE_VERSION_PATTERN = ::T.let(nil, ::T.untyped)
  RESTRICTIVE_VERSION_SPECIFIERS_OPTION = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  VERSION_SPECIFIERS_OPTION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::GemFilename
  GEMFILE_FILES = ::T.let(nil, ::T.untyped)
  GEMS_RB_FILES = ::T.let(nil, ::T.untyped)
  MSG_GEMFILE_MISMATCHED = ::T.let(nil, ::T.untyped)
  MSG_GEMFILE_REQUIRED = ::T.let(nil, ::T.untyped)
  MSG_GEMS_RB_MISMATCHED = ::T.let(nil, ::T.untyped)
  MSG_GEMS_RB_REQUIRED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::GemVersion
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  REQUIRED_MSG = ::T.let(nil, ::T.untyped)
  VERSION_SPECIFICATION_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
  MSG = ::T.let(nil, ::T.untyped)
  MSG_HTTP_PROTOCOL = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::OrderedGems
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::CodeLength
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNaming
  FORMATS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNumbering
  FORMATS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Corrector
  NOOP_CONSUMER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::EachToForCorrector
  CORRECTION_WITHOUT_ARGUMENTS = ::T.let(nil, ::T.untyped)
  CORRECTION_WITH_ARGUMENTS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::EndKeywordAlignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::ForToEachCorrector
  CORRECTION = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::FrozenStringLiteral
  FROZEN_STRING_LITERAL = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LITERAL_ENABLED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DependencyVersion
  ADD_DEPENDENCY_METHODS = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  REQUIRED_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  VERSION_SPECIFICATION_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DeprecatedAttributeAssignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DevelopmentDependencies
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::OrderedDependencies
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RequireMFA
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
  MISSING_MSG = ::T.let(nil, ::T.untyped)
  NOT_EQUAL_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator
  CONFIGURATION_ADDED_MESSAGE = ::T.let(nil, ::T.untyped)
  SOURCE_TEMPLATE = ::T.let(nil, ::T.untyped)
  SPEC_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::ConfigurationInjector
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::RequireFileInjector
  REQUIRE_PATH = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::HashShorthandSyntax
  DO_NOT_MIX_EXPLICIT_VALUE_MSG = ::T.let(nil, ::T.untyped)
  DO_NOT_MIX_MSG_PREFIX = ::T.let(nil, ::T.untyped)
  DO_NOT_MIX_OMIT_VALUE_MSG = ::T.let(nil, ::T.untyped)
  EXPLICIT_HASH_VALUE_MSG = ::T.let(nil, ::T.untyped)
  OMIT_HASH_VALUE_MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::HashTransformMethod
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Heredoc
  OPENING_DELIMITER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::IfThenCorrector
  DEFAULT_INDENTATION_WIDTH = ::T.let(nil, ::T.untyped)
end

RuboCop::Cop::IgnoredMethods = RuboCop::Cop::AllowedMethods

RuboCop::Cop::IgnoredPattern = RuboCop::Cop::AllowedPattern

class RuboCop::Cop::Layout::AccessModifierIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ArgumentAlignment
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ArrayAlignment
  ALIGN_ELEMENTS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AssignmentIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BeginEndAlignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockAlignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockEndNewline
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CaseIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClassStructure
  HUMANIZED_NODE_TYPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingHeredocIndentation
  MSG = ::T.let(nil, ::T.untyped)
  MSG_ARG = ::T.let(nil, ::T.untyped)
  SIMPLE_HEREDOC = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingParenthesisIndentation
  MSG_ALIGN = ::T.let(nil, ::T.untyped)
  MSG_INDENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CommentIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ConditionPosition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::DefEndAlignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ElseAlignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause
  END_OF_HEREDOC_LINE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterMultilineCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLines
  LINE_OFFSET = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_AFTER_FOR_ONLY_BEFORE = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_AND_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_FOR_ONLY_BEFORE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundAttributeAccessor
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
  KIND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  MSG_DEFERRED = ::T.let(nil, ::T.untyped)
  MSG_EXTRA = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EndOfLine
  MSG_DETECTED = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ExtraSpacing
  MSG_UNALIGNED_ASGN = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArgumentIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstParameterIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HashAlignment
  MESSAGES = ::T.let(nil, ::T.untyped)
  SEPARATOR_ALIGNMENT_STYLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::HeredocIndentation
  TYPE_MSG = ::T.let(nil, ::T.untyped)
  WIDTH_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationConsistency
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationStyle
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationWidth
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::InitialIndentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingCommentSpace
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingEmptyLines
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LineEndStringConcatenationIndentation
  MSG_ALIGN = ::T.let(nil, ::T.untyped)
  MSG_INDENT = ::T.let(nil, ::T.untyped)
  PARENT_TYPES_FOR_INDENTED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LineLength
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayLineBreaks
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
  NEW_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
  SAME_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineBlockLayout
  ARG_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PIPE_SIZE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodParameterLineBreaks
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ParameterAlignment
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::RedundantLineBreak
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
  ALTERNATIVE_ACCESS_MODIFIERS = ::T.let(nil, ::T.untyped)
  ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  ANCESTOR_TYPES_WITH_ACCESS_MODIFIERS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SingleLineBlockChain
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterColon
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterNot
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
  ACCEPT_LEFT_PAREN = ::T.let(nil, ::T.untyped)
  ACCEPT_LEFT_SQUARE_BRACKET = ::T.let(nil, ::T.untyped)
  ACCEPT_NAMESPACE_OPERATOR = ::T.let(nil, ::T.untyped)
  DO = ::T.let(nil, ::T.untyped)
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE = ::T.let(nil, ::T.untyped)
  NAMESPACE_OPERATOR = ::T.let(nil, ::T.untyped)
  SAFE_NAVIGATION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundMethodCallOperator
  MSG = ::T.let(nil, ::T.untyped)
  SPACES_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundOperators
  EXCESSIVE_SPACE = ::T.let(nil, ::T.untyped)
  IRREGULAR_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
  DETECTED_MSG = ::T.let(nil, ::T.untyped)
  MISSING_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeBrackets
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
  MSG_REQUIRE_NO_SPACE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
  MSG = ::T.let(nil, ::T.untyped)
  MULTIPLE_SPACES_BETWEEN_ITEMS_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideParens
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
  BEGIN_REGEX = ::T.let(nil, ::T.untyped)
  END_REGEX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
  NO_SPACE_MSG = ::T.let(nil, ::T.untyped)
  SPACE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::TrailingWhitespace
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousAssignment
  MISTAKES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SIMPLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousOperator
  AMBIGUITIES = ::T.let(nil, ::T.untyped)
  MSG_FORMAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousOperatorPrecedence
  MSG = ::T.let(nil, ::T.untyped)
  PRECEDENCE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousRange
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AssignmentInCondition
  ASGN_TYPES = ::T.let(nil, ::T.untyped)
  MSG_WITHOUT_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
  MSG_WITH_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BigDecimalNew
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands
  ALLOWED_MATH_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BooleanSymbol
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::CircularArgumentReference
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConstantDefinitionInBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConstantOverwrittenInRescue
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConstantResolution
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Debugger
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
  DIR_ENV_FILE_CONSTANTS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PREFERRED_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedConstants
  DO_NOT_USE_MSG = ::T.let(nil, ::T.untyped)
  SUGGEST_GOOD_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedOpenSSLConstant
  MSG = ::T.let(nil, ::T.untyped)
  NO_ARG_ALGORITHM = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateBranch
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateCaseCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateElsifCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateHashKey
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateMagicComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateMatchPattern
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateMethods
  DEF_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRegexpCharacterClassElement
  MSG_REPEATED_ELEMENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRequire
  MSG = ::T.let(nil, ::T.untyped)
  REQUIRE_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRescueException
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EachWithObjectArgument
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ElseLayout
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyClass
  CLASS_MSG = ::T.let(nil, ::T.untyped)
  METACLASS_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyConditionalBody
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyEnsure
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyExpression
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyFile
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyInPattern
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyInterpolation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyWhen
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EnsureReturn
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ErbNewArguments
  MESSAGES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FlipFlop
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FloatComparison
  EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  FLOAT_INSTANCE_METHODS = ::T.let(nil, ::T.untyped)
  FLOAT_RETURNING_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FloatOutOfRange
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FormatParameterMismatch
  KERNEL = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INVALID = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SHOVEL = ::T.let(nil, ::T.untyped)
  STRING_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HashCompareByIdentity
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HeredocMethodCallPosition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IdentityComparison
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ImplicitStringConcatenation
  FOR_ARRAY = ::T.let(nil, ::T.untyped)
  FOR_METHOD = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IncompatibleIoSelectWithFiberScheduler
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
  ALTERNATIVE_PRIVATE = ::T.let(nil, ::T.untyped)
  ALTERNATIVE_PROTECTED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InheritException
  MSG = ::T.let(nil, ::T.untyped)
  PREFERRED_BASE_CLASS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InterpolationCheck
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LambdaWithoutLiteralBlock
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralAsCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralInInterpolation
  COMPOSITE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Loop
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MissingCopEnableDirective
  MSG = ::T.let(nil, ::T.untyped)
  MSG_BOUND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MissingSuper
  CALLBACKS = ::T.let(nil, ::T.untyped)
  CALLBACK_MSG = ::T.let(nil, ::T.untyped)
  CLASS_LIFECYCLE_CALLBACKS = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR_MSG = ::T.let(nil, ::T.untyped)
  METHOD_LIFECYCLE_CALLBACKS = ::T.let(nil, ::T.untyped)
  STATELESS_CLASSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MixedRegexpCaptureTypes
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MultipleComparison
  COMPARISON_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SET_OPERATION_OPERATORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedMethodDefinition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedPercentLiteral
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
  REGEXES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NoReturnInBeginEndBlocks
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonAtomicFileOperation
  MAKE_FORCE_METHODS = ::T.let(nil, ::T.untyped)
  MAKE_METHODS = ::T.let(nil, ::T.untyped)
  MSG_CHANGE_FORCE_METHOD = ::T.let(nil, ::T.untyped)
  MSG_REMOVE_FILE_EXIST_CHECK = ::T.let(nil, ::T.untyped)
  REMOVE_FORCE_METHODS = ::T.let(nil, ::T.untyped)
  REMOVE_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonDeterministicRequireOrder
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NumberConversion
  CONVERSION_METHODS = ::T.let(nil, ::T.untyped)
  CONVERSION_METHOD_CLASS_MAPPING = ::T.let(nil, ::T.untyped)
  METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NumberedParameterAssignment
  LVAR_MSG = ::T.let(nil, ::T.untyped)
  NUMBERED_PARAMETER_RANGE = ::T.let(nil, ::T.untyped)
  NUM_PARAM_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OrAssignmentToConstant
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OrderedMagicComments
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OutOfRangeRegexpRef
  MSG = ::T.let(nil, ::T.untyped)
  REGEXP_ARGUMENT_METHODS = ::T.let(nil, ::T.untyped)
  REGEXP_CAPTURE_METHODS = ::T.let(nil, ::T.untyped)
  REGEXP_RECEIVER_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentStringArray
  LEADING_QUOTE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTES_AND_COMMAS = ::T.let(nil, ::T.untyped)
  TRAILING_QUOTE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentSymbolArray
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RaiseException
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RandOne
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantCopDisableDirective
  COP_NAME = ::T.let(nil, ::T.untyped)
  DEPARTMENT_MARKER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantCopEnableDirective
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantDirGlobSort
  GLOB_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantRequireStatement
  MSG = ::T.let(nil, ::T.untyped)
  PRETTY_PRINT_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  RUBY_22_LOADED_FEATURES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantSafeNavigation
  MSG = ::T.let(nil, ::T.untyped)
  NIL_SPECIFIC_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantSplatExpansion
  ARRAY_PARAM_MSG = ::T.let(nil, ::T.untyped)
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_I = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_W = ::T.let(nil, ::T.untyped)
  PERCENT_I = ::T.let(nil, ::T.untyped)
  PERCENT_W = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantStringCoercion
  MSG_DEFAULT = ::T.let(nil, ::T.untyped)
  MSG_SELF = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithIndex
  MSG_EACH_WITH_INDEX = ::T.let(nil, ::T.untyped)
  MSG_WITH_INDEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithObject
  MSG_EACH_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  MSG_WITH_OBJECT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RefinementImportMethods
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RegexpAsCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RequireParentheses
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RequireRangeParentheses
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RequireRelativeSelfPath
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueException
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueType
  INVALID_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ReturnInVoidContext
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationChain
  MSG = ::T.let(nil, ::T.untyped)
  PLUS_MINUS_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationConsistency
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationWithEmpty
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ScriptPermission
  MSG = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SelfAssignment
  ASSIGNMENT_TYPE_TO_RHS_TYPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SendWithMixinArgument
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SEND_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedArgument
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedException
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::StructNewOverride
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STRUCT_MEMBER_NAME_TYPES = ::T.let(nil, ::T.untyped)
  STRUCT_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SuppressedException
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SymbolConversion
  MSG = ::T.let(nil, ::T.untyped)
  MSG_CONSISTENCY = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ToEnumArguments
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ToJSON
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TopLevelReturnWithArgument
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TrailingCommaInAttributeDeclaration
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TripleQuotes
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnexpectedBlockArity
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnifiedInteger
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnmodifiedReduceAccumulator
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INDEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnreachableCode
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnreachableLoop
  CONTINUE_KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriEscapeUnescape
  ALTERNATE_METHODS_OF_URI_ESCAPE = ::T.let(nil, ::T.untyped)
  ALTERNATE_METHODS_OF_URI_UNESCAPE = ::T.let(nil, ::T.untyped)
  METHOD_NAMES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriRegexp
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  URI_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAccessModifier
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAssignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessElseWithoutRescue
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessMethodDefinition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessRescue
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessRuby2Keywords
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessSetterCall
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessTimes
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Void
  BINARY_OPERATORS = ::T.let(nil, ::T.untyped)
  EXPRESSION_MSG = ::T.let(nil, ::T.untyped)
  LIT_MSG = ::T.let(nil, ::T.untyped)
  METHODS_REPLACEABLE_BY_EACH = ::T.let(nil, ::T.untyped)
  NONMUTATING_METHODS = ::T.let(nil, ::T.untyped)
  NONMUTATING_METHODS_WITH_BANG_VERSION = ::T.let(nil, ::T.untyped)
  NONMUTATING_MSG = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  OP_MSG = ::T.let(nil, ::T.untyped)
  SELF_MSG = ::T.let(nil, ::T.untyped)
  UNARY_OPERATORS = ::T.let(nil, ::T.untyped)
  VAR_MSG = ::T.let(nil, ::T.untyped)
  VOID_CONTEXT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::AbcSize
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockLength
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockNesting
  NESTING_BLOCKS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::CollectionLiteralLength
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::CyclomaticComplexity
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::MethodLength
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::ParameterLists
  MSG = ::T.let(nil, ::T.untyped)
  OPTIONAL_PARAMETERS_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::PerceivedComplexity
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  include ::RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount
  include ::RuboCop::AST::Sexp
end

module RuboCop::Cop::Metrics::Utils::IteratingBlock
  KNOWN_ITERATING_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Metrics::Utils::RepeatedAttributeDiscount
  VAR_SETTER_TO_GETTER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Migration::DepartmentName
  DISABLE_COMMENT_FORMAT = ::T.let(nil, ::T.untyped)
  DISABLING_COPS_CONTENT_TOKEN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::MultilineExpressionIndentation
  ASSIGNMENT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  DEFAULT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  KEYWORD_ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  KEYWORD_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  UNALIGNED_RHS_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AccessorMethodName
  MSG_READER = ::T.let(nil, ::T.untyped)
  MSG_WRITER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AsciiIdentifiers
  CONSTANT_MSG = ::T.let(nil, ::T.untyped)
  IDENTIFIER_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
  EXCLUDED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  OP_LIKE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BlockForwarding
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ConstantName
  MSG = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::FileName
  MSG_NO_DEFINITION = ::T.let(nil, ::T.untyped)
  MSG_REGEX = ::T.let(nil, ::T.untyped)
  MSG_SNAKE_CASE = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterCase
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterNaming
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::InclusiveLanguage
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_FOR_FILE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName
  DYNAMIC_DEFINE_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE_REQUIRED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MethodName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::RescuedExceptionsVariableName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableName
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableNumber
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::NegativeConditional
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Offense
  COMPARISON_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  NO_LOCATION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::OrderedGemCorrector
  extend ::RuboCop::Cop::OrderedGemNode
  extend ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::ParenthesesCorrector
  extend ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Performance::AncestorsInclude
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::ArraySemiInfiniteRangeSlice
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SLICE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::BigDecimalWithNumericArgument
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::BindCall
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::BlockGivenWithExplicitBlock
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::Caller
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::Casecmp
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::ChainArrayAllocation
  RETURNS_NEW_ARRAY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::CollectionLiteralInLoop
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  ENUMERABLE_METHOD_NAMES = ::T.let(nil, ::T.untyped)
  HASH_METHODS = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NONMUTATING_ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  NONMUTATING_HASH_METHODS = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::ConcurrentMonotonicTime
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::ConstantRegexp
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::Count
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::DeletePrefix
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::DeleteSuffix
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::Detect
  CANDIDATE_METHODS = ::T.let(nil, ::T.untyped)
  INDEX_MSG = ::T.let(nil, ::T.untyped)
  INDEX_REVERSE_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::EndWith
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::FixedSize
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::FlatMap
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::InefficientHashSearch
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::IoReadlines
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::MapCompact
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::MethodObjectAsBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::OpenStruct
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::RangeInclude
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::RedundantEqualityComparisonBlock
  COMPARISON_METHODS = ::T.let(nil, ::T.untyped)
  IS_A_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  TARGET_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::RedundantMatch
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::RedundantMerge
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::RedundantSortBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::RedundantSplitRegexpArgument
  DETERMINISTIC_REGEX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STR_SPECIAL_CHARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::RedundantStringChars
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::ReverseEach
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::ReverseFirst
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::SelectMap
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::Size
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::SortReverse
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::Squeeze
  MSG = ::T.let(nil, ::T.untyped)
  PREFERRED_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::StartWith
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::StringIdentifierArgument
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::StringInclude
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::StringReplacement
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::Sum
  MSG = ::T.let(nil, ::T.untyped)
  MSG_IF_NO_INIT_VALUE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::TimesMap
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::UnfreezeString
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::UriDefaultParser
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::PreferredDelimiters
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::RangeHelp
  BYTE_ORDER_MARK = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::RequireLibrary
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::CompoundHash
  COMBINATOR_IN_HASH_MSG = ::T.let(nil, ::T.untyped)
  MONUPLE_HASH_MSG = ::T.let(nil, ::T.untyped)
  REDUNDANT_HASH_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Eval
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::IoMethods
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::JSONLoad
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::MarshalLoad
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Open
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::YAMLLoad
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Severity
  CODE_TABLE = ::T.let(nil, ::T.untyped)
  NAMES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceAfterPunctuation
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceBeforePunctuation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AccessModifierDeclarations
  ALLOWED_NODE_TYPES = ::T.let(nil, ::T.untyped)
  GROUP_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
  INLINE_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AccessorGrouping
  GROUPED_MSG = ::T.let(nil, ::T.untyped)
  SEPARATED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Alias
  MSG_ALIAS = ::T.let(nil, ::T.untyped)
  MSG_ALIAS_METHOD = ::T.let(nil, ::T.untyped)
  MSG_SYMBOL_ARGS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AndOr
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArgumentsForwarding
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayCoercion
  CHECK_MSG = ::T.let(nil, ::T.untyped)
  SPLAT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayIntersect
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STRAIGHT_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayJoin
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AsciiComments
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Attr
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AutoResourceCleanup
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  TARGET_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BarePercentLiterals
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BeginBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BisectedAttrAccessor
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BlockComments
  BEGIN_LENGTH = ::T.let(nil, ::T.untyped)
  END_LENGTH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BlockDelimiters
  ALWAYS_BRACES_MESSAGE = ::T.let(nil, ::T.untyped)
  BRACES_REQUIRED_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
end

class RuboCop::Cop::Style::CaseEquality
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseLikeIf
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CharacterLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassAndModuleChildren
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  NESTED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassCheck
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassEqualityComparison
  CLASS_NAME_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassMethods
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassMethodsDefinitions
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SCLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassVars
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CollectionCompact
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  TO_ENUM_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CollectionMethods
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodCall
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodDefinition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CombinableLoops
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommandLiteral
  MSG_USE_BACKTICKS = ::T.let(nil, ::T.untyped)
  MSG_USE_PERCENT_X = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentAnnotation
  MISSING_NOTE = ::T.let(nil, ::T.untyped)
  MSG_COLON_STYLE = ::T.let(nil, ::T.untyped)
  MSG_SPACE_STYLE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentedKeyword
  ALLOWED_COMMENTS = ::T.let(nil, ::T.untyped)
  ALLOWED_COMMENT_REGEXES = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORD_REGEXES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ComparableClamp
  MSG = ::T.let(nil, ::T.untyped)
  MSG_MIN_MAX = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConcatArrayLiterals
  MSG = ::T.let(nil, ::T.untyped)
  MSG_FOR_PERCENT_LITERALS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConditionalAssignment
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  ASSIGN_TO_CONDITION_MSG = ::T.let(nil, ::T.untyped)
  ENABLED = ::T.let(nil, ::T.untyped)
  LINE_LENGTH = ::T.let(nil, ::T.untyped)
  MAX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SINGLE_LINE_CONDITIONS_ONLY = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  ALIGN_WITH = ::T.let(nil, ::T.untyped)
  END_ALIGNMENT = ::T.let(nil, ::T.untyped)
  EQUAL = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConstantVisibility
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Copyright
  AUTOCORRECT_EMPTY_WARNING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DataInheritance
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DateTime
  CLASS_MSG = ::T.let(nil, ::T.untyped)
  COERCION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DefWithParentheses
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Dir
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DirEmpty
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective
  MSG = ::T.let(nil, ::T.untyped)
  MSG_FOR_COPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DocumentDynamicEvalDefinition
  BLOCK_COMMENT_REGEXP = ::T.let(nil, ::T.untyped)
  COMMENT_REGEXP = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Documentation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DocumentationMethod
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleCopDisableDirective
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleNegation
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachForSimpleLoop
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachWithObject
  METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyBlockParameter
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyCaseCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyElse
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyHeredoc
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLambdaParameter
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLiteral
  ARR_MSG = ::T.let(nil, ::T.untyped)
  HASH_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  STR_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyMethod
  MSG_COMPACT = ::T.let(nil, ::T.untyped)
  MSG_EXPANDED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Encoding
  ENCODING_PATTERN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EndBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EndlessMethod
  CORRECTION_STYLES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_MULTI_LINE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EnvHome
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvalWithLocation
  MSG = ::T.let(nil, ::T.untyped)
  MSG_EVAL = ::T.let(nil, ::T.untyped)
  MSG_INCORRECT_FILE = ::T.let(nil, ::T.untyped)
  MSG_INCORRECT_LINE = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvenOdd
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExpandPathArguments
  MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_NEW_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExplicitBlockArgument
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExponentialNotation
  MESSAGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FetchEnvVar
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FileEmpty
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FileRead
  MSG = ::T.let(nil, ::T.untyped)
  READ_FILE_START_TO_FINISH_MODES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FileWrite
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  TRUNCATING_WRITE_MODES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FloatDivision
  MESSAGES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::For
  EACH_LENGTH = ::T.let(nil, ::T.untyped)
  PREFER_EACH = ::T.let(nil, ::T.untyped)
  PREFER_FOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FormatString
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
  MSG_DISABLED = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
  MSG_MISSING_TRUE = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GlobalStdStream
  MSG = ::T.let(nil, ::T.untyped)
  STD_STREAMS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GlobalVars
  BUILT_IN_VARS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GuardClause
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashConversion
  MSG_LITERAL_HASH_ARG = ::T.let(nil, ::T.untyped)
  MSG_LITERAL_MULTI_ARG = ::T.let(nil, ::T.untyped)
  MSG_SPLAT = ::T.let(nil, ::T.untyped)
  MSG_TO_H = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashEachMethods
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashExcept
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashLikeCase
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashSyntax
  MSG_19 = ::T.let(nil, ::T.untyped)
  MSG_HASH_ROCKETS = ::T.let(nil, ::T.untyped)
  MSG_NO_MIXED_KEYS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IdenticalConditionalBranches
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
end

class RuboCop::Cop::Style::IfInsideElse
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifier
  MSG_USE_MODIFIER = ::T.let(nil, ::T.untyped)
  MSG_USE_NORMAL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfWithBooleanLiteralBranches
  MSG = ::T.let(nil, ::T.untyped)
  MSG_FOR_ELSIF = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfWithSemicolon
  MSG_IF_ELSE = ::T.let(nil, ::T.untyped)
  MSG_TERNARY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ImplicitRuntimeError
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InPatternThen
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InfiniteLoop
  LEADING_SPACE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InlineComment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InverseMethods
  CAMEL_CASE = ::T.let(nil, ::T.untyped)
  CLASS_COMPARISON_METHODS = ::T.let(nil, ::T.untyped)
  EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InvertibleUnlessCondition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IpAddresses
  IPV6_MAX_SIZE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::KeywordParametersOrder
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Lambda
  LITERAL_MESSAGE = ::T.let(nil, ::T.untyped)
  METHOD_MESSAGE = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::LambdaCall
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::LineEndConcatenation
  COMPLEX_STRING_BEGIN_TOKEN = ::T.let(nil, ::T.untyped)
  COMPLEX_STRING_END_TOKEN = ::T.let(nil, ::T.untyped)
  CONCAT_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  HIGH_PRECEDENCE_OP_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTE_DELIMITERS = ::T.let(nil, ::T.untyped)
  SIMPLE_STRING_TOKEN_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MagicCommentFormat
  KEBAB_SEPARATOR = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_VALUE = ::T.let(nil, ::T.untyped)
  SNAKE_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MagicCommentFormat::CommentRange
  DIRECTIVE_REGEXP = ::T.let(nil, ::T.untyped)
  VALUE_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MapCompactWithConditionalBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MapToHash
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MapToSet
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
  TRAILING_WHITESPACE_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodDefParentheses
  MSG_MISSING = ::T.let(nil, ::T.untyped)
  MSG_PRESENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MinMax
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MinMaxComparison
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  GRATER_OPERATORS = ::T.let(nil, ::T.untyped)
  LESS_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingElse
  MSG = ::T.let(nil, ::T.untyped)
  MSG_EMPTY = ::T.let(nil, ::T.untyped)
  MSG_NIL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingRespondToMissing
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinGrouping
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinUsage
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ModuleFunction
  EXTEND_SELF_MSG = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  MODULE_FUNCTION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineBlockChain
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfModifier
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfThen
  MSG = ::T.let(nil, ::T.untyped)
  NON_MODIFIER_THEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineInPatternThen
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMemoization
  BRACES_MSG = ::T.let(nil, ::T.untyped)
  KEYWORD_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMethodSignature
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineTernaryOperator
  MSG_IF = ::T.let(nil, ::T.untyped)
  MSG_SINGLE_LINE = ::T.let(nil, ::T.untyped)
  SINGLE_LINE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineWhenThen
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultipleComparison
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MutableConstant
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NegatedIfElseCondition
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedFileDirname
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedModifier
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedTernaryOperator
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Next
  EXIT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NilComparison
  EXPLICIT_MSG = ::T.let(nil, ::T.untyped)
  PREDICATE_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NilLambda
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NonNilCheck
  MSG_FOR_REDUNDANCY = ::T.let(nil, ::T.untyped)
  MSG_FOR_REPLACEMENT = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Not
  MSG = ::T.let(nil, ::T.untyped)
  OPPOSITE_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumberedParameters
  MSG_DISALLOW = ::T.let(nil, ::T.untyped)
  MSG_MULTI_LINE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumberedParametersLimit
  DEFAULT_MAX_VALUE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NUMBERED_PARAMETER_PATTERN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiteralPrefix
  BINARY_MSG = ::T.let(nil, ::T.untyped)
  BINARY_REGEX = ::T.let(nil, ::T.untyped)
  DECIMAL_MSG = ::T.let(nil, ::T.untyped)
  DECIMAL_REGEX = ::T.let(nil, ::T.untyped)
  HEX_MSG = ::T.let(nil, ::T.untyped)
  HEX_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiterals
  DELIMITER_REGEXP = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericPredicate
  MSG = ::T.let(nil, ::T.untyped)
  REPLACEMENTS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ObjectThen
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OneLineConditional
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OpenStructUse
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OperatorMethodCall
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionHash
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionalArguments
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionalBooleanParameter
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OrAssignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ParallelAssignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PercentQLiterals
  LOWER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
  UPPER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PerlBackrefs
  MESSAGE_FORMAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PreferredHashMethods
  MSG = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Proc
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::QuotedSymbols
  MSG_DOUBLE = ::T.let(nil, ::T.untyped)
  MSG_SINGLE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RaiseArgs
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  EXPLODED_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RandomWithOffset
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantArgument
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantAssignment
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantBegin
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCapitalW
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantCondition
  ARGUMENT_WITH_OPERATOR_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  REDUNDANT_CONDITION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantConditional
  COMPARISON_OPERATOR_MATCHER = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantConstantBase
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantDoubleSplatHashBraces
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantEach
  MSG = ::T.let(nil, ::T.untyped)
  MSG_WITH_INDEX = ::T.let(nil, ::T.untyped)
  MSG_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantException
  MSG_1 = ::T.let(nil, ::T.untyped)
  MSG_2 = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFetchBlock
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFileExtensionInRequire
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFreeze
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantHeredocDelimiterQuotes
  MSG = ::T.let(nil, ::T.untyped)
  STRING_INTERPOLATION_OR_ESCAPED_CHARACTER_PATTERN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantInitialize
  MSG = ::T.let(nil, ::T.untyped)
  MSG_EMPTY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantInterpolation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantLineContinuation
  ALLOWED_STRING_TOKENS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantPercentQ
  DYNAMIC_MSG = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ESCAPED_NON_BACKSLASH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_Q = ::T.let(nil, ::T.untyped)
  PERCENT_Q = ::T.let(nil, ::T.untyped)
  QUOTE = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTE = ::T.let(nil, ::T.untyped)
  STRING_INTERPOLATION_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantRegexpCharacterClass
  MSG_REDUNDANT_CHARACTER_CLASS = ::T.let(nil, ::T.untyped)
  REQUIRES_ESCAPE_OUTSIDE_CHAR_CLASS_CHARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantRegexpEscape
  ALLOWED_ALWAYS_ESCAPES = ::T.let(nil, ::T.untyped)
  ALLOWED_OUTSIDE_CHAR_CLASS_METACHAR_ESCAPES = ::T.let(nil, ::T.untyped)
  ALLOWED_WITHIN_CHAR_CLASS_METACHAR_ESCAPES = ::T.let(nil, ::T.untyped)
  MSG_REDUNDANT_ESCAPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantReturn
  MSG = ::T.let(nil, ::T.untyped)
  MULTI_RETURN_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelf
  KERNEL_METHODS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelfAssignment
  ASSIGNMENT_TYPE_TO_RECEIVER_TYPE = ::T.let(nil, ::T.untyped)
  METHODS_RETURNING_SELF = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelfAssignmentBranch
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSort
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSortBy
  MSG_BLOCK = ::T.let(nil, ::T.untyped)
  MSG_NUMBLOCK = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantStringEscape
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RegexpLiteral
  MSG_USE_PERCENT_R = ::T.let(nil, ::T.untyped)
  MSG_USE_SLASHES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RequireOrder
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueModifier
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueStandardError
  MSG_EXPLICIT = ::T.let(nil, ::T.untyped)
  MSG_IMPLICIT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ReturnNil
  RETURN_MSG = ::T.let(nil, ::T.untyped)
  RETURN_NIL_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SafeNavigation
  LOGIC_JUMP_KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Sample
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SelectByRegexp
  MSG = ::T.let(nil, ::T.untyped)
  OPPOSITE_REPLACEMENTS = ::T.let(nil, ::T.untyped)
  REGEXP_METHODS = ::T.let(nil, ::T.untyped)
  REPLACEMENTS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SelfAssignment
  MSG = ::T.let(nil, ::T.untyped)
  OPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Semicolon
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Send
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SignalException
  FAIL_MSG = ::T.let(nil, ::T.untyped)
  RAISE_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleArgumentDig
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineBlockParams
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineMethods
  MSG = ::T.let(nil, ::T.untyped)
  NOT_SUPPORTED_ENDLESS_METHOD_BODY_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SlicingWithRange
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SoleNestedConditional
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SpecialGlobalVars
  BUILTIN_VARS = ::T.let(nil, ::T.untyped)
  ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  LIBRARY_NAME = ::T.let(nil, ::T.untyped)
  MSG_BOTH = ::T.let(nil, ::T.untyped)
  MSG_ENGLISH = ::T.let(nil, ::T.untyped)
  MSG_REGULAR = ::T.let(nil, ::T.untyped)
  NON_ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  PERL_VARS = ::T.let(nil, ::T.untyped)
  STYLE_VARS_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
  MSG_NO_REQUIRE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StaticClass
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StderrPuts
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringChars
  BAD_ARGUMENTS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringConcatenation
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringHashKeys
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringLiterals
  MSG_INCONSISTENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringMethods
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Strip
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StructInheritance
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SwapValues
  MSG = ::T.let(nil, ::T.untyped)
  SIMPLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolArray
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolLiteral
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolProc
  MSG = ::T.let(nil, ::T.untyped)
  SUPER_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TernaryCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
end

class RuboCop::Cop::Style::TernaryParentheses
  MSG = ::T.let(nil, ::T.untyped)
  MSG_COMPLEX = ::T.let(nil, ::T.untyped)
  NON_COMPLEX_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TopLevelMethodDefinition
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnClass
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnModule
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingCommaInBlockArgs
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrivialAccessors
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnlessElse
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnlessLogicalOperators
  FORBID_LOGICAL_OPERATORS = ::T.let(nil, ::T.untyped)
  FORBID_MIXED_LOGICAL_OPERATORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnpackFirst
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::VariableInterpolation
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhenThen
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilDo
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilModifier
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WordArray
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::YodaCondition
  EQUALITY_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NONCOMMUTATIVE_OPERATORS = ::T.let(nil, ::T.untyped)
  PROGRAM_NAMES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  REVERSE_COMPARISON = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::YodaExpression
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ZeroLengthPredicate
  NONZERO_MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  ZERO_MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SurroundingSpace
  NO_SPACE_COMMAND = ::T.let(nil, ::T.untyped)
  SINGLE_SPACE_REGEXP = ::T.let(nil, ::T.untyped)
  SPACE_COMMAND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::TrailingComma
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::UncommunicativeName
  CASE_MSG = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  LENGTH_MSG = ::T.let(nil, ::T.untyped)
  NUM_MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Util
  LITERAL_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Utils::FormatString
  DIGIT_DOLLAR = ::T.let(nil, ::T.untyped)
  FLAG = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  NUMBER_ARG = ::T.let(nil, ::T.untyped)
  PRECISION = ::T.let(nil, ::T.untyped)
  SEQUENCE = ::T.let(nil, ::T.untyped)
  TEMPLATE_NAME = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
  WIDTH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce
  ARGUMENT_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
  LOGICAL_OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MULTIPLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
  REGEXP_NAMED_CAPTURE_TYPE = ::T.let(nil, ::T.untyped)
  RESCUE_TYPE = ::T.let(nil, ::T.untyped)
  SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  SEND_TYPE = ::T.let(nil, ::T.untyped)
  TWISTED_SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_REFERENCE_TYPE = ::T.let(nil, ::T.untyped)
  ZERO_ARITY_SUPER_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Assignment
  MULTIPLE_LEFT_HAND_SIDE_TYPE = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::VariableForce::Branch
  CLASSES_BY_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Reference
  VARIABLE_REFERENCE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Scope
  OUTER_SCOPE_CHILD_INDICES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Variable
  VARIABLE_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::VisibilityHelp
  VISIBILITY_SCOPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::DirectiveComment
  COPS_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAMES_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  DIRECTIVE_COMMENT_REGEXP = ::T.let(nil, ::T.untyped)
  REDUNDANT_DIRECTIVE_COP = ::T.let(nil, ::T.untyped)
  REDUNDANT_DIRECTIVE_COP_DEPARTMENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ClangStyleFormatter
  ELLIPSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::DisabledConfigFormatter
  HEADING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FormatterSet
  BUILTIN_FORMATTERS_FOR_KEYS = ::T.let(nil, ::T.untyped)
  FORMATTER_APIS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FuubarStyleFormatter
  RESET_SEQUENCE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::GitHubActionsFormatter
  ESCAPE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter
  ELLIPSES = ::T.let(nil, ::T.untyped)
  TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::ERBContext
  LOGO_IMAGE_PATH = ::T.let(nil, ::T.untyped)
  SEVERITY_COLORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::PacmanFormatter
  FALLBACK_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
  GHOST = ::T.let(nil, ::T.untyped)
  PACDOT = ::T.let(nil, ::T.untyped)
  PACMAN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ProgressFormatter
  DOT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::SimpleTextFormatter
  COLOR_FOR_SEVERITY = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment
  KEYWORDS = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::EmacsComment
  FORMAT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::VimComment
  FORMAT = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern
end

RuboCop::NodePattern::Builder = RuboCop::AST::NodePattern::Builder

class RuboCop::AST::NodePattern::Compiler
end

RuboCop::NodePattern::Compiler::Debug = RuboCop::AST::NodePattern::Compiler::Debug

class RuboCop::AST::NodePattern::Compiler
end

class RuboCop::AST::NodePattern::Lexer
end

RuboCop::NodePattern::Lexer::Error = RuboCop::AST::NodePattern::LexerRex::ScanError

class RuboCop::AST::NodePattern::Lexer
end

class RuboCop::AST::NodePattern
end

class RuboCop::Options
  DEFAULT_MAXIMUM_EXCLUSION_ITEMS = ::T.let(nil, ::T.untyped)
  EXITING_OPTIONS = ::T.let(nil, ::T.untyped)
  E_STDIN_NO_PATH = ::T.let(nil, ::T.untyped)
end

module RuboCop::OptionsHelp
  FORMATTER_OPTION_LIST = ::T.let(nil, ::T.untyped)
  MAX_EXCL = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
end

module RuboCop::PathUtil
  HIDDEN_FILE_PATTERN = ::T.let(nil, ::T.untyped)
end

RuboCop::ProcessedSource = RuboCop::AST::ProcessedSource

class RuboCop::RemoteConfig
  CACHE_LIFETIME = ::T.let(nil, ::T.untyped)
end

class RuboCop::ResultCache
  DL_EXTENSIONS = ::T.let(nil, ::T.untyped)
  NON_CHANGING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Runner
  MAX_ITERATIONS = ::T.let(nil, ::T.untyped)
  REDUNDANT_COP_DISABLE_DIRECTIVE_RULES = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetFinder
  HIDDEN_PATH_SUBSTRING = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby
  DEFAULT_VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::GemspecFile
  GEMSPEC_EXTENSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::RubyVersionFile
  RUBY_VERSION_FILENAME = ::T.let(nil, ::T.untyped)
  RUBY_VERSION_PATTERN = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetRuby::ToolVersionsFile
  TOOL_VERSIONS_FILENAME = ::T.let(nil, ::T.untyped)
  TOOL_VERSIONS_PATTERN = ::T.let(nil, ::T.untyped)
end

RuboCop::Token = RuboCop::AST::Token

module RuboCop::Version
  CANONICAL_FEATURE_NAMES = ::T.let(nil, ::T.untyped)
  EXTENSION_PATH_NAMES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

class RubyLex
  def check_code_block(code, tokens=T.unsafe(nil)); end

  def check_corresponding_token_depth(lines, line_index); end

  def check_newline_depth_difference(); end

  def check_state(code, tokens=T.unsafe(nil), context: T.unsafe(nil)); end

  def check_string_literal(tokens); end

  def check_termination_in_prev_line(code, context: T.unsafe(nil)); end

  def each_top_level_statement(context); end

  def find_prev_spaces(line_index); end

  def initialize_input(); end

  def is_method_calling?(tokens, index); end

  def is_the_in_correspond_to_a_for(tokens, index); end

  def lex(context); end

  def process_continue(tokens=T.unsafe(nil)); end

  def process_literal_type(tokens=T.unsafe(nil)); end

  def process_nesting_level(tokens=T.unsafe(nil)); end

  def prompt(); end

  def set_auto_indent(context); end

  def set_input(io, p=T.unsafe(nil), context:, &block); end

  def set_prompt(p=T.unsafe(nil), &block); end

  def take_corresponding_syntax_to_kw_do(tokens, index); end
  ERROR_TOKENS = ::T.let(nil, ::T.untyped)
end

class RubyLex::TerminateLineInput
  def initialize(); end
end

class RubyLex::TerminateLineInput
end

class RubyLex
  def self.compile_with_errors_suppressed(code, line_no: T.unsafe(nil)); end

  def self.generate_local_variables_assign_code(local_variables); end

  def self.ripper_lex_without_warning(code, context: T.unsafe(nil)); end
end

class RubyVM::AbstractSyntaxTree::Node
  def all_tokens(); end

  def node_id(); end

  def pretty_print_children(q, names=T.unsafe(nil)); end

  def script_lines(); end

  def source(); end

  def tokens(); end
end

module RubyVM::AbstractSyntaxTree
  def self.node_id_for_backtrace_location(backtrace_location); end
end

class RubyVM::InstructionSequence
  def script_lines(); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(wait: T.unsafe(nil)); end

  def self.resume(); end
end

module RubyVM::YJIT
end

module RubyVM::YJIT
  def self.code_gc(); end

  def self.disasm(iseq); end

  def self.dump_exit_locations(filename); end

  def self.enabled?(); end

  def self.exit_locations(); end

  def self.insns_compiled(iseq); end

  def self.reset_stats!(); end

  def self.runtime_stats(); end

  def self.simulate_oom!(); end

  def self.stats_enabled?(); end

  def self.trace_exit_locations_enabled?(); end
end

class RubyVM
  def self.keep_script_lines(); end

  def self.keep_script_lines=(keep_script_lines); end
end

ScanError = StringScanner::Error

class Set
  def ==(other); end

  def ===(o); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DECnet = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AF_VSOCK = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_DONTFRAG = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DECnet = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_VSOCK = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_CONNECTION_INFO = ::T.let(nil, ::T.untyped)
  TCP_KEEPALIVE = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DECnet = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AF_VSOCK = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_DONTFRAG = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DECnet = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_VSOCK = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_CONNECTION_INFO = ::T.let(nil, ::T.untyped)
  TCP_KEEPALIVE = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Standard
  VERSION = ::T.let(nil, ::T.untyped)
end

class Standard::CreatesConfigStore::ConfiguresIgnoredPaths
  DEFAULT_IGNORES = ::T.let(nil, ::T.untyped)
end

class Standard::CreatesConfigStore::MergesUserConfigExtensions
  DISALLOWED_ALLCOPS_KEYS = ::T.let(nil, ::T.untyped)
end

class Standard::CreatesConfigStore::SetsTargetRubyVersion
  MIN_TARGET_RUBY_VERSION = ::T.let(nil, ::T.untyped)
end

class Standard::Formatter
  STANDARD_GREETING = ::T.let(nil, ::T.untyped)
end

class Standard::LoadsRunner
  RUNNERS = ::T.let(nil, ::T.untyped)
end

Standard::Lsp::Proto = LanguageServer::Protocol

Standard::Lsp::SEV = LanguageServer::Protocol::Constant::DiagnosticSeverity

class Standard::Lsp::Standardizer
  BASE_OPTIONS = ::T.let(nil, ::T.untyped)
end

module Steep
  VERSION = ::T.let(nil, ::T.untyped)
end

module Steep::AST::Builtin
  Array = ::T.let(nil, ::T.untyped)
  BasicObject = ::T.let(nil, ::T.untyped)
  Class = ::T.let(nil, ::T.untyped)
  FalseClass = ::T.let(nil, ::T.untyped)
  Float = ::T.let(nil, ::T.untyped)
  Hash = ::T.let(nil, ::T.untyped)
  Integer = ::T.let(nil, ::T.untyped)
  Module = ::T.let(nil, ::T.untyped)
  NilClass = ::T.let(nil, ::T.untyped)
  Object = ::T.let(nil, ::T.untyped)
  Proc = ::T.let(nil, ::T.untyped)
  Range = ::T.let(nil, ::T.untyped)
  Regexp = ::T.let(nil, ::T.untyped)
  String = ::T.let(nil, ::T.untyped)
  Symbol = ::T.let(nil, ::T.untyped)
  TrueClass = ::T.let(nil, ::T.untyped)
end

class Steep::AnnotationParser
  COLON = ::T.let(nil, ::T.untyped)
  CONST_NAME = ::T.let(nil, ::T.untyped)
  DYNAMIC_NAME = ::T.let(nil, ::T.untyped)
  IVAR_NAME = ::T.let(nil, ::T.untyped)
  METHOD_NAME = ::T.let(nil, ::T.untyped)
  PARAM = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
  TYPE_PARAMS = ::T.let(nil, ::T.untyped)
  VAR_NAME = ::T.let(nil, ::T.untyped)
end

class Steep::Diagnostic::LSPFormatter
  ERROR = ::T.let(nil, ::T.untyped)
  HINT = ::T.let(nil, ::T.untyped)
  INFORMATION = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
end

Steep::Diagnostic::LSPFormatter::LSP = LanguageServer::Protocol

module Steep::Diagnostic::Ruby
  ALL = ::T.let(nil, ::T.untyped)
end

class Steep::Diagnostic::Ruby::UnknownConstantAssigned
  def context(); end

  def initialize(node:, context:, name:); end

  def name(); end
end

class Steep::Diagnostic::Ruby::UnknownConstantAssigned
end

Steep::Drivers::Check::LSP = LanguageServer::Protocol

Steep::Drivers::Checkfile::LSP = LanguageServer::Protocol

Steep::Drivers::DiagnosticPrinter::LSP = LanguageServer::Protocol

class Steep::Drivers::Init
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

Steep::Drivers::Watch::LSP = LanguageServer::Protocol

Steep::Expectations::LSP = LanguageServer::Protocol

Steep::Index::SignatureSymbolProvider::LSP = LanguageServer::Protocol

class Steep::Project::DSL::TargetDSL
  NONE = ::T.let(nil, ::T.untyped)
end

Steep::Server::BaseWorker::LSP = LanguageServer::Protocol

Steep::Server::InteractionWorker::LSP = LanguageServer::Protocol

Steep::Server::Master::LSP = LanguageServer::Protocol

Steep::Signature::Validator::Declarations = RBS::AST::Declarations

Steep::Signature::Validator::Location = RBS::Location

class Steep::TypeConstruction
  KNOWN_PURE_METHODS = ::T.let(nil, ::T.untyped)
  SPECIAL_LVAR_NAMES = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def dedup(); end

  def parse_csv(**options); end

  def shellescape(); end

  def shellsplit(); end
  BLANK_RE = ::T.let(nil, ::T.untyped)
  ENCODED_BLANKS = ::T.let(nil, ::T.untyped)
end

class StringIO
  def set_encoding_by_bom(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class StringIO
  def self.new(*arg); end
end

class StringScanner
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Struct
  def deconstruct(); end

  def deconstruct_keys(arg); end

  def filter(*arg); end
end

class Struct
  def self.new(*arg); end
end

class SyntaxError
  def path(); end
end

module SyntaxSuggest
end

class SyntaxSuggest::MiniStringIO
  def initialize(isatty: T.unsafe(nil)); end

  def isatty(); end

  def puts(value=T.unsafe(nil), **arg); end

  def string(); end
end

class SyntaxSuggest::MiniStringIO
end

module SyntaxSuggest
  def self.module_for_detailed_message(); end
end

module TZInfo
  VERSION = ::T.let(nil, ::T.untyped)
end

class Tempfile
  def _close(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

class Terminal::Table
  VERSION = ::T.let(nil, ::T.untyped)
end

class Terminal::Table::AsciiBorder
  HORIZONTALS = ::T.let(nil, ::T.untyped)
  INTERSECTIONS = ::T.let(nil, ::T.untyped)
  VERTICALS = ::T.let(nil, ::T.untyped)
end

class Terminal::Table::UnicodeBorder
  ALLOWED_SEPARATOR_BORDER_STYLES = ::T.let(nil, ::T.untyped)
  HORIZONTALS = ::T.let(nil, ::T.untyped)
  INTERSECTIONS = ::T.let(nil, ::T.untyped)
  VERTICALS = ::T.let(nil, ::T.untyped)
end

class Thread
  def native_thread_id(); end
end

class Thread::Backtrace
  def self.limit(); end
end

class Thread
  def self.each_caller_location(); end

  def self.ignore_deadlock(); end

  def self.ignore_deadlock=(ignore_deadlock); end

  def self.new(*arg); end
end

class Time
  def deconstruct_keys(arg); end
  COMMON_YEAR_DAYS_IN_MONTH = ::T.let(nil, ::T.untyped)
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

module Timeout
  VERSION = ::T.let(nil, ::T.untyped)
end

module Timeout
  def self.ensure_timeout_thread_created(); end
end

class TracePoint
  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TracePoint
  def self.allow_reentry(); end

  def self.new(*events); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

class TypeError
  include ::ErrorHighlight::CoreExt
end

module URI
  include ::URI::RFC2396_REGEXP
  TBLENCURICOMP_ = ::T.let(nil, ::T.untyped)
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::Generic
  def decoded_password(); end

  def decoded_user(); end
end

class URI::HTTP
  def authority(); end

  def origin(); end
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def initialize(*arg); end
end

class URI::RFC2396_Parser
  def initialize(opts=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

class URI::WSS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::WSS
end

module URI
  def self.decode_uri_component(str, enc=T.unsafe(nil)); end

  def self.for(scheme, *arguments, default: T.unsafe(nil)); end

  def self.get_encoding(label); end

  def self.register_scheme(scheme, klass); end
end

class Unicode::DisplayWidth
  ASCII_NON_ZERO_REGEX = ::T.let(nil, ::T.untyped)
  DATA_DIRECTORY = ::T.let(nil, ::T.untyped)
  FIRST_4096 = ::T.let(nil, ::T.untyped)
  INDEX = ::T.let(nil, ::T.untyped)
  INDEX_FILENAME = ::T.let(nil, ::T.untyped)
  INITIAL_DEPTH = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module UnicodeNormalize
end

module UnicodeNormalize
end

module Warning
  extend ::Warning
end

class WeakRef
  def initialize(orig); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module WebMock
  VERSION = ::T.let(nil, ::T.untyped)
end

class WebMock::BodyPattern
  BODY_FORMATS = ::T.let(nil, ::T.untyped)
end

WebMock::HttpLibAdapters::NetHttpAdapter::OriginalNetHTTP = Net::HTTP

class WebMock::Util::URI
  ADDRESSABLE_URIS = ::T.let(nil, ::T.untyped)
  NORMALIZED_URIS = ::T.let(nil, ::T.untyped)
end

module WebMock::Util::URI::CharacterClasses
  USERINFO = ::T.let(nil, ::T.untyped)
end

class Zlib::Deflate
  def initialize(*arg); end
end

class Zlib::GzipReader
  def initialize(*arg); end
end

class Zlib::GzipReader
  def self.zcat(*arg); end
end

class Zlib::GzipWriter
  def initialize(*arg); end
end

class Zlib::InProgressError
end

class Zlib::InProgressError
end

class Zlib::Inflate
  def initialize(*arg); end
end
